"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry-internal+replay@10.25.0";
exports.ids = ["vendor-chunks/@sentry-internal+replay@10.25.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@sentry-internal+replay@10.25.0/node_modules/@sentry-internal/replay/build/npm/esm/index.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry-internal+replay@10.25.0/node_modules/@sentry-internal/replay/build/npm/esm/index.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getReplay: () => (/* binding */ getReplay),\n/* harmony export */   replayIntegration: () => (/* binding */ replayIntegration)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/worldwide.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/normalize.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/object.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/browser.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/time.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/breadcrumbs.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/debug-logger.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/severity.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/exports.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/misc.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/spanUtils.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/isSentryRequestUrl.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/string.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/debounce.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/envelope.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/prepareEvent.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/ratelimit.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/semanticAttributes.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/isBrowser.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/utils/parseSampleRate.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/metrics/instrument.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/networkUtils.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(ssr)/./node_modules/.pnpm/@sentry-internal+browser-utils@10.25.0/node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js\");\n\n\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and replay packages should `@sentry/browser` import\n// from `@sentry/replay` in the future\nconst WINDOW = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n\nconst REPLAY_SESSION_KEY = 'sentryReplaySession';\nconst REPLAY_EVENT_NAME = 'replay_event';\nconst UNABLE_TO_SEND_REPLAY = 'Unable to send Replay';\n\n// The idle limit for a session after which recording is paused.\nconst SESSION_IDLE_PAUSE_DURATION = 300000; // 5 minutes in ms\n\n// The idle limit for a session after which the session expires.\nconst SESSION_IDLE_EXPIRE_DURATION = 900000; // 15 minutes in ms\n\n/** Default flush delays */\nconst DEFAULT_FLUSH_MIN_DELAY = 5000;\n// XXX: Temp fix for our debounce logic where `maxWait` would never occur if it\n// was the same as `wait`\nconst DEFAULT_FLUSH_MAX_DELAY = 5500;\n\n/* How long to wait for error checkouts */\nconst BUFFER_CHECKOUT_TIME = 60000;\n\nconst RETRY_BASE_INTERVAL = 5000;\nconst RETRY_MAX_COUNT = 3;\n\n/* The max (uncompressed) size in bytes of a network body. Any body larger than this will be truncated. */\nconst NETWORK_BODY_MAX_SIZE = 150000;\n\n/* The max size of a single console arg that is captured. Any arg larger than this will be truncated. */\nconst CONSOLE_ARG_MAX_SIZE = 5000;\n\n/* Min. time to wait before we consider something a slow click. */\nconst SLOW_CLICK_THRESHOLD = 3000;\n/* For scroll actions after a click, we only look for a very short time period to detect programmatic scrolling. */\nconst SLOW_CLICK_SCROLL_TIMEOUT = 300;\n\n/** When encountering a total segment size exceeding this size, stop the replay (as we cannot properly ingest it). */\nconst REPLAY_MAX_EVENT_BUFFER_SIZE = 20000000; // ~20MB\n\n/** Replays must be min. 5s long before we send them. */\nconst MIN_REPLAY_DURATION = 4999;\n/* The max. allowed value that the minReplayDuration can be set to. */\nconst MIN_REPLAY_DURATION_LIMIT = 15000;\n\n/** The max. length of a replay. */\nconst MAX_REPLAY_DURATION = 3600000; // 60 minutes in ms;\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement$1(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction filterCSSPropertiesFromInlineStyle(cssText, ignoredProperties) {\n  if (!cssText || ignoredProperties.size === 0) {\n    return cssText;\n  }\n  try {\n    const properties = cssText.split(\";\");\n    const filteredProperties = [];\n    for (let property of properties) {\n      property = property.trim();\n      if (!property) continue;\n      const colonIndex = property.indexOf(\":\");\n      if (colonIndex === -1) {\n        filteredProperties.push(property);\n        continue;\n      }\n      const propertyName = property.slice(0, colonIndex).trim();\n      if (!ignoredProperties.has(propertyName)) {\n        filteredProperties.push(property);\n      }\n    }\n    return filteredProperties.join(\"; \") + (filteredProperties.length > 0 && cssText.endsWith(\";\") ? \";\" : \"\");\n  } catch (error) {\n    console.warn(\"Error filtering CSS properties:\", error);\n    return cssText;\n  }\n}\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn, ignoreCSSAttributes) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    let processedStyle = absoluteToStylesheet(value, getHref(doc));\n    if (ignoreCSSAttributes && ignoreCSSAttributes.size > 0) {\n      processedStyle = filterCSSPropertiesFromInlineStyle(\n        processedStyle,\n        ignoreCSSAttributes\n      );\n    }\n    return processedStyle;\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    ignoreCSSAttributes\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        ignoreCSSAttributes\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    ignoreCSSAttributes\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn,\n        ignoreCSSAttributes\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false,\n    ignoreCSSAttributes\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement,\n    ignoreCSSAttributes\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onBlockedImageLoad,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn,\n      ignoreCSSAttributes\n    };\n    const childNodes = n2.childNodes ? Array.from(n2.childNodes) : [];\n    for (const childN of childNodes) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement$1(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !serializedNode2.needBlock) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n            ignoreCSSAttributes\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"img\" && !n2.complete && serializedNode2.needBlock) {\n    const image = n2;\n    const updateImageDimensions = () => {\n      if (image.isConnected && !image.complete && onBlockedImageLoad) {\n        try {\n          const rect = image.getBoundingClientRect();\n          if (rect.width > 0 && rect.height > 0) {\n            onBlockedImageLoad(image, serializedNode2, rect);\n          }\n        } catch (error) {\n        }\n      }\n      image.removeEventListener(\"load\", updateImageDimensions);\n    };\n    if (image.isConnected) {\n      image.addEventListener(\"load\", updateImageDimensions);\n    }\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n            ignoreCSSAttributes\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element) {\n    delete serializedNode2.needBlock;\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([])\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false,\n    ignoreCSSAttributes\n  });\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle$1(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout$2(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode$1(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode$1(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2)\n  );\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$2(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          },\n          onBlockedImageLoad: (_imageEl, serializedNode, { width, height }) => {\n            this.mutationCb({\n              adds: [],\n              removes: [],\n              texts: [],\n              attributes: [\n                {\n                  id: serializedNode.id,\n                  attributes: {\n                    style: {\n                      width: `${width}px`,\n                      height: `${height}px`\n                    }\n                  }\n                }\n              ]\n            });\n          },\n          ignoreCSSAttributes: this.ignoreCSSAttributes\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode$1(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case \"attributes\": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === \"value\") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = \"rr_src\";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n            target.setAttribute(\"data-rr-is-password\", \"true\");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === \"style\") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement(\"span\");\n              if (m.oldValue) {\n                old.setAttribute(\"style\", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === \"\") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === \"\") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case \"childList\": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        if (n2.childNodes) {\n          n2.childNodes.forEach((childN) => this.genAdds(childN));\n        }\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      \"mutationCb\",\n      \"blockClass\",\n      \"blockSelector\",\n      \"unblockSelector\",\n      \"maskAllText\",\n      \"maskTextClass\",\n      \"unmaskTextClass\",\n      \"maskTextSelector\",\n      \"unmaskTextSelector\",\n      \"inlineStylesheet\",\n      \"maskInputOptions\",\n      \"maskAttributeFn\",\n      \"maskTextFn\",\n      \"maskInputFn\",\n      \"keepIframeSrcFn\",\n      \"recordCanvas\",\n      \"inlineImages\",\n      \"slimDOMOptions\",\n      \"dataURLOptions\",\n      \"doc\",\n      \"mirror\",\n      \"iframeManager\",\n      \"stylesheetManager\",\n      \"shadowDomManager\",\n      \"canvasManager\",\n      \"processedNodeManager\",\n      \"ignoreCSSAttributes\"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes?.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle$1(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on(\"mousemove\", updatePosition, doc),\n    on(\"touchmove\", updatePosition, doc),\n    on(\"drag\", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            \"mouse\",\n            \"pointer\"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle$1(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle$1(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    \"value\"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, \"value\"],\n    [currentWindow.HTMLInputElement.prototype, \"checked\"],\n    [currentWindow.HTMLSelectElement.prototype, \"value\"],\n    [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n    [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    \"adoptedStyleSheets\"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle$1(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on(\"play\", handler(MediaInteractions.Play), doc),\n    on(\"pause\", handler(MediaInteractions.Pause), doc),\n    on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n    on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n    on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    \"add\",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    \"define\",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        \"message\",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          [\"id\", \"parentId\", \"previousId\", \"nextId\"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                \"parentId\",\n                \"nextId\",\n                \"previousId\"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        \"attachShadow\",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager,\n      ignoreCSSAttributes\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      onBlockedImageLoad: (_imageEl, serializedNode, { width, height }) => {\n        wrappedMutationEmit({\n          adds: [],\n          removes: [],\n          texts: [],\n          attributes: [\n            {\n              id: serializedNode.id,\n              attributes: {\n                style: {\n                  width: `${width}px`,\n                  height: `${height}px`\n                }\n              }\n            }\n          ]\n        });\n      },\n      keepIframeSrcFn,\n      ignoreCSSAttributes\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(\n        on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\") init();\n        })\n      );\n      handlers.push(\n        on(\n          \"load\",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === \"load\") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\n\nconst ReplayEventTypeIncrementalSnapshot = 3;\nconst ReplayEventTypeCustom = 5;\n\n/**\n * Converts a timestamp to ms, if it was in s, or keeps it as ms.\n */\nfunction timestampToMs(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp : timestamp * 1000;\n}\n\n/**\n * Converts a timestamp to s, if it was in ms, or keeps it as s.\n */\nfunction timestampToS(timestamp) {\n  const isMs = timestamp > 9999999999;\n  return isMs ? timestamp / 1000 : timestamp;\n}\n\n/**\n * Add a breadcrumb event to replay.\n */\nfunction addBreadcrumbEvent(replay, breadcrumb) {\n  if (breadcrumb.category === 'sentry.transaction') {\n    return;\n  }\n\n  if (['ui.click', 'ui.input'].includes(breadcrumb.category )) {\n    replay.triggerUserActivity();\n  } else {\n    replay.checkAndHandleExpiredSession();\n  }\n\n  replay.addUpdate(() => {\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n      // but maybe we should just keep them as milliseconds\n      timestamp: (breadcrumb.timestamp || 0) * 1000,\n      data: {\n        tag: 'breadcrumb',\n        // normalize to max. 10 depth and 1_000 properties per object\n        payload: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.normalize)(breadcrumb, 10, 1000),\n      },\n    });\n\n    // Do not flush after console log messages\n    return breadcrumb.category === 'console';\n  });\n}\n\nconst INTERACTIVE_SELECTOR = 'button,a';\n\n/** Get the closest interactive parent element, or else return the given element. */\nfunction getClosestInteractive(element) {\n  const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n  return closestInteractive || element;\n}\n\n/**\n * For clicks, we check if the target is inside of a button or link\n * If so, we use this as the target instead\n * This is useful because if you click on the image in <button><img></button>,\n * The target will be the image, not the button, which we don't want here\n */\nfunction getClickTargetNode(event) {\n  const target = getTargetNode(event);\n\n  if (!target || !(target instanceof Element)) {\n    return target;\n  }\n\n  return getClosestInteractive(target);\n}\n\n/** Get the event target node. */\nfunction getTargetNode(event) {\n  if (isEventWithTarget(event)) {\n    return event.target ;\n  }\n\n  return event;\n}\n\nfunction isEventWithTarget(event) {\n  return typeof event === 'object' && !!event && 'target' in event;\n}\n\nlet handlers;\n\n/**\n * Register a handler to be called when `window.open()` is called.\n * Returns a cleanup function.\n */\nfunction onWindowOpen(cb) {\n  // Ensure to only register this once\n  if (!handlers) {\n    handlers = [];\n    monkeyPatchWindowOpen();\n  }\n\n  handlers.push(cb);\n\n  return () => {\n    const pos = handlers ? handlers.indexOf(cb) : -1;\n    if (pos > -1) {\n      (handlers ).splice(pos, 1);\n    }\n  };\n}\n\nfunction monkeyPatchWindowOpen() {\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.fill)(WINDOW, 'open', function (originalWindowOpen) {\n    return function (...args) {\n      if (handlers) {\n        try {\n          handlers.forEach(handler => handler());\n        } catch {\n          // ignore errors in here\n        }\n      }\n\n      return originalWindowOpen.apply(WINDOW, args);\n    };\n  });\n}\n\n/** Any IncrementalSource for rrweb that we interpret as a kind of mutation. */\nconst IncrementalMutationSources = new Set([\n  IncrementalSource.Mutation,\n  IncrementalSource.StyleSheetRule,\n  IncrementalSource.StyleDeclaration,\n  IncrementalSource.AdoptedStyleSheet,\n  IncrementalSource.CanvasMutation,\n  IncrementalSource.Selection,\n  IncrementalSource.MediaInteraction,\n]);\n\n/** Handle a click. */\nfunction handleClick(clickDetector, clickBreadcrumb, node) {\n  clickDetector.handleClick(clickBreadcrumb, node);\n}\n\n/** A click detector class that can be used to detect slow or rage clicks on elements. */\nclass ClickDetector  {\n  // protected for testing\n\n   constructor(\n    replay,\n    slowClickConfig,\n    // Just for easier testing\n    _addBreadcrumbEvent = addBreadcrumbEvent,\n  ) {\n    this._lastMutation = 0;\n    this._lastScroll = 0;\n    this._clicks = [];\n\n    // We want everything in s, but options are in ms\n    this._timeout = slowClickConfig.timeout / 1000;\n    this._threshold = slowClickConfig.threshold / 1000;\n    this._scrollTimeout = slowClickConfig.scrollTimeout / 1000;\n    this._replay = replay;\n    this._ignoreSelector = slowClickConfig.ignoreSelector;\n    this._addBreadcrumbEvent = _addBreadcrumbEvent;\n  }\n\n  /** Register click detection handlers on mutation or scroll. */\n   addListeners() {\n    const cleanupWindowOpen = onWindowOpen(() => {\n      // Treat window.open as mutation\n      this._lastMutation = nowInSeconds();\n    });\n\n    this._teardown = () => {\n      cleanupWindowOpen();\n\n      this._clicks = [];\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n    };\n  }\n\n  /** Clean up listeners. */\n   removeListeners() {\n    if (this._teardown) {\n      this._teardown();\n    }\n\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n  }\n\n  /** @inheritDoc */\n   handleClick(breadcrumb, node) {\n    if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n      return;\n    }\n\n    const newClick = {\n      timestamp: timestampToS(breadcrumb.timestamp),\n      clickBreadcrumb: breadcrumb,\n      // Set this to 0 so we know it originates from the click breadcrumb\n      clickCount: 0,\n      node,\n    };\n\n    // If there was a click in the last 1s on the same element, ignore it - only keep a single reference per second\n    if (\n      this._clicks.some(click => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)\n    ) {\n      return;\n    }\n\n    this._clicks.push(newClick);\n\n    // If this is the first new click, set a timeout to check for multi clicks\n    if (this._clicks.length === 1) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** @inheritDoc */\n   registerMutation(timestamp = Date.now()) {\n    this._lastMutation = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerScroll(timestamp = Date.now()) {\n    this._lastScroll = timestampToS(timestamp);\n  }\n\n  /** @inheritDoc */\n   registerClick(element) {\n    const node = getClosestInteractive(element);\n    this._handleMultiClick(node );\n  }\n\n  /** Count multiple clicks on elements. */\n   _handleMultiClick(node) {\n    this._getClicks(node).forEach(click => {\n      click.clickCount++;\n    });\n  }\n\n  /** Get all pending clicks for a given node. */\n   _getClicks(node) {\n    return this._clicks.filter(click => click.node === node);\n  }\n\n  /** Check the clicks that happened. */\n   _checkClicks() {\n    const timedOutClicks = [];\n\n    const now = nowInSeconds();\n\n    this._clicks.forEach(click => {\n      if (!click.mutationAfter && this._lastMutation) {\n        click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : undefined;\n      }\n      if (!click.scrollAfter && this._lastScroll) {\n        click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : undefined;\n      }\n\n      // All of these are in seconds!\n      if (click.timestamp + this._timeout <= now) {\n        timedOutClicks.push(click);\n      }\n    });\n\n    // Remove \"old\" clicks\n    for (const click of timedOutClicks) {\n      const pos = this._clicks.indexOf(click);\n\n      if (pos > -1) {\n        this._generateBreadcrumbs(click);\n        this._clicks.splice(pos, 1);\n      }\n    }\n\n    // Trigger new check, unless no clicks left\n    if (this._clicks.length) {\n      this._scheduleCheckClicks();\n    }\n  }\n\n  /** Generate matching breadcrumb(s) for the click. */\n   _generateBreadcrumbs(click) {\n    const replay = this._replay;\n    const hadScroll = click.scrollAfter && click.scrollAfter <= this._scrollTimeout;\n    const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n\n    const isSlowClick = !hadScroll && !hadMutation;\n    const { clickCount, clickBreadcrumb } = click;\n\n    // Slow click\n    if (isSlowClick) {\n      // If `mutationAfter` is set, it means a mutation happened after the threshold, but before the timeout\n      // If not, it means we just timed out without scroll & mutation\n      const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1000;\n      const endReason = timeAfterClickMs < this._timeout * 1000 ? 'mutation' : 'timeout';\n\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.slowClickDetected',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          timeAfterClickMs,\n          endReason,\n          // If clickCount === 0, it means multiClick was not correctly captured here\n          // - we still want to send 1 in this case\n          clickCount: clickCount || 1,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n      return;\n    }\n\n    // Multi click\n    if (clickCount > 1) {\n      const breadcrumb = {\n        type: 'default',\n        message: clickBreadcrumb.message,\n        timestamp: clickBreadcrumb.timestamp,\n        category: 'ui.multiClick',\n        data: {\n          ...clickBreadcrumb.data,\n          url: WINDOW.location.href,\n          route: replay.getCurrentRoute(),\n          clickCount,\n          metric: true,\n        },\n      };\n\n      this._addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n\n  /** Schedule to check current clicks. */\n   _scheduleCheckClicks() {\n    if (this._checkClickTimeout) {\n      clearTimeout(this._checkClickTimeout);\n    }\n\n    this._checkClickTimeout = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(() => this._checkClicks(), 1000);\n  }\n}\n\nconst SLOW_CLICK_TAGS = ['A', 'BUTTON', 'INPUT'];\n\n/** exported for tests only */\nfunction ignoreElement(node, ignoreSelector) {\n  if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n    return true;\n  }\n\n  // If <input> tag, we only want to consider input[type='submit'] & input[type='button']\n  if (node.tagName === 'INPUT' && !['submit', 'button'].includes(node.getAttribute('type') || '')) {\n    return true;\n  }\n\n  // If <a> tag, detect special variants that may not lead to an action\n  // If target !== _self, we may open the link somewhere else, which would lead to no action\n  // Also, when downloading a file, we may not leave the page, but still not trigger an action\n  if (\n    node.tagName === 'A' &&\n    (node.hasAttribute('download') || (node.hasAttribute('target') && node.getAttribute('target') !== '_self'))\n  ) {\n    return true;\n  }\n\n  if (ignoreSelector && node.matches(ignoreSelector)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isClickBreadcrumb(breadcrumb) {\n  return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === 'number' && breadcrumb.timestamp);\n}\n\n// This is good enough for us, and is easier to test/mock than `timestampInSeconds`\nfunction nowInSeconds() {\n  return Date.now() / 1000;\n}\n\n/** Update the click detector based on a recording event of rrweb. */\nfunction updateClickDetectorForRecordingEvent(clickDetector, event) {\n  try {\n    // note: We only consider incremental snapshots here\n    // This means that any full snapshot is ignored for mutation detection - the reason is that we simply cannot know if a mutation happened here.\n    // E.g. think that we are buffering, an error happens and we take a full snapshot because we switched to session mode -\n    // in this scenario, we would not know if a dead click happened because of the error, which is a key dead click scenario.\n    // Instead, by ignoring full snapshots, we have the risk that we generate a false positive\n    // (if a mutation _did_ happen but was \"swallowed\" by the full snapshot)\n    // But this should be more unlikely as we'd generally capture the incremental snapshot right away\n\n    if (!isIncrementalEvent(event)) {\n      return;\n    }\n\n    const { source } = event.data;\n    if (IncrementalMutationSources.has(source)) {\n      clickDetector.registerMutation(event.timestamp);\n    }\n\n    if (source === IncrementalSource.Scroll) {\n      clickDetector.registerScroll(event.timestamp);\n    }\n\n    if (isIncrementalMouseInteraction(event)) {\n      const { type, id } = event.data;\n      const node = record.mirror.getNode(id);\n\n      if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n        clickDetector.registerClick(node);\n      }\n    }\n  } catch {\n    // ignore errors here, e.g. if accessing something that does not exist\n  }\n}\n\nfunction isIncrementalEvent(event) {\n  return event.type === ReplayEventTypeIncrementalSnapshot;\n}\n\nfunction isIncrementalMouseInteraction(\n  event,\n) {\n  return event.data.source === IncrementalSource.MouseInteraction;\n}\n\n/**\n * Create a breadcrumb for a replay.\n */\nfunction createBreadcrumb(\n  breadcrumb,\n) {\n  return {\n    timestamp: Date.now() / 1000,\n    type: 'default',\n    ...breadcrumb,\n  };\n}\n\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType || {});\n\n// Note that these are the serialized attributes and not attributes directly on\n// the DOM Node. Attributes we are interested in:\nconst ATTRIBUTES_TO_RECORD = new Set([\n  'id',\n  'class',\n  'aria-label',\n  'role',\n  'name',\n  'alt',\n  'title',\n  'data-test-id',\n  'data-testid',\n  'disabled',\n  'aria-disabled',\n  'data-sentry-component',\n]);\n\n/**\n * Inclusion list of attributes that we want to record from the DOM element\n */\nfunction getAttributesToRecord(attributes) {\n  const obj = {};\n  if (!attributes['data-sentry-component'] && attributes['data-sentry-element']) {\n    attributes['data-sentry-component'] = attributes['data-sentry-element'];\n  }\n  for (const key in attributes) {\n    if (ATTRIBUTES_TO_RECORD.has(key)) {\n      let normalizedKey = key;\n\n      if (key === 'data-testid' || key === 'data-test-id') {\n        normalizedKey = 'testId';\n      }\n\n      obj[normalizedKey] = attributes[key];\n    }\n  }\n\n  return obj;\n}\n\nconst handleDomListener = (\n  replay,\n) => {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleDom(handlerData);\n\n    if (!result) {\n      return;\n    }\n\n    const isClick = handlerData.name === 'click';\n    const event = isClick ? (handlerData.event ) : undefined;\n    // Ignore clicks if ctrl/alt/meta/shift keys are held down as they alter behavior of clicks (e.g. open in new tab)\n    if (\n      isClick &&\n      replay.clickDetector &&\n      event?.target &&\n      !event.altKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      handleClick(\n        replay.clickDetector,\n        result ,\n        getClickTargetNode(handlerData.event ) ,\n      );\n    }\n\n    addBreadcrumbEvent(replay, result);\n  };\n};\n\n/** Get the base DOM breadcrumb. */\nfunction getBaseDomBreadcrumb(target, message) {\n  const nodeId = record.mirror.getId(target);\n  const node = nodeId && record.mirror.getNode(nodeId);\n  const meta = node && record.mirror.getMeta(node);\n  const element = meta && isElement(meta) ? meta : null;\n\n  return {\n    message,\n    data: element\n      ? {\n          nodeId,\n          node: {\n            id: nodeId,\n            tagName: element.tagName,\n            textContent: Array.from(element.childNodes)\n              .map((node) => node.type === NodeType.Text && node.textContent)\n              .filter(Boolean) // filter out empty values\n              .map(text => (text ).trim())\n              .join(''),\n            attributes: getAttributesToRecord(element.attributes),\n          },\n        }\n      : {},\n  };\n}\n\n/**\n * An event handler to react to DOM events.\n * Exported for tests.\n */\nfunction handleDom(handlerData) {\n  const { target, message } = getDomTarget(handlerData);\n\n  return createBreadcrumb({\n    category: `ui.${handlerData.name}`,\n    ...getBaseDomBreadcrumb(target, message),\n  });\n}\n\nfunction getDomTarget(handlerData) {\n  const isClick = handlerData.name === 'click';\n\n  let message;\n  let target = null;\n\n  // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n  try {\n    target = isClick ? getClickTargetNode(handlerData.event ) : getTargetNode(handlerData.event );\n    message = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.htmlTreeAsString)(target, { maxStringLength: 200 }) || '<unknown>';\n  } catch {\n    message = '<unknown>';\n  }\n\n  return { target, message };\n}\n\nfunction isElement(node) {\n  return node.type === NodeType.Element;\n}\n\n/** Handle keyboard events & create breadcrumbs. */\nfunction handleKeyboardEvent(replay, event) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  // Update user activity, but do not restart recording as it can create\n  // noisy/low-value replays (e.g. user comes back from idle, hits alt-tab, new\n  // session with a single \"keydown\" breadcrumb is created)\n  replay.updateUserActivity();\n\n  const breadcrumb = getKeyboardBreadcrumb(event);\n\n  if (!breadcrumb) {\n    return;\n  }\n\n  addBreadcrumbEvent(replay, breadcrumb);\n}\n\n/** exported only for tests */\nfunction getKeyboardBreadcrumb(event) {\n  const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n\n  // never capture for input fields\n  if (!target || isInputElement(target ) || !key) {\n    return null;\n  }\n\n  // Note: We do not consider shift here, as that means \"uppercase\"\n  const hasModifierKey = metaKey || ctrlKey || altKey;\n  const isCharacterKey = key.length === 1; // other keys like Escape, Tab, etc have a longer length\n\n  // Do not capture breadcrumb if only a word key is pressed\n  // This could leak e.g. user input\n  if (!hasModifierKey && isCharacterKey) {\n    return null;\n  }\n\n  const message = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.htmlTreeAsString)(target, { maxStringLength: 200 }) || '<unknown>';\n  const baseBreadcrumb = getBaseDomBreadcrumb(target , message);\n\n  return createBreadcrumb({\n    category: 'ui.keyDown',\n    message,\n    data: {\n      ...baseBreadcrumb.data,\n      metaKey,\n      shiftKey,\n      ctrlKey,\n      altKey,\n      key,\n    },\n  });\n}\n\nfunction isInputElement(target) {\n  return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;\n}\n\n// Map entryType -> function to normalize data for event\nconst ENTRY_TYPES\n\n = {\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  resource: createResourceEntry,\n  paint: createPaintEntry,\n  // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n  navigation: createNavigationEntry,\n};\n\n/**\n * Handler creater for web vitals\n */\nfunction webVitalHandler(\n  getter,\n  replay,\n) {\n  return ({ metric }) => void replay.replayPerformanceEntries.push(getter(metric));\n}\n\n/**\n * Create replay performance entries from the browser performance entries.\n */\nfunction createPerformanceEntries(\n  entries,\n) {\n  return entries.map(createPerformanceEntry).filter(Boolean) ;\n}\n\nfunction createPerformanceEntry(entry) {\n  const entryType = ENTRY_TYPES[entry.entryType];\n  if (!entryType) {\n    return null;\n  }\n\n  return entryType(entry);\n}\n\nfunction getAbsoluteTime(time) {\n  // browserPerformanceTimeOrigin can be undefined if `performance` or\n  // `performance.now` doesn't exist, but this is already checked by this integration\n  return (((0,_sentry_core__WEBPACK_IMPORTED_MODULE_5__.browserPerformanceTimeOrigin)() || WINDOW.performance.timeOrigin) + time) / 1000;\n}\n\nfunction createPaintEntry(entry) {\n  const { duration, entryType, name, startTime } = entry;\n\n  const start = getAbsoluteTime(startTime);\n  return {\n    type: entryType,\n    name,\n    start,\n    end: start + duration,\n    data: undefined,\n  };\n}\n\nfunction createNavigationEntry(entry) {\n  const {\n    entryType,\n    name,\n    decodedBodySize,\n    duration,\n    domComplete,\n    encodedBodySize,\n    domContentLoadedEventStart,\n    domContentLoadedEventEnd,\n    domInteractive,\n    loadEventStart,\n    loadEventEnd,\n    redirectCount,\n    startTime,\n    transferSize,\n    type,\n  } = entry;\n\n  // Ignore entries with no duration, they do not seem to be useful and cause dupes\n  if (duration === 0) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${type}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(domComplete),\n    name,\n    data: {\n      size: transferSize,\n      decodedBodySize,\n      encodedBodySize,\n      duration,\n      domInteractive,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      loadEventStart,\n      loadEventEnd,\n      domComplete,\n      redirectCount,\n    },\n  };\n}\n\nfunction createResourceEntry(\n  entry,\n) {\n  const {\n    entryType,\n    initiatorType,\n    name,\n    responseEnd,\n    startTime,\n    decodedBodySize,\n    encodedBodySize,\n    responseStatus,\n    transferSize,\n  } = entry;\n\n  // Core SDK handles these\n  if (['fetch', 'xmlhttprequest'].includes(initiatorType)) {\n    return null;\n  }\n\n  return {\n    type: `${entryType}.${initiatorType}`,\n    start: getAbsoluteTime(startTime),\n    end: getAbsoluteTime(responseEnd),\n    name,\n    data: {\n      size: transferSize,\n      statusCode: responseStatus,\n      decodedBodySize,\n      encodedBodySize,\n    },\n  };\n}\n\n/**\n * Add a LCP event to the replay based on a LCP metric.\n */\nfunction getLargestContentfulPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.element ? [lastEntry.element] : undefined;\n  return getWebVital(metric, 'largest-contentful-paint', node);\n}\n\nfunction isLayoutShift(entry) {\n  return (entry ).sources !== undefined;\n}\n\n/**\n * Add a CLS event to the replay based on a CLS metric.\n */\nfunction getCumulativeLayoutShift(metric) {\n  const layoutShifts = [];\n  const nodes = [];\n  for (const entry of metric.entries) {\n    if (isLayoutShift(entry)) {\n      const nodeIds = [];\n      for (const source of entry.sources) {\n        if (source.node) {\n          nodes.push(source.node);\n          const nodeId = record.mirror.getId(source.node);\n          if (nodeId) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n      layoutShifts.push({ value: entry.value, nodeIds: nodeIds.length ? nodeIds : undefined });\n    }\n  }\n\n  return getWebVital(metric, 'cumulative-layout-shift', nodes, layoutShifts);\n}\n\n/**\n * Add an INP event to the replay based on an INP metric.\n */\nfunction getInteractionToNextPaint(metric) {\n  const lastEntry = metric.entries[metric.entries.length - 1] ;\n  const node = lastEntry?.target ? [lastEntry.target] : undefined;\n  return getWebVital(metric, 'interaction-to-next-paint', node);\n}\n\n/**\n * Add an web vital event to the replay based on the web vital metric.\n */\nfunction getWebVital(\n  metric,\n  name,\n  nodes,\n  attributions,\n) {\n  const value = metric.value;\n  const rating = metric.rating;\n\n  const end = getAbsoluteTime(value);\n\n  return {\n    type: 'web-vital',\n    name,\n    start: end,\n    end,\n    data: {\n      value,\n      size: value,\n      rating,\n      nodeIds: nodes ? nodes.map(node => record.mirror.getId(node)) : undefined,\n      attributions,\n    },\n  };\n}\n\n/**\n * Sets up a PerformanceObserver to listen to all performance entry types.\n * Returns a callback to stop observing.\n */\nfunction setupPerformanceObserver(replay) {\n  function addPerformanceEntry(entry) {\n    // It is possible for entries to come up multiple times\n    if (!replay.performanceEntries.includes(entry)) {\n      replay.performanceEntries.push(entry);\n    }\n  }\n\n  function onEntries({ entries }) {\n    entries.forEach(addPerformanceEntry);\n  }\n\n  const clearCallbacks = [];\n\n  (['navigation', 'paint', 'resource'] ).forEach(type => {\n    clearCallbacks.push((0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addPerformanceInstrumentationHandler)(type, onEntries));\n  });\n\n  clearCallbacks.push(\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addLcpInstrumentationHandler)(webVitalHandler(getLargestContentfulPaint, replay)),\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addClsInstrumentationHandler)(webVitalHandler(getCumulativeLayoutShift, replay)),\n    (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_6__.addInpInstrumentationHandler)(webVitalHandler(getInteractionToNextPaint, replay)),\n  );\n\n  // A callback to cleanup all handlers\n  return () => {\n    clearCallbacks.forEach(clearCallback => clearCallback());\n  };\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nconst r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),s=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),a=function(t,e){for(var i=new n(31),s=0;s<31;++s)i[s]=e+=1<<t[s-1];var a=new r(i[30]);for(s=1;s<30;++s)for(var o=i[s];o<i[s+1];++o)a[o]=o-i[s]<<5|s;return{b:i,r:a}},o=a(e,2),h=o.b,f=o.r;h[28]=258,f[258]=28;for(var l=a(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,s=0,a=new n(r);s<i;++s)t[s]&&++a[t[s]-1];var o,h=new n(r);for(s=1;s<r;++s)h[s]=h[s-1]+a[s-1]<<1;if(e){o=new n(1<<r);var f=15-r;for(s=0;s<i;++s)if(t[s])for(var l=s<<4|t[s],c=r-t[s],v=h[t[s]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>f]=l}else for(o=new n(i),s=0;s<i;++s)t[s]&&(o[s]=u[h[t[s]-1]++]>>15-t[s]);return o},p=new t(288);for(c=0;c<144;++c)p[c]=8;for(c=144;c<256;++c)p[c]=9;for(c=256;c<280;++c)p[c]=7;for(c=280;c<288;++c)p[c]=8;var g=new t(32);for(c=0;c<32;++c)g[c]=5;var w=d(p,9,0),y=d(g,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},_=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},x=function(r,e){for(var i=[],s=0;s<r.length;++s)r[s]&&i.push({s:s,f:r[s]});var a=i.length,o=i.slice();if(!a)return{t:F,l:0};if(1==a){var h=new t(i[0].s+1);return h[i[0].s]=1,{t:h,l:1}}i.sort(function(t,n){return t.f-n.f}),i.push({s:-1,f:25001});var f=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:f.f+l.f,l:f,r:l};c!=a-1;)f=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:f.f+l.f,l:f,r:l};var d=o[0].s;for(s=1;s<a;++s)o[s].s>d&&(d=o[s].s);var p=new n(d+1),g=A(i[c-1],p,0);if(g>e){s=0;var w=0,y=g-e,m=1<<y;for(o.sort(function(t,n){return p[n.s]-p[t.s]||t.f-n.f});s<a;++s){var b=o[s].s;if(!(p[b]>e))break;w+=m-(1<<g-p[b]),p[b]=e}for(w>>=y;w>0;){var M=o[s].s;p[M]<e?w-=1<<e-p[M]++-1:++s}for(;s>=0&&w;--s){var E=o[s].s;p[E]==e&&(--p[E],++w)}g=e}return{t:new t(p),l:g}},A=function(t,n,r){return-1==t.s?Math.max(A(t.l,n,r+1),A(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,s=t[0],a=1,o=function(t){e[i++]=t},h=1;h<=r;++h)if(t[h]==s&&h!=r)++a;else{if(!s&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0)}else if(a>3){for(o(s),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0)}for(;a--;)o(s);a=1,s=t[h]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<e;++s)t[i+s+4]=r[s];return 8*(i+4+e)},U=function(t,r,a,o,h,f,l,u,c,v,m){z(r,m++,a),++h[256];for(var b=x(h,15),M=b.t,E=b.l,A=x(f,15),U=A.t,C=A.l,F=D(M),I=F.c,S=F.n,L=D(U),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=x(q,7),H=G.t,J=G.l,K=19;K>4&&!H[s[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(h,p)+T(f,g)+l,X=T(h,M)+T(f,U)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(U,C,0),R=U;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[s[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=w,P=p,Q=y,R=g;for(B=0;B<u;++B){var rt=o[B];if(rt>255){_(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;_(r,m,Q[et]),m+=R[et],et>3&&(_(r,m,rt>>5&8191),m+=i[et])}else _(r,m,N[rt]),m+=P[rt]}return _(r,m,N[256]),m+P[256]},C=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,s=0|r.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=e+=r[a];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(s,a,o,h,u){if(!u&&(u={l:1},a.dictionary)){var c=a.dictionary.subarray(-32768),v=new t(c.length+s.length);v.set(c),v.set(s,c.length),s=v,u.w=c.length}return function(s,a,o,h,u,c){var v=c.z||s.length,d=new t(h+v+5*(1+Math.ceil(v/7e3))+u),p=d.subarray(h,d.length-u),g=c.l,w=7&(c.r||0);if(a){w&&(p[0]=c.r>>3);for(var y=C[a-1],M=y>>13,E=8191&y,z=(1<<o)-1,_=c.p||new n(32768),x=c.h||new n(z+1),A=Math.ceil(o/3),D=2*A,T=function(t){return(s[t]^s[t+1]<<A^s[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=x[H];if(_[J]=K,x[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!g)){w=U(s,p,0,F,I,S,O,q,G,j-G,w),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(s[j+Q]==s[j+Q-W]){for(var $=0;$<Z&&s[j+$]==s[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-_[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=_[J])&32767}if(R){F[q++]=268435456|f[Q]<<18|l[R];var it=31&f[Q],st=31&l[R];O+=e[it]+i[st],++I[257+it],++S[st],B=j+Q,++L}else F[q++]=s[j],++I[s[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=s[j],++I[s[j]];w=U(s,p,g,F,I,S,O,q,G,j-G,w),g||(c.r=7&w|p[w/8|0]<<3,w-=7,c.h=x,c.p=_,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+g;j+=65535){var at=j+65535;at>=v&&(p[w/8|0]=g,at=v),w=k(p,w+1,s.subarray(j,at))}c.i=v}return b(d,0,h+m(w)+u)}(s,null==a.level?6:a.level,null==a.mem?u.l?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(s.length)))):20:12+a.mem,o,h,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(n.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(s),32768),this.s.z=n.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||E(5),this.s.l&&E(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,s=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),a=s.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(s,n),O(s,a-8,r.d()),O(s,a-4,e),s}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t.prototype.flush=function(){j.prototype.flush.call(this)},t}(),G=\"undefined\"!=typeof TextEncoder&&new TextEncoder,H=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(G)return G.encode(n);for(var e=n.length,i=new t(n.length+(n.length>>1)),s=0,a=function(t){i[s++]=t},o=0;o<e;++o){if(s+5>i.length){var h=new t(s+8+(e-o<<1));h.set(i),i=h}var f=n.charCodeAt(o);f<128||r?a(f):f<2048?(a(192|f>>6),a(128|63&f)):f>55295&&f<57344?(a(240|(f=65536+(1047552&f)|1023&n.charCodeAt(++o))>>18),a(128|f>>12&63),a(128|f>>6&63),a(128|63&f)):(a(224|f>>12),a(128|f>>6&63),a(128|63&f))}return b(i,0,s)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J((t,n)=>{this.deflate.push(t,n)}),this.stream.push(\"[\")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener(\"message\",function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&\"function\"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}}),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\n\nfunction e(){const e=new Blob([r]);return URL.createObjectURL(e)}\n\nconst CONSOLE_LEVELS = ['log', 'warn', 'error'] ;\nconst PREFIX = '[Replay] ';\n\nfunction _addBreadcrumb(message, level = 'info') {\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_7__.addBreadcrumb)(\n    {\n      category: 'console',\n      data: {\n        logger: 'replay',\n      },\n      level,\n      message: `${PREFIX}${message}`,\n    },\n    { level },\n  );\n}\n\nfunction makeReplayDebugLogger() {\n  let _capture = false;\n  let _trace = false;\n\n  const _debug = {\n    exception: () => undefined,\n    infoTick: () => undefined,\n    setConfig: (opts) => {\n      _capture = !!opts.captureExceptions;\n      _trace = !!opts.traceInternals;\n    },\n  };\n\n  if (DEBUG_BUILD) {\n    CONSOLE_LEVELS.forEach(name => {\n      _debug[name] = (...args) => {\n        _sentry_core__WEBPACK_IMPORTED_MODULE_8__.debug[name](PREFIX, ...args);\n        if (_trace) {\n          _addBreadcrumb(args.join(''), (0,_sentry_core__WEBPACK_IMPORTED_MODULE_9__.severityLevelFromString)(name));\n        }\n      };\n    });\n\n    _debug.exception = (error, ...message) => {\n      if (message.length && _debug.error) {\n        _debug.error(...message);\n      }\n\n      _sentry_core__WEBPACK_IMPORTED_MODULE_8__.debug.error(PREFIX, error);\n\n      if (_capture) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.captureException)(error, {\n          mechanism: {\n            handled: true,\n            type: 'auto.function.replay.debug',\n          },\n        });\n      } else if (_trace) {\n        // No need for a breadcrumb if `_capture` is enabled since it should be\n        // captured as an exception\n        _addBreadcrumb(error, 'error');\n      }\n    };\n\n    _debug.infoTick = (...args) => {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_8__.debug.log(PREFIX, ...args);\n      if (_trace) {\n        // Wait a tick here to avoid race conditions for some initial logs\n        // which may be added before replay is initialized\n        setTimeout(() => _addBreadcrumb(args[0]), 0);\n      }\n    };\n  } else {\n    CONSOLE_LEVELS.forEach(name => {\n      _debug[name] = () => undefined;\n    });\n  }\n\n  return _debug ;\n}\n\nconst debug = makeReplayDebugLogger();\n\n/** This error indicates that the event buffer size exceeded the limit.. */\nclass EventBufferSizeExceededError extends Error {\n   constructor() {\n    super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n  }\n}\n\n/**\n * A basic event buffer that does not do any compression.\n * Used as fallback if the compression worker cannot be loaded or is disabled.\n */\nclass EventBufferArray  {\n  /** All the events that are buffered to be sent. */\n\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return this.events.length > 0;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return 'sync';\n  }\n\n  /** @inheritdoc */\n   destroy() {\n    this.events = [];\n  }\n\n  /** @inheritdoc */\n   async addEvent(event) {\n    const eventSize = JSON.stringify(event).length;\n    this._totalSize += eventSize;\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      throw new EventBufferSizeExceededError();\n    }\n\n    this.events.push(event);\n  }\n\n  /** @inheritdoc */\n   finish() {\n    return new Promise(resolve => {\n      // Make a copy of the events array reference and immediately clear the\n      // events member so that we do not lose new events while uploading\n      // attachment.\n      const eventsRet = this.events;\n      this.clear();\n      resolve(JSON.stringify(eventsRet));\n    });\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this.events = [];\n    this._totalSize = 0;\n    this.hasCheckout = false;\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    const timestamp = this.events.map(event => event.timestamp).sort()[0];\n\n    if (!timestamp) {\n      return null;\n    }\n\n    return timestampToMs(timestamp);\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass WorkerHandler {\n\n   constructor(worker) {\n    this._worker = worker;\n    this._id = 0;\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    // Ensure we only check once\n    if (this._ensureReadyPromise) {\n      return this._ensureReadyPromise;\n    }\n\n    this._ensureReadyPromise = new Promise((resolve, reject) => {\n      this._worker.addEventListener(\n        'message',\n        ({ data }) => {\n          if ((data ).success) {\n            resolve();\n          } else {\n            reject();\n          }\n        },\n        { once: true },\n      );\n\n      this._worker.addEventListener(\n        'error',\n        error => {\n          reject(error);\n        },\n        { once: true },\n      );\n    });\n\n    return this._ensureReadyPromise;\n  }\n\n  /**\n   * Destroy the worker.\n   */\n   destroy() {\n    DEBUG_BUILD && debug.log('Destroying compression worker');\n    this._worker.terminate();\n  }\n\n  /**\n   * Post message to worker and wait for response before resolving promise.\n   */\n   postMessage(method, arg) {\n    const id = this._getAndIncrementId();\n\n    return new Promise((resolve, reject) => {\n      const listener = ({ data }) => {\n        const response = data ;\n        if (response.method !== method) {\n          return;\n        }\n\n        // There can be multiple listeners for a single method, the id ensures\n        // that the response matches the caller.\n        if (response.id !== id) {\n          return;\n        }\n\n        // At this point, we'll always want to remove listener regardless of result status\n        this._worker.removeEventListener('message', listener);\n\n        if (!response.success) {\n          // TODO: Do some error handling, not sure what\n          DEBUG_BUILD && debug.error('Error in compression worker: ', response.response);\n\n          reject(new Error('Error in compression worker'));\n          return;\n        }\n\n        resolve(response.response );\n      };\n\n      // Note: we can't use `once` option because it's possible it needs to\n      // listen to multiple messages\n      this._worker.addEventListener('message', listener);\n      this._worker.postMessage({ id, method, arg });\n    });\n  }\n\n  /** Get the current ID and increment it for the next call. */\n   _getAndIncrementId() {\n    return this._id++;\n  }\n}\n\n/**\n * Event buffer that uses a web worker to compress events.\n * Exported only for testing.\n */\nclass EventBufferCompressionWorker  {\n  /** @inheritdoc */\n\n  /** @inheritdoc */\n\n   constructor(worker) {\n    this._worker = new WorkerHandler(worker);\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n    this.waitForCheckout = false;\n  }\n\n  /** @inheritdoc */\n   get hasEvents() {\n    return !!this._earliestTimestamp;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return 'worker';\n  }\n\n  /**\n   * Ensure the worker is ready (or not).\n   * This will either resolve when the worker is ready, or reject if an error occurred.\n   */\n   ensureReady() {\n    return this._worker.ensureReady();\n  }\n\n  /**\n   * Destroy the event buffer.\n   */\n   destroy() {\n    this._worker.destroy();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully received and processed by worker.\n   */\n   addEvent(event) {\n    const timestamp = timestampToMs(event.timestamp);\n    if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n      this._earliestTimestamp = timestamp;\n    }\n\n    const data = JSON.stringify(event);\n    this._totalSize += data.length;\n\n    if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n      return Promise.reject(new EventBufferSizeExceededError());\n    }\n\n    return this._sendEventToWorker(data);\n  }\n\n  /**\n   * Finish the event buffer and return the compressed data.\n   */\n   finish() {\n    return this._finishRequest();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n    this.hasCheckout = false;\n\n    // We do not wait on this, as we assume the order of messages is consistent for the worker\n    this._worker.postMessage('clear').then(null, e => {\n      DEBUG_BUILD && debug.exception(e, 'Sending \"clear\" message to worker failed', e);\n    });\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._earliestTimestamp;\n  }\n\n  /**\n   * Send the event to the worker.\n   */\n   _sendEventToWorker(data) {\n    return this._worker.postMessage('addEvent', data);\n  }\n\n  /**\n   * Finish the request and return the compressed data from the worker.\n   */\n   async _finishRequest() {\n    const response = await this._worker.postMessage('finish');\n\n    this._earliestTimestamp = null;\n    this._totalSize = 0;\n\n    return response;\n  }\n}\n\n/**\n * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.\n * This can happen e.g. if the worker cannot be loaded.\n * Exported only for testing.\n */\nclass EventBufferProxy  {\n\n   constructor(worker) {\n    this._fallback = new EventBufferArray();\n    this._compression = new EventBufferCompressionWorker(worker);\n    this._used = this._fallback;\n\n    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n  }\n\n  /** @inheritdoc */\n   get waitForCheckout() {\n    return this._used.waitForCheckout;\n  }\n\n  /** @inheritdoc */\n   get type() {\n    return this._used.type;\n  }\n\n  /** @inheritDoc */\n   get hasEvents() {\n    return this._used.hasEvents;\n  }\n\n  /** @inheritdoc */\n   get hasCheckout() {\n    return this._used.hasCheckout;\n  }\n  /** @inheritdoc */\n   set hasCheckout(value) {\n    this._used.hasCheckout = value;\n  }\n\n  /** @inheritdoc */\n  // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures\n   set waitForCheckout(value) {\n    this._used.waitForCheckout = value;\n  }\n\n  /** @inheritDoc */\n   destroy() {\n    this._fallback.destroy();\n    this._compression.destroy();\n  }\n\n  /** @inheritdoc */\n   clear() {\n    return this._used.clear();\n  }\n\n  /** @inheritdoc */\n   getEarliestTimestamp() {\n    return this._used.getEarliestTimestamp();\n  }\n\n  /**\n   * Add an event to the event buffer.\n   *\n   * Returns true if event was successfully added.\n   */\n   addEvent(event) {\n    return this._used.addEvent(event);\n  }\n\n  /** @inheritDoc */\n   async finish() {\n    // Ensure the worker is loaded, so the sent event is compressed\n    await this.ensureWorkerIsLoaded();\n\n    return this._used.finish();\n  }\n\n  /** Ensure the worker has loaded. */\n   ensureWorkerIsLoaded() {\n    return this._ensureWorkerIsLoadedPromise;\n  }\n\n  /** Actually check if the worker has been loaded. */\n   async _ensureWorkerIsLoaded() {\n    try {\n      await this._compression.ensureReady();\n    } catch (error) {\n      // If the worker fails to load, we fall back to the simple buffer.\n      // Nothing more to do from our side here\n      DEBUG_BUILD && debug.exception(error, 'Failed to load the compression worker, falling back to simple buffer');\n      return;\n    }\n\n    // Now we need to switch over the array buffer to the compression worker\n    await this._switchToCompressionWorker();\n  }\n\n  /** Switch the used buffer to the compression worker. */\n   async _switchToCompressionWorker() {\n    const { events, hasCheckout, waitForCheckout } = this._fallback;\n\n    const addEventPromises = [];\n    for (const event of events) {\n      addEventPromises.push(this._compression.addEvent(event));\n    }\n\n    this._compression.hasCheckout = hasCheckout;\n    this._compression.waitForCheckout = waitForCheckout;\n\n    // We switch over to the new buffer immediately - any further events will be added\n    // after the previously buffered ones\n    this._used = this._compression;\n\n    // Wait for original events to be re-added before resolving\n    try {\n      await Promise.all(addEventPromises);\n\n      // Can now clear fallback buffer as it's no longer necessary\n      this._fallback.clear();\n    } catch (error) {\n      DEBUG_BUILD && debug.exception(error, 'Failed to add events when switching buffers.');\n    }\n  }\n}\n\n/**\n * Create an event buffer for replays.\n */\nfunction createEventBuffer({\n  useCompression,\n  workerUrl: customWorkerUrl,\n}) {\n  if (\n    useCompression &&\n    // eslint-disable-next-line no-restricted-globals\n    window.Worker\n  ) {\n    const worker = _loadWorker(customWorkerUrl);\n\n    if (worker) {\n      return worker;\n    }\n  }\n\n  DEBUG_BUILD && debug.log('Using simple buffer');\n  return new EventBufferArray();\n}\n\nfunction _loadWorker(customWorkerUrl) {\n  try {\n    const workerUrl = customWorkerUrl || _getWorkerUrl();\n\n    if (!workerUrl) {\n      return;\n    }\n\n    DEBUG_BUILD && debug.log(`Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : ''}`);\n    const worker = new Worker(workerUrl);\n    return new EventBufferProxy(worker);\n  } catch (error) {\n    DEBUG_BUILD && debug.exception(error, 'Failed to create compression worker');\n    // Fall back to use simple event buffer array\n  }\n}\n\nfunction _getWorkerUrl() {\n  if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === 'undefined' || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n    return e();\n  }\n\n  return '';\n}\n\n/** If sessionStorage is available. */\nfunction hasSessionStorage() {\n  try {\n    // This can throw, e.g. when being accessed in a sandboxed iframe\n    return 'sessionStorage' in WINDOW && !!WINDOW.sessionStorage;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Removes the session from Session Storage and unsets session in replay instance\n */\nfunction clearSession(replay) {\n  deleteSession();\n  replay.session = undefined;\n}\n\n/**\n * Deletes a session from storage\n */\nfunction deleteSession() {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Given a sample rate, returns true if replay should be sampled.\n *\n * 1.0 = 100% sampling\n * 0.0 = 0% sampling\n */\nfunction isSampled(sampleRate) {\n  if (sampleRate === undefined) {\n    return false;\n  }\n\n  // Math.random() returns a number in range of 0 to 1 (inclusive of 0, but not 1)\n  return Math.random() < sampleRate;\n}\n\n/**\n * Save a session to session storage.\n */\nfunction saveSession(session) {\n  if (!hasSessionStorage()) {\n    return;\n  }\n\n  try {\n    WINDOW.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n  } catch {\n    // Ignore potential SecurityError exceptions\n  }\n}\n\n/**\n * Get a session with defaults & applied sampling.\n */\nfunction makeSession(session) {\n  const now = Date.now();\n  const id = session.id || (0,_sentry_core__WEBPACK_IMPORTED_MODULE_11__.uuid4)();\n  // Note that this means we cannot set a started/lastActivity of `0`, but this should not be relevant outside of tests.\n  const started = session.started || now;\n  const lastActivity = session.lastActivity || now;\n  const segmentId = session.segmentId || 0;\n  const sampled = session.sampled;\n  const previousSessionId = session.previousSessionId;\n  const dirty = session.dirty || false;\n\n  return {\n    id,\n    started,\n    lastActivity,\n    segmentId,\n    sampled,\n    previousSessionId,\n    dirty,\n  };\n}\n\n/**\n * Get the sampled status for a session based on sample rates & current sampled status.\n */\nfunction getSessionSampleType(sessionSampleRate, allowBuffering) {\n  return isSampled(sessionSampleRate) ? 'session' : allowBuffering ? 'buffer' : false;\n}\n\n/**\n * Create a new session, which in its current implementation is a Sentry event\n * that all replays will be saved to as attachments. Currently, we only expect\n * one of these Sentry events per \"replay session\".\n */\nfunction createSession(\n  { sessionSampleRate, allowBuffering, stickySession = false },\n  { previousSessionId } = {},\n) {\n  const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n  const session = makeSession({\n    sampled,\n    previousSessionId,\n  });\n\n  if (stickySession) {\n    saveSession(session);\n  }\n\n  return session;\n}\n\n/**\n * Fetches a session from storage\n */\nfunction fetchSession() {\n  if (!hasSessionStorage()) {\n    return null;\n  }\n\n  try {\n    // This can throw if cookies are disabled\n    const sessionStringFromStorage = WINDOW.sessionStorage.getItem(REPLAY_SESSION_KEY);\n\n    if (!sessionStringFromStorage) {\n      return null;\n    }\n\n    const sessionObj = JSON.parse(sessionStringFromStorage) ;\n\n    DEBUG_BUILD && debug.infoTick('Loading existing session');\n\n    return makeSession(sessionObj);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given an initial timestamp and an expiry duration, checks to see if current\n * time should be considered as expired.\n */\nfunction isExpired(\n  initialTime,\n  expiry,\n  targetTime = +new Date(),\n) {\n  // Always expired if < 0\n  if (initialTime === null || expiry === undefined || expiry < 0) {\n    return true;\n  }\n\n  // Never expires if == 0\n  if (expiry === 0) {\n    return false;\n  }\n\n  return initialTime + expiry <= targetTime;\n}\n\n/**\n * Checks to see if session is expired\n */\nfunction isSessionExpired(\n  session,\n  {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now(),\n  },\n) {\n  return (\n    // First, check that maximum session length has not been exceeded\n    isExpired(session.started, maxReplayDuration, targetTime) ||\n    // check that the idle timeout has not been exceeded (i.e. user has\n    // performed an action within the last `sessionIdleExpire` ms)\n    isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n  );\n}\n\n/** If the session should be refreshed or not. */\nfunction shouldRefreshSession(\n  session,\n  { sessionIdleExpire, maxReplayDuration },\n) {\n  // If not expired, all good, just keep the session\n  if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n    return false;\n  }\n\n  // If we are buffering & haven't ever flushed yet, always continue\n  if (session.sampled === 'buffer' && session.segmentId === 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Get or create a session, when initializing the replay.\n * Returns a session that may be unsampled.\n */\nfunction loadOrCreateSession(\n  {\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId,\n  }\n\n,\n  sessionOptions,\n) {\n  const existingSession = sessionOptions.stickySession && fetchSession();\n\n  // No session exists yet, just create a new one\n  if (!existingSession) {\n    DEBUG_BUILD && debug.infoTick('Creating new session');\n    return createSession(sessionOptions, { previousSessionId });\n  }\n\n  if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n    return existingSession;\n  }\n\n  DEBUG_BUILD && debug.infoTick('Session in sessionStorage is expired, creating new one...');\n  return createSession(sessionOptions, { previousSessionId: existingSession.id });\n}\n\nfunction isCustomEvent(event) {\n  return event.type === EventType.Custom;\n}\n\n/**\n * Add an event to the event buffer.\n * In contrast to `addEvent`, this does not return a promise & does not wait for the adding of the event to succeed/fail.\n * Instead this returns `true` if we tried to add the event, else false.\n * It returns `false` e.g. if we are paused, disabled, or out of the max replay duration.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEventSync(replay, event, isCheckout) {\n  if (!shouldAddEvent(replay, event)) {\n    return false;\n  }\n\n  // This should never reject\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  _addEvent(replay, event, isCheckout);\n\n  return true;\n}\n\n/**\n * Add an event to the event buffer.\n * Resolves to `null` if no event was added, else to `void`.\n *\n * `isCheckout` is true if this is either the very first event, or an event triggered by `checkoutEveryNms`.\n */\nfunction addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  if (!shouldAddEvent(replay, event)) {\n    return Promise.resolve(null);\n  }\n\n  return _addEvent(replay, event, isCheckout);\n}\n\nasync function _addEvent(\n  replay,\n  event,\n  isCheckout,\n) {\n  const { eventBuffer } = replay;\n\n  if (!eventBuffer || (eventBuffer.waitForCheckout && !isCheckout)) {\n    return null;\n  }\n\n  const isBufferMode = replay.recordingMode === 'buffer';\n\n  try {\n    if (isCheckout && isBufferMode) {\n      eventBuffer.clear();\n    }\n\n    if (isCheckout) {\n      eventBuffer.hasCheckout = true;\n      eventBuffer.waitForCheckout = false;\n    }\n\n    const replayOptions = replay.getOptions();\n\n    const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n\n    if (!eventAfterPossibleCallback) {\n      return;\n    }\n\n    return await eventBuffer.addEvent(eventAfterPossibleCallback);\n  } catch (error) {\n    const isExceeded = error && error instanceof EventBufferSizeExceededError;\n    const reason = isExceeded ? 'addEventSizeExceeded' : 'addEvent';\n    const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n    if (client) {\n      // We are limited in the drop reasons:\n      // https://github.com/getsentry/snuba/blob/6c73be60716c2fb1c30ca627883207887c733cbd/rust_snuba/src/processors/outcomes.rs#L39\n      const dropReason = isExceeded ? 'buffer_overflow' : 'internal_sdk_error';\n      client.recordDroppedEvent(dropReason, 'replay');\n    }\n\n    if (isExceeded && isBufferMode) {\n      // Clear buffer and wait for next checkout\n      eventBuffer.clear();\n      eventBuffer.waitForCheckout = true;\n\n      return null;\n    }\n\n    replay.handleException(error);\n\n    await replay.stop({ reason });\n  }\n}\n\n/** Exported only for tests. */\nfunction shouldAddEvent(replay, event) {\n  if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n    return false;\n  }\n\n  const timestampInMs = timestampToMs(event.timestamp);\n\n  // Throw out events that happen more than 5 minutes ago. This can happen if\n  // page has been left open and idle for a long period of time and user\n  // comes back to trigger a new session. The performance entries rely on\n  // `performance.timeOrigin`, which is when the page first opened.\n  if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n    return false;\n  }\n\n  // Throw out events that are +60min from the initial timestamp\n  if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n    DEBUG_BUILD &&\n      debug.infoTick(`Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`);\n    return false;\n  }\n\n  return true;\n}\n\nfunction maybeApplyCallback(\n  event,\n  callback,\n) {\n  try {\n    if (typeof callback === 'function' && isCustomEvent(event)) {\n      return callback(event);\n    }\n  } catch (error) {\n    DEBUG_BUILD &&\n      debug.exception(error, 'An error occurred in the `beforeAddRecordingEvent` callback, skipping the event...');\n    return null;\n  }\n\n  return event;\n}\n\n/** If the event is an error event */\nfunction isErrorEvent(event) {\n  return !event.type;\n}\n\n/** If the event is a transaction event */\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** If the event is an replay event */\nfunction isReplayEvent(event) {\n  return event.type === 'replay_event';\n}\n\n/** If the event is a feedback event */\nfunction isFeedbackEvent(event) {\n  return event.type === 'feedback';\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleAfterSendEvent(replay) {\n  return (event, sendResponse) => {\n    if (!replay.isEnabled() || (!isErrorEvent(event) && !isTransactionEvent(event))) {\n      return;\n    }\n\n    const statusCode = sendResponse.statusCode;\n\n    // We only want to do stuff on successful error sending, otherwise you get error replays without errors attached\n    // We skip if we encountered an non-OK status code\n    if (!statusCode || statusCode < 200 || statusCode >= 300) {\n      return;\n    }\n\n    if (isTransactionEvent(event)) {\n      handleTransactionEvent(replay, event);\n      return;\n    }\n\n    handleErrorEvent(replay, event);\n  };\n}\n\nfunction handleTransactionEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Collect traceIds in _context regardless of `recordingMode`\n  // In error mode, _context gets cleared on every checkout\n  // We limit to max. 100 transactions linked\n  if (event.contexts?.trace?.trace_id && replayContext.traceIds.size < 100) {\n    replayContext.traceIds.add(event.contexts.trace.trace_id);\n  }\n}\n\nfunction handleErrorEvent(replay, event) {\n  const replayContext = replay.getContext();\n\n  // Add error to list of errorIds of replay. This is ok to do even if not\n  // sampled because context will get reset at next checkout.\n  // XXX: There is also a race condition where it's possible to capture an\n  // error to Sentry before Replay SDK has loaded, but response returns after\n  // it was loaded, and this gets called.\n  // We limit to max. 100 errors linked\n  if (event.event_id && replayContext.errorIds.size < 100) {\n    replayContext.errorIds.add(event.event_id);\n  }\n\n  // If error event is tagged with replay id it means it was sampled (when in buffer mode)\n  // Need to be very careful that this does not cause an infinite loop\n  if (replay.recordingMode !== 'buffer' || !event.tags || !event.tags.replayId) {\n    return;\n  }\n\n  const { beforeErrorSampling } = replay.getOptions();\n  if (typeof beforeErrorSampling === 'function' && !beforeErrorSampling(event)) {\n    return;\n  }\n\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(async () => {\n    try {\n      // Capture current event buffer as new replay\n      await replay.sendBufferedReplayOrFlush();\n    } catch (err) {\n      replay.handleException(err);\n    }\n  });\n}\n\n/**\n * Returns a listener to be added to `client.on('afterSendErrorEvent, listener)`.\n */\nfunction handleBeforeSendEvent(replay) {\n  return (event) => {\n    if (!replay.isEnabled() || !isErrorEvent(event)) {\n      return;\n    }\n\n    handleHydrationError(replay, event);\n  };\n}\n\nfunction handleHydrationError(replay, event) {\n  const exceptionValue = event.exception?.values?.[0]?.value;\n  if (typeof exceptionValue !== 'string') {\n    return;\n  }\n\n  if (\n    // Only matches errors in production builds of react-dom\n    // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n    // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n    exceptionValue.match(\n      /(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/,\n    ) ||\n    // Development builds of react-dom\n    // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n    // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n    exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n  ) {\n    const breadcrumb = createBreadcrumb({\n      category: 'replay.hydrate-error',\n      data: {\n        url: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_4__.getLocationHref)(),\n      },\n    });\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n}\n\n/**\n * Handle breadcrumbs that Sentry captures, and make sure to capture relevant breadcrumbs to Replay as well.\n */\nfunction handleBreadcrumbs(replay) {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  if (!client) {\n    return;\n  }\n\n  client.on('beforeAddBreadcrumb', breadcrumb => beforeAddBreadcrumb(replay, breadcrumb));\n}\n\nfunction beforeAddBreadcrumb(replay, breadcrumb) {\n  if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n    return;\n  }\n\n  const result = normalizeBreadcrumb(breadcrumb);\n  if (result) {\n    addBreadcrumbEvent(replay, result);\n  }\n}\n\n/** Exported only for tests. */\nfunction normalizeBreadcrumb(breadcrumb) {\n  if (\n    !isBreadcrumbWithCategory(breadcrumb) ||\n    [\n      // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n      'fetch',\n      'xhr',\n      // These two are breadcrumbs for emitted sentry events, we don't care about them\n      'sentry.event',\n      'sentry.transaction',\n    ].includes(breadcrumb.category) ||\n    // We capture UI breadcrumbs separately\n    breadcrumb.category.startsWith('ui.')\n  ) {\n    return null;\n  }\n\n  if (breadcrumb.category === 'console') {\n    return normalizeConsoleBreadcrumb(breadcrumb);\n  }\n\n  return createBreadcrumb(breadcrumb);\n}\n\n/** exported for tests only */\nfunction normalizeConsoleBreadcrumb(\n  breadcrumb,\n) {\n  const args = breadcrumb.data?.arguments;\n\n  if (!Array.isArray(args) || args.length === 0) {\n    return createBreadcrumb(breadcrumb);\n  }\n\n  let isTruncated = false;\n\n  // Avoid giant args captures\n  const normalizedArgs = args.map(arg => {\n    if (!arg) {\n      return arg;\n    }\n    if (typeof arg === 'string') {\n      if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n        isTruncated = true;\n        return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}`;\n      }\n\n      return arg;\n    }\n    if (typeof arg === 'object') {\n      try {\n        const normalizedArg = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.normalize)(arg, 7);\n        const stringified = JSON.stringify(normalizedArg);\n        if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          // We use the pretty printed JSON string here as a base\n          return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}`;\n        }\n        return normalizedArg;\n      } catch {\n        // fall back to default\n      }\n    }\n\n    return arg;\n  });\n\n  return createBreadcrumb({\n    ...breadcrumb,\n    data: {\n      ...breadcrumb.data,\n      arguments: normalizedArgs,\n      ...(isTruncated ? { _meta: { warnings: ['CONSOLE_ARG_TRUNCATED'] } } : {}),\n    },\n  });\n}\n\nfunction isBreadcrumbWithCategory(breadcrumb) {\n  return !!breadcrumb.category;\n}\n\n/**\n * Returns true if we think the given event is an error originating inside of rrweb.\n */\nfunction isRrwebError(event, hint) {\n  if (event.type || !event.exception?.values?.length) {\n    return false;\n  }\n\n  // @ts-expect-error this may be set by rrweb when it finds errors\n  if (hint.originalException?.__rrweb__) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reset the `replay_id` field on the DSC.\n */\nfunction resetReplayIdOnDynamicSamplingContext() {\n  // Reset DSC on the current scope, if there is one\n  const dsc = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getCurrentScope)().getPropagationContext().dsc;\n  if (dsc) {\n    delete dsc.replay_id;\n  }\n\n  // Clear it from frozen DSC on the active span\n  const activeSpan = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getActiveSpan)();\n  if (activeSpan) {\n    const dsc = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_14__.getDynamicSamplingContextFromSpan)(activeSpan);\n    delete (dsc ).replay_id;\n  }\n}\n\n/**\n * Add a feedback breadcrumb event to replay.\n */\nfunction addFeedbackBreadcrumb(replay, event) {\n  replay.triggerUserActivity();\n  replay.addUpdate(() => {\n    if (!event.timestamp) {\n      // Ignore events that don't have timestamps (this shouldn't happen, more of a typing issue)\n      // Return true here so that we don't flush\n      return true;\n    }\n\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: event.timestamp * 1000,\n      data: {\n        tag: 'breadcrumb',\n        payload: {\n          timestamp: event.timestamp,\n          type: 'default',\n          category: 'sentry.feedback',\n          data: {\n            feedbackId: event.event_id,\n          },\n        },\n      },\n    } );\n\n    return false;\n  });\n}\n\n/**\n * Determine if event should be sampled (only applies in buffer mode).\n * When an event is captured by `handleGlobalEvent`, when in buffer mode\n * we determine if we want to sample the error or not.\n */\nfunction shouldSampleForBufferEvent(replay, event) {\n  if (replay.recordingMode !== 'buffer') {\n    return false;\n  }\n\n  // ignore this error because otherwise we could loop indefinitely with\n  // trying to capture replay and failing\n  if (event.message === UNABLE_TO_SEND_REPLAY) {\n    return false;\n  }\n\n  // Require the event to be an error event & to have an exception\n  if (!event.exception || event.type) {\n    return false;\n  }\n\n  return isSampled(replay.getOptions().errorSampleRate);\n}\n\n/**\n * Returns a listener to be added to `addEventProcessor(listener)`.\n */\nfunction handleGlobalEventListener(replay) {\n  return Object.assign(\n    (event, hint) => {\n      // Do nothing if replay has been disabled or paused\n      if (!replay.isEnabled() || replay.isPaused()) {\n        return event;\n      }\n\n      if (isReplayEvent(event)) {\n        // Replays have separate set of breadcrumbs, do not include breadcrumbs\n        // from core SDK\n        delete event.breadcrumbs;\n        return event;\n      }\n\n      // We only want to handle errors, transactions, and feedbacks, nothing else\n      if (!isErrorEvent(event) && !isTransactionEvent(event) && !isFeedbackEvent(event)) {\n        return event;\n      }\n\n      // Ensure we do not add replay_id if the session is expired\n      const isSessionActive = replay.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        // prevent exceeding replay durations by removing the expired replayId from the DSC\n        resetReplayIdOnDynamicSamplingContext();\n        return event;\n      }\n\n      if (isFeedbackEvent(event)) {\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        replay.flush();\n        event.contexts.feedback.replay_id = replay.getSessionId();\n        // Add a replay breadcrumb for this piece of feedback\n        addFeedbackBreadcrumb(replay, event);\n        return event;\n      }\n\n      // Unless `captureExceptions` is enabled, we want to ignore errors coming from rrweb\n      // As there can be a bunch of stuff going wrong in internals there, that we don't want to bubble up to users\n      if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n        DEBUG_BUILD && debug.log('Ignoring error from rrweb internals', event);\n        return null;\n      }\n\n      // When in buffer mode, we decide to sample here.\n      // Later, in `handleAfterSendEvent`, if the replayId is set, we know that we sampled\n      // And convert the buffer session to a full session\n      const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n\n      // Tag errors if it has been sampled in buffer mode, or if it is session mode\n      // Only tag transactions if in session mode\n      const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === 'session';\n\n      if (shouldTagReplayId) {\n        event.tags = { ...event.tags, replayId: replay.getSessionId() };\n      }\n\n      // If we sampled this error in buffer mode, immediately mark the session as \"sampled\"\n      // by changing the sampled state from 'buffer' to 'session'. Otherwise, if the application is interrupte\n      // before `afterSendEvent` occurs, then the session would remain as \"buffer\" but we have an error event\n      // that is tagged with a replay id. This could end up creating replays w/ excessive durations because\n      // of the linked error.\n      if (isErrorEventSampled && replay.recordingMode === 'buffer' && replay.session?.sampled === 'buffer') {\n        const session = replay.session;\n        session.dirty = true;\n        // Save the session if sticky sessions are enabled to persist the state change\n        if (replay.getOptions().stickySession) {\n          saveSession(session);\n        }\n      }\n\n      return event;\n    },\n    { id: 'Replay' },\n  );\n}\n\n/**\n * Create a \"span\" for each performance entry.\n */\nfunction createPerformanceSpans(\n  replay,\n  entries,\n) {\n  return entries.map(({ type, start, end, name, data }) => {\n    const response = replay.throttledAddEvent({\n      type: EventType.Custom,\n      timestamp: start,\n      data: {\n        tag: 'performanceSpan',\n        payload: {\n          op: type,\n          description: name,\n          startTimestamp: start,\n          endTimestamp: end,\n          data,\n        },\n      },\n    });\n\n    // If response is a string, it means its either THROTTLED or SKIPPED\n    return typeof response === 'string' ? Promise.resolve(null) : response;\n  });\n}\n\nfunction handleHistory(handlerData) {\n  const { from, to } = handlerData;\n\n  const now = Date.now() / 1000;\n\n  return {\n    type: 'navigation.push',\n    start: now,\n    end: now,\n    name: to,\n    data: {\n      previous: from,\n    },\n  };\n}\n\n/**\n * Returns a listener to be added to `addHistoryInstrumentationHandler(listener)`.\n */\nfunction handleHistorySpanListener(replay) {\n  return (handlerData) => {\n    if (!replay.isEnabled()) {\n      return;\n    }\n\n    const result = handleHistory(handlerData);\n\n    if (result === null) {\n      return;\n    }\n\n    // Need to collect visited URLs\n    replay.getContext().urls.push(result.name);\n    replay.triggerUserActivity();\n\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      // Returning false to flush\n      return false;\n    });\n  };\n}\n\n/**\n * Check whether a given request URL should be filtered out. This is so we\n * don't log Sentry ingest requests.\n */\nfunction shouldFilterRequest(replay, url) {\n  // If we enabled the `traceInternals` experiment, we want to trace everything\n  if (DEBUG_BUILD && replay.getOptions()._experiments.traceInternals) {\n    return false;\n  }\n\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_15__.isSentryRequestUrl)(url, (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)());\n}\n\n/** Add a performance entry breadcrumb */\nfunction addNetworkBreadcrumb(\n  replay,\n  result,\n) {\n  if (!replay.isEnabled()) {\n    return;\n  }\n\n  if (result === null) {\n    return;\n  }\n\n  if (shouldFilterRequest(replay, result.name)) {\n    return;\n  }\n\n  replay.addUpdate(() => {\n    createPerformanceSpans(replay, [result]);\n    // Returning true will cause `addUpdate` to not flush\n    // We do not want network requests to cause a flush. This will prevent\n    // recurring/polling requests from keeping the replay session alive.\n    return true;\n  });\n}\n\n/** Get the size of a body. */\nfunction getBodySize(body) {\n  if (!body) {\n    return undefined;\n  }\n\n  const textEncoder = new TextEncoder();\n\n  try {\n    if (typeof body === 'string') {\n      return textEncoder.encode(body).length;\n    }\n\n    if (body instanceof URLSearchParams) {\n      return textEncoder.encode(body.toString()).length;\n    }\n\n    if (body instanceof FormData) {\n      const formDataStr = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.serializeFormData)(body);\n      return textEncoder.encode(formDataStr).length;\n    }\n\n    if (body instanceof Blob) {\n      return body.size;\n    }\n\n    if (body instanceof ArrayBuffer) {\n      return body.byteLength;\n    }\n\n    // Currently unhandled types: ArrayBufferView, ReadableStream\n  } catch {\n    // just return undefined\n  }\n\n  return undefined;\n}\n\n/** Convert a Content-Length header to number/undefined.  */\nfunction parseContentLengthHeader(header) {\n  if (!header) {\n    return undefined;\n  }\n\n  const size = parseInt(header, 10);\n  return isNaN(size) ? undefined : size;\n}\n\n/** Merge a warning into an existing network request/response. */\nfunction mergeWarning(\n  info,\n  warning,\n) {\n  if (!info) {\n    return {\n      headers: {},\n      size: undefined,\n      _meta: {\n        warnings: [warning],\n      },\n    };\n  }\n\n  const newMeta = { ...info._meta };\n  const existingWarnings = newMeta.warnings || [];\n  newMeta.warnings = [...existingWarnings, warning];\n\n  info._meta = newMeta;\n  return info;\n}\n\n/** Convert ReplayNetworkRequestData to a PerformanceEntry. */\nfunction makeNetworkReplayBreadcrumb(\n  type,\n  data,\n) {\n  if (!data) {\n    return null;\n  }\n\n  const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n\n  const result = {\n    type,\n    start: startTimestamp / 1000,\n    end: endTimestamp / 1000,\n    name: url,\n    data: {\n      method,\n      statusCode,\n      request,\n      response,\n    },\n  };\n\n  return result;\n}\n\n/** Build the request or response part of a replay network breadcrumb that was skipped. */\nfunction buildSkippedNetworkRequestOrResponse(bodySize) {\n  return {\n    headers: {},\n    size: bodySize,\n    _meta: {\n      warnings: ['URL_SKIPPED'],\n    },\n  };\n}\n\n/** Build the request or response part of a replay network breadcrumb. */\nfunction buildNetworkRequestOrResponse(\n  headers,\n  bodySize,\n  body,\n) {\n  if (!bodySize && Object.keys(headers).length === 0) {\n    return undefined;\n  }\n\n  if (!bodySize) {\n    return {\n      headers,\n    };\n  }\n\n  if (!body) {\n    return {\n      headers,\n      size: bodySize,\n    };\n  }\n\n  const info = {\n    headers,\n    size: bodySize,\n  };\n\n  const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n  info.body = normalizedBody;\n  if (warnings?.length) {\n    info._meta = {\n      warnings,\n    };\n  }\n\n  return info;\n}\n\n/** Filter a set of headers */\nfunction getAllowedHeaders(headers, allowedHeaders) {\n  return Object.entries(headers).reduce((filteredHeaders, [key, value]) => {\n    const normalizedKey = key.toLowerCase();\n    // Avoid putting empty strings into the headers\n    if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n      filteredHeaders[normalizedKey] = value;\n    }\n    return filteredHeaders;\n  }, {});\n}\n\nfunction normalizeNetworkBody(body)\n\n {\n  if (!body || typeof body !== 'string') {\n    return {\n      body,\n    };\n  }\n\n  const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n  const isProbablyJson = _strIsProbablyJson(body);\n\n  if (exceedsSizeLimit) {\n    const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n\n    if (isProbablyJson) {\n      return {\n        body: truncatedBody,\n        warnings: ['MAYBE_JSON_TRUNCATED'],\n      };\n    }\n\n    return {\n      body: `${truncatedBody}`,\n      warnings: ['TEXT_TRUNCATED'],\n    };\n  }\n\n  if (isProbablyJson) {\n    try {\n      const jsonBody = JSON.parse(body);\n      return {\n        body: jsonBody,\n      };\n    } catch {\n      // fall back to just send the body as string\n    }\n  }\n\n  return {\n    body,\n  };\n}\n\nfunction _strIsProbablyJson(str) {\n  const first = str[0];\n  const last = str[str.length - 1];\n\n  // Simple check: If this does not start & end with {} or [], it's not JSON\n  return (first === '[' && last === ']') || (first === '{' && last === '}');\n}\n\n/** Match an URL against a list of strings/Regex. */\nfunction urlMatches(url, urls) {\n  const fullUrl = getFullUrl(url);\n\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_17__.stringMatchesSomePattern)(fullUrl, urls);\n}\n\n/** exported for tests */\nfunction getFullUrl(url, baseURI = WINDOW.document.baseURI) {\n  // Short circuit for common cases:\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith(WINDOW.location.origin)) {\n    return url;\n  }\n  const fixedUrl = new URL(url, baseURI);\n\n  // If these do not match, we are not dealing with a relative URL, so just return it\n  if (fixedUrl.origin !== new URL(baseURI).origin) {\n    return url;\n  }\n\n  const fullUrl = fixedUrl.href;\n\n  // Remove trailing slashes, if they don't match the original URL\n  if (!url.endsWith('/') && fullUrl.endsWith('/')) {\n    return fullUrl.slice(0, -1);\n  }\n\n  return fullUrl;\n}\n\n/**\n * Capture a fetch breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureFetchBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options\n\n,\n) {\n  try {\n    const data = await _prepareFetchData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.fetch', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && debug.exception(error, 'Failed to capture fetch breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichFetchBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { input, response } = hint;\n\n  const body = input ? (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getFetchRequestArgBody)(input) : undefined;\n  const reqSize = getBodySize(body);\n\n  const resSize = response ? parseContentLengthHeader(response.headers.get('content-length')) : undefined;\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nasync function _prepareFetchData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  const captureDetails =\n    urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n\n  const request = captureDetails\n    ? _getRequestInfo(options, hint.input, requestBodySize)\n    : buildSkippedNetworkRequestOrResponse(requestBodySize);\n  const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request,\n    response,\n  };\n}\n\nfunction _getRequestInfo(\n  { networkCaptureBodies, networkRequestHeaders },\n  input,\n  requestBodySize,\n) {\n  const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n\n  if (!networkCaptureBodies) {\n    return buildNetworkRequestOrResponse(headers, requestBodySize, undefined);\n  }\n\n  // We only want to transmit string or string-like bodies\n  const requestBody = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getFetchRequestArgBody)(input);\n  const [bodyStr, warning] = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getBodyString)(requestBody, debug);\n  const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n\n  if (warning) {\n    return mergeWarning(data, warning);\n  }\n\n  return data;\n}\n\n/** Exported only for tests. */\nasync function _getResponseInfo(\n  captureDetails,\n  {\n    networkCaptureBodies,\n    networkResponseHeaders,\n  },\n  response,\n  responseBodySize,\n) {\n  if (!captureDetails && responseBodySize !== undefined) {\n    return buildSkippedNetworkRequestOrResponse(responseBodySize);\n  }\n\n  const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n\n  if (!response || (!networkCaptureBodies && responseBodySize !== undefined)) {\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n\n  const [bodyText, warning] = await _parseFetchResponseBody(response);\n  const result = getResponseData(bodyText, {\n    networkCaptureBodies,\n\n    responseBodySize,\n    captureDetails,\n    headers,\n  });\n\n  if (warning) {\n    return mergeWarning(result, warning);\n  }\n\n  return result;\n}\n\nfunction getResponseData(\n  bodyText,\n  {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers,\n  }\n\n,\n) {\n  try {\n    const size = bodyText?.length && responseBodySize === undefined ? getBodySize(bodyText) : responseBodySize;\n\n    if (!captureDetails) {\n      return buildSkippedNetworkRequestOrResponse(size);\n    }\n\n    if (networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, size, bodyText);\n    }\n\n    return buildNetworkRequestOrResponse(headers, size, undefined);\n  } catch (error) {\n    DEBUG_BUILD && debug.exception(error, 'Failed to serialize response body');\n    // fallback\n    return buildNetworkRequestOrResponse(headers, responseBodySize, undefined);\n  }\n}\n\nasync function _parseFetchResponseBody(response) {\n  const res = _tryCloneResponse(response);\n\n  if (!res) {\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  try {\n    const text = await _tryGetResponseText(res);\n    return [text];\n  } catch (error) {\n    if (error instanceof Error && error.message.indexOf('Timeout') > -1) {\n      DEBUG_BUILD && debug.warn('Parsing text body from response timed out');\n      return [undefined, 'BODY_PARSE_TIMEOUT'];\n    }\n\n    DEBUG_BUILD && debug.exception(error, 'Failed to get text body from response');\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n}\n\nfunction getAllHeaders(headers, allowedHeaders) {\n  const allHeaders = {};\n\n  allowedHeaders.forEach(header => {\n    if (headers.get(header)) {\n      allHeaders[header] = headers.get(header) ;\n    }\n  });\n\n  return allHeaders;\n}\n\nfunction getRequestHeaders(fetchArgs, allowedHeaders) {\n  if (fetchArgs.length === 1 && typeof fetchArgs[0] !== 'string') {\n    return getHeadersFromOptions(fetchArgs[0] , allowedHeaders);\n  }\n\n  if (fetchArgs.length === 2) {\n    return getHeadersFromOptions(fetchArgs[1] , allowedHeaders);\n  }\n\n  return {};\n}\n\nfunction getHeadersFromOptions(\n  input,\n  allowedHeaders,\n) {\n  if (!input) {\n    return {};\n  }\n\n  const headers = input.headers;\n\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    return getAllHeaders(headers, allowedHeaders);\n  }\n\n  // We do not support this, as it is not really documented (anymore?)\n  if (Array.isArray(headers)) {\n    return {};\n  }\n\n  return getAllowedHeaders(headers, allowedHeaders);\n}\n\nfunction _tryCloneResponse(response) {\n  try {\n    // We have to clone this, as the body can only be read once\n    return response.clone();\n  } catch (error) {\n    // this can throw if the response was already consumed before\n    DEBUG_BUILD && debug.exception(error, 'Failed to clone response body');\n  }\n}\n\n/**\n * Get the response body of a fetch request, or timeout after 500ms.\n * Fetch can return a streaming body, that may not resolve (or not for a long time).\n * If that happens, we rather abort after a short time than keep waiting for this.\n */\nfunction _tryGetResponseText(response) {\n  return new Promise((resolve, reject) => {\n    const timeout = (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(() => reject(new Error('Timeout while trying to read response body')), 500);\n\n    _getResponseText(response)\n      .then(\n        txt => resolve(txt),\n        reason => reject(reason),\n      )\n      .finally(() => clearTimeout(timeout));\n  });\n}\n\nasync function _getResponseText(response) {\n  // Force this to be a promise, just to be safe\n  // eslint-disable-next-line no-return-await\n  return await response.text();\n}\n\n/**\n * Capture an XHR breadcrumb to a replay.\n * This adds additional data (where appropriate).\n */\nasync function captureXhrBreadcrumbToReplay(\n  breadcrumb,\n  hint,\n  options,\n) {\n  try {\n    const data = _prepareXhrData(breadcrumb, hint, options);\n\n    // Create a replay performance entry from this breadcrumb\n    const result = makeNetworkReplayBreadcrumb('resource.xhr', data);\n    addNetworkBreadcrumb(options.replay, result);\n  } catch (error) {\n    DEBUG_BUILD && debug.exception(error, 'Failed to capture xhr breadcrumb');\n  }\n}\n\n/**\n * Enrich a breadcrumb with additional data.\n * This has to be sync & mutate the given breadcrumb,\n * as the breadcrumb is afterwards consumed by other handlers.\n */\nfunction enrichXhrBreadcrumb(\n  breadcrumb,\n  hint,\n) {\n  const { xhr, input } = hint;\n\n  if (!xhr) {\n    return;\n  }\n\n  const reqSize = getBodySize(input);\n  const resSize = xhr.getResponseHeader('content-length')\n    ? parseContentLengthHeader(xhr.getResponseHeader('content-length'))\n    : _getBodySize(xhr.response, xhr.responseType);\n\n  if (reqSize !== undefined) {\n    breadcrumb.data.request_body_size = reqSize;\n  }\n  if (resSize !== undefined) {\n    breadcrumb.data.response_body_size = resSize;\n  }\n}\n\nfunction _prepareXhrData(\n  breadcrumb,\n  hint,\n  options,\n) {\n  const now = Date.now();\n  const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n\n  const {\n    url,\n    method,\n    status_code: statusCode = 0,\n    request_body_size: requestBodySize,\n    response_body_size: responseBodySize,\n  } = breadcrumb.data;\n\n  if (!url) {\n    return null;\n  }\n\n  if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n    const request = buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = buildSkippedNetworkRequestOrResponse(responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response,\n    };\n  }\n\n  // ---- This additional network data below is only captured for URLs defined in `networkDetailAllowUrls` ----\n\n  const xhrInfo = xhr[_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_18__.SENTRY_XHR_DATA_KEY];\n  const networkRequestHeaders = xhrInfo\n    ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders)\n    : {};\n  const networkResponseHeaders = getAllowedHeaders((0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.parseXhrResponseHeaders)(xhr), options.networkResponseHeaders);\n\n  const [requestBody, requestWarning] = options.networkCaptureBodies ? (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_16__.getBodyString)(input, debug) : [undefined];\n  const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [undefined];\n\n  const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n  const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n\n  return {\n    startTimestamp,\n    endTimestamp,\n    url,\n    method,\n    statusCode,\n    request: requestWarning ? mergeWarning(request, requestWarning) : request,\n    response: responseWarning ? mergeWarning(response, responseWarning) : response,\n  };\n}\n\nfunction _getXhrResponseBody(xhr) {\n  // We collect errors that happen, but only log them if we can't get any response body\n  const errors = [];\n\n  try {\n    return [xhr.responseText];\n  } catch (e) {\n    errors.push(e);\n  }\n\n  // Try to manually parse the response body, if responseText fails\n  try {\n    return _parseXhrResponse(xhr.response, xhr.responseType);\n  } catch (e) {\n    errors.push(e);\n  }\n\n  DEBUG_BUILD && debug.warn('Failed to get xhr response body', ...errors);\n\n  return [undefined];\n}\n\n/**\n * Get the string representation of the XHR response.\n * Based on MDN, these are the possible types of the response:\n * string\n * ArrayBuffer\n * Blob\n * Document\n * POJO\n *\n * Exported only for tests.\n */\nfunction _parseXhrResponse(\n  body,\n  responseType,\n) {\n  try {\n    if (typeof body === 'string') {\n      return [body];\n    }\n\n    if (body instanceof Document) {\n      return [body.body.outerHTML];\n    }\n\n    if (responseType === 'json' && body && typeof body === 'object') {\n      return [JSON.stringify(body)];\n    }\n\n    if (!body) {\n      return [undefined];\n    }\n  } catch (error) {\n    DEBUG_BUILD && debug.exception(error, 'Failed to serialize body', body);\n    return [undefined, 'BODY_PARSE_ERROR'];\n  }\n\n  DEBUG_BUILD && debug.log('Skipping network body because of body type', body);\n\n  return [undefined, 'UNPARSEABLE_BODY_TYPE'];\n}\n\nfunction _getBodySize(\n  body,\n  responseType,\n) {\n  try {\n    const bodyStr = responseType === 'json' && body && typeof body === 'object' ? JSON.stringify(body) : body;\n    return getBodySize(bodyStr);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * This method does two things:\n * - It enriches the regular XHR/fetch breadcrumbs with request/response size data\n * - It captures the XHR/fetch breadcrumbs to the replay\n *   (enriching it with further data that is _not_ added to the regular breadcrumbs)\n */\nfunction handleNetworkBreadcrumbs(replay) {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  try {\n    const {\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    } = replay.getOptions();\n\n    const options = {\n      replay,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders,\n      networkResponseHeaders,\n    };\n\n    if (client) {\n      client.on('beforeAddBreadcrumb', (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n    }\n  } catch {\n    // Do nothing\n  }\n}\n\n/** just exported for tests */\nfunction beforeAddNetworkBreadcrumb(\n  options,\n  breadcrumb,\n  hint,\n) {\n  if (!breadcrumb.data) {\n    return;\n  }\n\n  try {\n    if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichXhrBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n\n    if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n      // This has to be sync, as we need to ensure the breadcrumb is enriched in the same tick\n      // Because the hook runs synchronously, and the breadcrumb is afterwards passed on\n      // So any async mutations to it will not be reflected in the final breadcrumb\n      enrichFetchBreadcrumb(breadcrumb, hint);\n\n      // This call should not reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n    }\n  } catch (e) {\n    DEBUG_BUILD && debug.exception(e, 'Error when enriching network breadcrumb');\n  }\n}\n\nfunction _isXhrBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'xhr';\n}\n\nfunction _isFetchBreadcrumb(breadcrumb) {\n  return breadcrumb.category === 'fetch';\n}\n\nfunction _isXhrHint(hint) {\n  return hint?.xhr;\n}\n\nfunction _isFetchHint(hint) {\n  return hint?.response;\n}\n\n/**\n * Add global listeners that cannot be removed.\n */\nfunction addGlobalListeners(replay) {\n  // Listeners from core SDK //\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_19__.addClickKeypressInstrumentationHandler)(handleDomListener(replay));\n  (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_20__.addHistoryInstrumentationHandler)(handleHistorySpanListener(replay));\n  handleBreadcrumbs(replay);\n  handleNetworkBreadcrumbs(replay);\n\n  // Tag all (non replay) events that get sent to Sentry with the current\n  // replay ID so that we can reference them later in the UI\n  const eventProcessor = handleGlobalEventListener(replay);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.addEventProcessor)(eventProcessor);\n\n  // If a custom client has no hooks yet, we continue to use the \"old\" implementation\n  if (client) {\n    client.on('beforeSendEvent', handleBeforeSendEvent(replay));\n    client.on('afterSendEvent', handleAfterSendEvent(replay));\n    client.on('createDsc', (dsc) => {\n      const replayId = replay.getSessionId();\n      // We do not want to set the DSC when in buffer mode, as that means the replay has not been sent (yet)\n      if (replayId && replay.isEnabled() && replay.recordingMode === 'session') {\n        // Ensure to check that the session is still active - it could have expired in the meanwhile\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (isSessionActive) {\n          dsc.replay_id = replayId;\n        }\n      }\n    });\n\n    client.on('spanStart', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We may be missing the initial spanStart due to timing issues,\n    // so we capture it on finish again.\n    client.on('spanEnd', span => {\n      replay.lastActiveSpan = span;\n    });\n\n    // We want to attach the replay id to the feedback event\n    client.on('beforeSendFeedback', async (feedbackEvent, options) => {\n      const replayId = replay.getSessionId();\n      if (options?.includeReplay && replay.isEnabled() && replayId && feedbackEvent.contexts?.feedback) {\n        // In case the feedback is sent via API and not through our widget, we want to flush replay\n        if (feedbackEvent.contexts.feedback.source === 'api') {\n          await replay.sendBufferedReplayOrFlush();\n        }\n        feedbackEvent.contexts.feedback.replay_id = replayId;\n      }\n    });\n\n    client.on('openFeedbackWidget', async () => {\n      await replay.sendBufferedReplayOrFlush();\n    });\n  }\n}\n\n/**\n * Create a \"span\" for the total amount of memory being used by JS objects\n * (including v8 internal objects).\n */\nasync function addMemoryEntry(replay) {\n  // window.performance.memory is a non-standard API and doesn't work on all browsers, so we try-catch this\n  try {\n    return Promise.all(\n      createPerformanceSpans(replay, [\n        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n        createMemoryEntry(WINDOW.performance.memory),\n      ]),\n    );\n  } catch {\n    // Do nothing\n    return [];\n  }\n}\n\nfunction createMemoryEntry(memoryEntry) {\n  const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n  // we don't want to use `getAbsoluteTime` because it adds the event time to the\n  // time origin, so we get the current timestamp instead\n  const time = Date.now() / 1000;\n  return {\n    type: 'memory',\n    name: 'memory',\n    start: time,\n    end: time,\n    data: {\n      memory: {\n        jsHeapSizeLimit,\n        totalJSHeapSize,\n        usedJSHeapSize,\n      },\n    },\n  };\n}\n\n/**\n * Heavily simplified debounce function based on lodash.debounce.\n *\n * This function takes a callback function (@param fun) and delays its invocation\n * by @param wait milliseconds. Optionally, a maxWait can be specified in @param options,\n * which ensures that the callback is invoked at least once after the specified max. wait time.\n *\n * @param func the function whose invocation is to be debounced\n * @param wait the minimum time until the function is invoked after it was called once\n * @param options the options object, which can contain the `maxWait` property\n *\n * @returns the debounced version of the function, which needs to be called at least once to start the\n *          debouncing process. Subsequent calls will reset the debouncing timer and, in case @paramfunc\n *          was already invoked in the meantime, return @param func's return value.\n *          The debounced function has two additional properties:\n *          - `flush`: Invokes the debounced function immediately and returns its return value\n *          - `cancel`: Cancels the debouncing process and resets the debouncing timer\n */\nfunction debounce(func, wait, options) {\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_21__.debounce)(func, wait, {\n    ...options,\n    // @ts-expect-error - Not quite sure why these types do not match, but this is fine\n    setTimeoutImpl: _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout,\n  });\n}\n\nconst NAVIGATOR = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.navigator;\n\n/**\n *  Disable sampling mousemove events on iOS browsers as this can cause blocking the main thread\n *  https://github.com/getsentry/sentry-javascript/issues/14534\n */\nfunction getRecordingSamplingOptions() {\n  if (\n    /iPhone|iPad|iPod/i.test(NAVIGATOR?.userAgent ?? '') ||\n    (/Macintosh/i.test(NAVIGATOR?.userAgent ?? '') && NAVIGATOR?.maxTouchPoints && NAVIGATOR?.maxTouchPoints > 1)\n  ) {\n    return {\n      sampling: {\n        mousemove: false,\n      },\n    };\n  }\n\n  return {};\n}\n\n/**\n * Handler for recording events.\n *\n * Adds to event buffer, and has varying flushing behaviors if the event was a checkout.\n */\nfunction getHandleRecordingEmit(replay) {\n  let hadFirstEvent = false;\n\n  return (event, _isCheckout) => {\n    // If this is false, it means session is expired, create and a new session and wait for checkout\n    if (!replay.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && debug.warn('Received replay event after session expired.');\n\n      return;\n    }\n\n    // `_isCheckout` is only set when the checkout is due to `checkoutEveryNms`\n    // We also want to treat the first event as a checkout, so we handle this specifically here\n    const isCheckout = _isCheckout || !hadFirstEvent;\n    hadFirstEvent = true;\n\n    if (replay.clickDetector) {\n      updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n    }\n\n    // The handler returns `true` if we do not want to trigger debounced flush, `false` if we want to debounce flush.\n    replay.addUpdate(() => {\n      // The session is always started immediately on pageload/init, but for\n      // error-only replays, it should reflect the most recent checkout\n      // when an error occurs. Clear any state that happens before this current\n      // checkout. This needs to happen before `addEvent()` which updates state\n      // dependent on this reset.\n      if (replay.recordingMode === 'buffer' && isCheckout) {\n        replay.setInitialState();\n      }\n\n      // If the event is not added (e.g. due to being paused, disabled, or out of the max replay duration),\n      // Skip all further steps\n      if (!addEventSync(replay, event, isCheckout)) {\n        // Return true to skip scheduling a debounced flush\n        return true;\n      }\n\n      // Different behavior for full snapshots (type=2), ignore other event types\n      // See https://github.com/rrweb-io/rrweb/blob/d8f9290ca496712aa1e7d472549480c4e7876594/packages/rrweb/src/types.ts#L16\n      if (!isCheckout) {\n        return false;\n      }\n\n      const session = replay.session;\n\n      // Additionally, create a meta event that will capture certain SDK settings.\n      // In order to handle buffer mode, this needs to either be done when we\n      // receive checkout events or at flush time. We have an experimental mode\n      // to perform multiple checkouts a session (the idea is to improve\n      // seeking during playback), so also only include if segmentId is 0\n      // (handled in `addSettingsEvent`).\n      //\n      // `isCheckout` is always true, but want to be explicit that it should\n      // only be added for checkouts\n      addSettingsEvent(replay, isCheckout);\n\n      // When in buffer mode, make sure we adjust the session started date to the current earliest event of the buffer\n      // this should usually be the timestamp of the checkout event, but to be safe...\n      if (replay.recordingMode === 'buffer' && session && replay.eventBuffer && !session.dirty) {\n        const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n        if (earliestEvent) {\n          DEBUG_BUILD &&\n            debug.log(`Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`);\n\n          session.started = earliestEvent;\n\n          if (replay.getOptions().stickySession) {\n            saveSession(session);\n          }\n        }\n      }\n\n      // If there is a previousSessionId after a full snapshot occurs, then\n      // the replay session was started due to session expiration. The new session\n      // is started before triggering a new checkout and contains the id\n      // of the previous session. Do not immediately flush in this case\n      // to avoid capturing only the checkout and instead the replay will\n      // be captured if they perform any follow-up actions.\n      if (session?.previousSessionId) {\n        return true;\n      }\n\n      if (replay.recordingMode === 'session') {\n        // If the full snapshot is due to an initial load, we will not have\n        // a previous session ID. In this case, we want to buffer events\n        // for a set amount of time before flushing. This can help avoid\n        // capturing replays of users that immediately close the window.\n\n        // This should never reject\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        void replay.flush();\n      }\n\n      return true;\n    });\n  };\n}\n\n/**\n * Exported for tests\n */\nfunction createOptionsEvent(replay) {\n  const options = replay.getOptions();\n  return {\n    type: EventType.Custom,\n    timestamp: Date.now(),\n    data: {\n      tag: 'options',\n      payload: {\n        shouldRecordCanvas: replay.isRecordingCanvas(),\n        sessionSampleRate: options.sessionSampleRate,\n        errorSampleRate: options.errorSampleRate,\n        useCompressionOption: options.useCompression,\n        blockAllMedia: options.blockAllMedia,\n        maskAllText: options.maskAllText,\n        maskAllInputs: options.maskAllInputs,\n        useCompression: replay.eventBuffer ? replay.eventBuffer.type === 'worker' : false,\n        networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n        networkCaptureBodies: options.networkCaptureBodies,\n        networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n        networkResponseHasHeaders: options.networkResponseHeaders.length > 0,\n      },\n    },\n  };\n}\n\n/**\n * Add a \"meta\" event that contains a simplified view on current configuration\n * options. This should only be included on the first segment of a recording.\n */\nfunction addSettingsEvent(replay, isCheckout) {\n  // Only need to add this event when sending the first segment\n  if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n    return;\n  }\n\n  addEventSync(replay, createOptionsEvent(replay), false);\n}\n\n/**\n * Vendored in from @sentry-internal/rrweb.\n *\n * This is a copy of the function from rrweb, it is not nicely exported there.\n */\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n\n  // Catch access to node properties to avoid Firefox \"permission denied\" errors\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? (node ) : node.parentElement;\n    return el;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Create a replay envelope ready to be sent.\n * This includes both the replay event, as well as the recording data.\n */\nfunction createReplayEnvelope(\n  replayEvent,\n  recordingData,\n  dsn,\n  tunnel,\n) {\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_22__.createEnvelope)(\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_22__.createEventEnvelopeHeaders)(replayEvent, (0,_sentry_core__WEBPACK_IMPORTED_MODULE_22__.getSdkMetadataForEnvelopeHeader)(replayEvent), tunnel, dsn),\n    [\n      [{ type: 'replay_event' }, replayEvent],\n      [\n        {\n          type: 'replay_recording',\n          // If string then we need to encode to UTF8, otherwise will have\n          // wrong size. TextEncoder has similar browser support to\n          // MutationObserver, although it does not accept IE11.\n          length:\n            typeof recordingData === 'string' ? new TextEncoder().encode(recordingData).length : recordingData.length,\n        },\n        recordingData,\n      ],\n    ],\n  );\n}\n\n/**\n * Prepare the recording data ready to be sent.\n */\nfunction prepareRecordingData({\n  recordingData,\n  headers,\n}\n\n) {\n  let payloadWithSequence;\n\n  // XXX: newline is needed to separate sequence id from events\n  const replayHeaders = `${JSON.stringify(headers)}\n`;\n\n  if (typeof recordingData === 'string') {\n    payloadWithSequence = `${replayHeaders}${recordingData}`;\n  } else {\n    const enc = new TextEncoder();\n    // XXX: newline is needed to separate sequence id from events\n    const sequence = enc.encode(replayHeaders);\n    // Merge the two Uint8Arrays\n    payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n    payloadWithSequence.set(sequence);\n    payloadWithSequence.set(recordingData, sequence.length);\n  }\n\n  return payloadWithSequence;\n}\n\n/**\n * Prepare a replay event & enrich it with the SDK metadata.\n */\nasync function prepareReplayEvent({\n  client,\n  scope,\n  replayId: event_id,\n  event,\n}\n\n) {\n  const integrations =\n    typeof client['_integrations'] === 'object' &&\n    client['_integrations'] !== null &&\n    !Array.isArray(client['_integrations'])\n      ? Object.keys(client['_integrations'])\n      : undefined;\n\n  const eventHint = { event_id, integrations };\n\n  client.emit('preprocessEvent', event, eventHint);\n\n  const preparedEvent = (await (0,_sentry_core__WEBPACK_IMPORTED_MODULE_23__.prepareEvent)(\n    client.getOptions(),\n    event,\n    eventHint,\n    scope,\n    client,\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getIsolationScope)(),\n  )) ;\n\n  // If e.g. a global event processor returned null\n  if (!preparedEvent) {\n    return null;\n  }\n\n  client.emit('postprocessEvent', preparedEvent, eventHint);\n\n  // This normally happens in browser client \"_prepareEvent\"\n  // but since we do not use this private method from the client, but rather the plain import\n  // we need to do this manually.\n  preparedEvent.platform = preparedEvent.platform || 'javascript';\n\n  // extract the SDK name because `client._prepareEvent` doesn't add it to the event\n  const metadata = client.getSdkMetadata();\n  const { name, version, settings } = metadata?.sdk || {};\n\n  preparedEvent.sdk = {\n    ...preparedEvent.sdk,\n    name: name || 'sentry.javascript.unknown',\n    version: version || '0.0.0',\n    settings,\n  };\n\n  return preparedEvent;\n}\n\n/**\n * Send replay attachment using `fetch()`\n */\nasync function sendReplayRequest({\n  recordingData,\n  replayId,\n  segmentId: segment_id,\n  eventContext,\n  timestamp,\n  session,\n}) {\n  const preparedRecordingData = prepareRecordingData({\n    recordingData,\n    headers: {\n      segment_id,\n    },\n  });\n\n  const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n  const scope = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getCurrentScope)();\n  const transport = client?.getTransport();\n  const dsn = client?.getDsn();\n\n  if (!client || !transport || !dsn || !session.sampled) {\n    return Promise.resolve({});\n  }\n\n  const baseEvent = {\n    type: REPLAY_EVENT_NAME,\n    replay_start_timestamp: initialTimestamp / 1000,\n    timestamp: timestamp / 1000,\n    error_ids: errorIds,\n    trace_ids: traceIds,\n    urls,\n    replay_id: replayId,\n    segment_id,\n    replay_type: session.sampled,\n  };\n\n  const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n\n  if (!replayEvent) {\n    // Taken from baseclient's `_processEvent` method, where this is handled for errors/transactions\n    client.recordDroppedEvent('event_processor', 'replay');\n    DEBUG_BUILD && debug.log('An event processor returned `null`, will not send event.');\n    return Promise.resolve({});\n  }\n\n  /*\n  For reference, the fully built event looks something like this:\n  {\n      \"type\": \"replay_event\",\n      \"timestamp\": 1670837008.634,\n      \"error_ids\": [\n          \"errorId\"\n      ],\n      \"trace_ids\": [\n          \"traceId\"\n      ],\n      \"urls\": [\n          \"https://example.com\"\n      ],\n      \"replay_id\": \"eventId\",\n      \"segment_id\": 3,\n      \"replay_type\": \"error\",\n      \"platform\": \"javascript\",\n      \"event_id\": \"eventId\",\n      \"environment\": \"production\",\n      \"sdk\": {\n          \"integrations\": [\n              \"BrowserTracing\",\n              \"Replay\"\n          ],\n          \"name\": \"sentry.javascript.browser\",\n          \"version\": \"7.25.0\"\n      },\n      \"sdkProcessingMetadata\": {},\n      \"contexts\": {\n      },\n  }\n  */\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete replayEvent.sdkProcessingMetadata;\n\n  const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n\n  let response;\n\n  try {\n    response = await transport.send(envelope);\n  } catch (err) {\n    const error = new Error(UNABLE_TO_SEND_REPLAY);\n\n    try {\n      // In case browsers don't allow this property to be writable\n      // @ts-expect-error This needs lib es2022 and newer\n      error.cause = err;\n    } catch {\n      // nothing to do\n    }\n    throw error;\n  }\n\n  // If the status code is invalid, we want to immediately stop & not retry\n  if (typeof response.statusCode === 'number' && (response.statusCode < 200 || response.statusCode >= 300)) {\n    throw new TransportStatusCodeError(response.statusCode);\n  }\n\n  const rateLimits = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_24__.updateRateLimits)({}, response);\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_24__.isRateLimited)(rateLimits, 'replay')) {\n    throw new RateLimitError(rateLimits);\n  }\n\n  return response;\n}\n\n/**\n * This error indicates that the transport returned an invalid status code.\n */\nclass TransportStatusCodeError extends Error {\n   constructor(statusCode) {\n    super(`Transport returned status code ${statusCode}`);\n  }\n}\n\n/**\n * This error indicates that we hit a rate limit API error.\n */\nclass RateLimitError extends Error {\n\n   constructor(rateLimits) {\n    super('Rate limit hit');\n    this.rateLimits = rateLimits;\n  }\n}\n\n/**\n * Finalize and send the current replay event to Sentry\n */\nasync function sendReplay(\n  replayData,\n  retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL,\n  },\n) {\n  const { recordingData, onError } = replayData;\n\n  // short circuit if there's no events to upload (this shouldn't happen as _runFlush makes this check)\n  if (!recordingData.length) {\n    return;\n  }\n\n  try {\n    await sendReplayRequest(replayData);\n    return true;\n  } catch (err) {\n    if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n      throw err;\n    }\n\n    // Capture error for every failed replay\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_10__.setContext)('Replays', {\n      _retryCount: retryConfig.count,\n    });\n\n    if (onError) {\n      onError(err);\n    }\n\n    // If an error happened here, it's likely that uploading the attachment\n    // failed, we'll can retry with the same events payload\n    if (retryConfig.count >= RETRY_MAX_COUNT) {\n      const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n\n      try {\n        // In case browsers don't allow this property to be writable\n        // @ts-expect-error This needs lib es2022 and newer\n        error.cause = err;\n      } catch {\n        // nothing to do\n      }\n\n      throw error;\n    }\n\n    // will retry in intervals of 5, 10, 30\n    retryConfig.interval *= ++retryConfig.count;\n\n    return new Promise((resolve, reject) => {\n      (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(async () => {\n        try {\n          await sendReplay(replayData, retryConfig);\n          resolve(true);\n        } catch (err) {\n          reject(err);\n        }\n      }, retryConfig.interval);\n    });\n  }\n}\n\nconst THROTTLED = '__THROTTLED';\nconst SKIPPED = '__SKIPPED';\n\n/**\n * Create a throttled function off a given function.\n * When calling the throttled function, it will call the original function only\n * if it hasn't been called more than `maxCount` times in the last `durationSeconds`.\n *\n * Returns `THROTTLED` if throttled for the first time, after that `SKIPPED`,\n * or else the return value of the original function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(\n  fn,\n  maxCount,\n  durationSeconds,\n) {\n  const counter = new Map();\n\n  const _cleanup = (now) => {\n    const threshold = now - durationSeconds;\n    counter.forEach((_value, key) => {\n      if (key < threshold) {\n        counter.delete(key);\n      }\n    });\n  };\n\n  const _getTotalCount = () => {\n    return [...counter.values()].reduce((a, b) => a + b, 0);\n  };\n\n  let isThrottled = false;\n\n  return (...rest) => {\n    // Date in second-precision, which we use as basis for the throttling\n    const now = Math.floor(Date.now() / 1000);\n\n    // First, make sure to delete any old entries\n    _cleanup(now);\n\n    // If already over limit, do nothing\n    if (_getTotalCount() >= maxCount) {\n      const wasThrottled = isThrottled;\n      isThrottled = true;\n      return wasThrottled ? SKIPPED : THROTTLED;\n    }\n\n    isThrottled = false;\n    const count = counter.get(now) || 0;\n    counter.set(now, count + 1);\n\n    return fn(...rest);\n  };\n}\n\n/**\n * The main replay container class, which holds all the state and methods for recording and sending replays.\n */\nclass ReplayContainer  {\n\n  /**\n   * Recording can happen in one of two modes:\n   *   - session: Record the whole session, sending it continuously\n   *   - buffer: Always keep the last 60s of recording, requires:\n   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *     - or calling `flush()` to send the replay\n   */\n\n  /**\n   * The current or last active span.\n   * This is only available when performance is enabled.\n   */\n\n  /**\n   * These are here so we can overwrite them in tests etc.\n   * @hidden\n   */\n\n  /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Timestamp of the last user activity. This lives across sessions.\n   */\n\n  /**\n   * Is the integration currently active?\n   */\n\n  /**\n   * Paused is a state where:\n   * - DOM Recording is not listening at all\n   * - Nothing will be added to event buffer (e.g. core SDK events)\n   */\n\n  /**\n   * Have we attached listeners to the core SDK?\n   * Note we have to track this as there is no way to remove instrumentation handlers.\n   */\n\n  /**\n   * Function to stop recording\n   */\n\n  /**\n   * Internal use for canvas recording options\n   */\n\n  /**\n   * Handle when visibility of the page content changes. Opening a new tab will\n   * cause the state to change to hidden because of content of current page will\n   * be hidden. Likewise, moving a different window to cover the contents of the\n   * page will also trigger a change to a hidden state.\n   */\n\n  /**\n   * Handle when page is blurred\n   */\n\n  /**\n   * Handle when page is focused\n   */\n\n  /** Ensure page remains active when a key is pressed. */\n\n   constructor({\n    options,\n    recordingOptions,\n  }\n\n) {\n    this.eventBuffer = null;\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n    this.recordingMode = 'session';\n    this.timeouts = {\n      sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n      sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION,\n    } ;\n    this._lastActivity = Date.now();\n    this._isEnabled = false;\n    this._isPaused = false;\n    this._requiresManualStart = false;\n    this._hasInitializedCoreListeners = false;\n    this._context = {\n      errorIds: new Set(),\n      traceIds: new Set(),\n      urls: [],\n      initialTimestamp: Date.now(),\n      initialUrl: '',\n    };\n\n    this._recordingOptions = recordingOptions;\n    this._options = options;\n\n    this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {\n      maxWait: this._options.flushMaxDelay,\n    });\n\n    this._throttledAddEvent = throttle(\n      (event, isCheckout) => addEvent(this, event, isCheckout),\n      // Max 300 events...\n      300,\n      // ... per 5s\n      5,\n    );\n\n    const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n\n    const slowClickConfig = slowClickTimeout\n      ? {\n          threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n          timeout: slowClickTimeout,\n          scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n          ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(',') : '',\n        }\n      : undefined;\n\n    if (slowClickConfig) {\n      this.clickDetector = new ClickDetector(this, slowClickConfig);\n    }\n\n    // Configure replay debug logger w/ experimental options\n    if (DEBUG_BUILD) {\n      const experiments = options._experiments;\n      debug.setConfig({\n        captureExceptions: !!experiments.captureExceptions,\n        traceInternals: !!experiments.traceInternals,\n      });\n    }\n\n    // We set these handler properties as class properties, to make binding/unbinding them easier\n    this._handleVisibilityChange = () => {\n      if (WINDOW.document.visibilityState === 'visible') {\n        this._doChangeToForegroundTasks();\n      } else {\n        this._doChangeToBackgroundTasks();\n      }\n    };\n\n    /**\n     * Handle when page is blurred\n     */\n    this._handleWindowBlur = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.blur',\n      });\n\n      // Do not count blur as a user action -- it's part of the process of them\n      // leaving the page\n      this._doChangeToBackgroundTasks(breadcrumb);\n    };\n\n    this._handleWindowFocus = () => {\n      const breadcrumb = createBreadcrumb({\n        category: 'ui.focus',\n      });\n\n      // Do not count focus as a user action -- instead wait until they focus and\n      // interactive with page\n      this._doChangeToForegroundTasks(breadcrumb);\n    };\n\n    /** Ensure page remains active when a key is pressed. */\n    this._handleKeyboardEvent = (event) => {\n      handleKeyboardEvent(this, event);\n    };\n  }\n\n  /** Get the event context. */\n   getContext() {\n    return this._context;\n  }\n\n  /** If recording is currently enabled. */\n   isEnabled() {\n    return this._isEnabled;\n  }\n\n  /** If recording is currently paused. */\n   isPaused() {\n    return this._isPaused;\n  }\n\n  /**\n   * Determine if canvas recording is enabled\n   */\n   isRecordingCanvas() {\n    return Boolean(this._canvas);\n  }\n\n  /** Get the replay integration options. */\n   getOptions() {\n    return this._options;\n  }\n\n  /** A wrapper to conditionally capture exceptions. */\n   handleException(error) {\n    DEBUG_BUILD && debug.exception(error);\n    if (this._options.onError) {\n      this._options.onError(error);\n    }\n  }\n\n  /**\n   * Initializes the plugin based on sampling configuration. Should not be\n   * called outside of constructor.\n   */\n   initializeSampling(previousSessionId) {\n    const { errorSampleRate, sessionSampleRate } = this._options;\n\n    // If neither sample rate is > 0, then do nothing - user will need to call one of\n    // `start()` or `startBuffering` themselves.\n    const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n\n    this._requiresManualStart = requiresManualStart;\n\n    if (requiresManualStart) {\n      return;\n    }\n\n    // Otherwise if there is _any_ sample rate set, try to load an existing\n    // session, or create a new one.\n    this._initializeSessionForSampling(previousSessionId);\n\n    if (!this.session) {\n      // This should not happen, something wrong has occurred\n      DEBUG_BUILD && debug.exception(new Error('Unable to initialize and create session'));\n      return;\n    }\n\n    if (this.session.sampled === false) {\n      // This should only occur if `errorSampleRate` is 0 and was unsampled for\n      // session-based replay. In this case there is nothing to do.\n      return;\n    }\n\n    // If segmentId > 0, it means we've previously already captured this session\n    // In this case, we still want to continue in `session` recording mode\n    this.recordingMode = this.session.sampled === 'buffer' && this.session.segmentId === 0 ? 'buffer' : 'session';\n\n    DEBUG_BUILD && debug.infoTick(`Starting replay in ${this.recordingMode} mode`);\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * _performanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (this._isEnabled && this.recordingMode === 'session') {\n      DEBUG_BUILD && debug.log('Recording is already in progress');\n      return;\n    }\n\n    if (this._isEnabled && this.recordingMode === 'buffer') {\n      DEBUG_BUILD && debug.log('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && debug.infoTick('Starting replay in session mode');\n\n    // Required as user activity is initially set in\n    // constructor, so if `start()` is called after\n    // session idle expiration, a replay will not be\n    // created due to an idle timeout.\n    this._updateUserActivity();\n\n    const session = loadOrCreateSession(\n      {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n      },\n      {\n        stickySession: this._options.stickySession,\n        // This is intentional: create a new session-based replay when calling `start()`\n        sessionSampleRate: 1,\n        allowBuffering: false,\n      },\n    );\n\n    this.session = session;\n    this.recordingMode = 'session';\n\n    this._initializeRecording();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, an error occurs.\n   */\n   startBuffering() {\n    if (this._isEnabled) {\n      DEBUG_BUILD && debug.log('Buffering is in progress, call `flush()` to save the replay');\n      return;\n    }\n\n    DEBUG_BUILD && debug.infoTick('Starting replay in buffer mode');\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: 0,\n        allowBuffering: true,\n      },\n    );\n\n    this.session = session;\n\n    this.recordingMode = 'buffer';\n    this._initializeRecording();\n  }\n\n  /**\n   * Start recording.\n   *\n   * Note that this will cause a new DOM checkout\n   */\n   startRecording() {\n    try {\n      const canvasOptions = this._canvas;\n\n      this._stopRecording = record({\n        ...this._recordingOptions,\n        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n        // Without this, it would record forever, until an error happens, which we don't want\n        // instead, we'll always keep the last 60 seconds of replay before an error happened\n        ...(this.recordingMode === 'buffer'\n          ? { checkoutEveryNms: BUFFER_CHECKOUT_TIME }\n          : // Otherwise, use experimental option w/ min checkout time of 6 minutes\n            // This is to improve playback seeking as there could potentially be\n            // less mutations to process in the worse cases.\n            //\n            // checkout by \"N\" events is probably ideal, but means we have less\n            // control about the number of checkouts we make (which generally\n            // increases replay size)\n            this._options._experiments.continuousCheckout && {\n              // Minimum checkout time is 6 minutes\n              checkoutEveryNms: Math.max(360000, this._options._experiments.continuousCheckout),\n            }),\n        emit: getHandleRecordingEmit(this),\n        ...getRecordingSamplingOptions(),\n        onMutation: this._onMutationHandler.bind(this),\n        ...(canvasOptions\n          ? {\n              recordCanvas: canvasOptions.recordCanvas,\n              getCanvasManager: canvasOptions.getCanvasManager,\n              sampling: canvasOptions.sampling,\n              dataURLOptions: canvasOptions.dataURLOptions,\n            }\n          : {}),\n      });\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Stops the recording, if it was running.\n   *\n   * Returns true if it was previously stopped, or is now stopped,\n   * otherwise false.\n   */\n   stopRecording() {\n    try {\n      if (this._stopRecording) {\n        this._stopRecording();\n        this._stopRecording = undefined;\n      }\n\n      return true;\n    } catch (err) {\n      this.handleException(err);\n      return false;\n    }\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   async stop({ forceFlush = false, reason } = {}) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    // We can't move `_isEnabled` after awaiting a flush, otherwise we can\n    // enter into an infinite loop when `stop()` is called while flushing.\n    this._isEnabled = false;\n\n    // Make sure to reset `recordingMode` to `buffer` to avoid any additional\n    // breadcrumbs to trigger a flush (e.g. in `addUpdate()`)\n    this.recordingMode = 'buffer';\n\n    try {\n      DEBUG_BUILD && debug.log(`Stopping Replay${reason ? ` triggered by ${reason}` : ''}`);\n\n      resetReplayIdOnDynamicSamplingContext();\n\n      this._removeListeners();\n      this.stopRecording();\n\n      this._debouncedFlush.cancel();\n      // See comment above re: `_isEnabled`, we \"force\" a flush, ignoring the\n      // `_isEnabled` state of the plugin since it was disabled above.\n      if (forceFlush) {\n        await this._flush({ force: true });\n      }\n\n      // After flush, destroy event buffer\n      this.eventBuffer?.destroy();\n      this.eventBuffer = null;\n\n      // Clear session from session storage, note this means if a new session\n      // is started after, it will not have `previousSessionId`\n      clearSession(this);\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Pause some replay functionality. See comments for `_isPaused`.\n   * This differs from stop as this only stops DOM recording, it is\n   * not as thorough of a shutdown as `stop()`.\n   */\n   pause() {\n    if (this._isPaused) {\n      return;\n    }\n\n    this._isPaused = true;\n    this.stopRecording();\n\n    DEBUG_BUILD && debug.log('Pausing replay');\n  }\n\n  /**\n   * Resumes recording, see notes for `pause().\n   *\n   * Note that calling `startRecording()` here will cause a\n   * new DOM checkout.`\n   */\n   resume() {\n    if (!this._isPaused || !this._checkSession()) {\n      return;\n    }\n\n    this._isPaused = false;\n    this.startRecording();\n\n    DEBUG_BUILD && debug.log('Resuming replay');\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   async sendBufferedReplayOrFlush({ continueRecording = true } = {}) {\n    if (this.recordingMode === 'session') {\n      return this.flushImmediate();\n    }\n\n    const activityTime = Date.now();\n\n    DEBUG_BUILD && debug.log('Converting buffer to session');\n\n    // Allow flush to complete before resuming as a session recording, otherwise\n    // the checkout from `startRecording` may be included in the payload.\n    // Prefer to keep the error replay as a separate (and smaller) segment\n    // than the session replay.\n    await this.flushImmediate();\n\n    const hasStoppedRecording = this.stopRecording();\n\n    if (!continueRecording || !hasStoppedRecording) {\n      return;\n    }\n\n    // To avoid race conditions where this is called multiple times, we check here again that we are still buffering\n    if ((this.recordingMode ) === 'session') {\n      return;\n    }\n\n    // Re-start recording in session-mode\n    this.recordingMode = 'session';\n\n    // Once this session ends, we do not want to refresh it\n    if (this.session) {\n      this.session.dirty = false;\n      this._updateUserActivity(activityTime);\n      this._updateSessionActivity(activityTime);\n      this._maybeSaveSession();\n    }\n\n    this.startRecording();\n  }\n\n  /**\n   * We want to batch uploads of replay events. Save events only if\n   * `<flushMinDelay>` milliseconds have elapsed since the last event\n   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n   *\n   * Accepts a callback to perform side-effects and returns true to stop batch\n   * processing and hand back control to caller.\n   */\n   addUpdate(cb) {\n    // We need to always run `cb` (e.g. in the case of `this.recordingMode == 'buffer'`)\n    const cbResult = cb();\n\n    // If this option is turned on then we will only want to call `flush`\n    // explicitly\n    if (this.recordingMode === 'buffer' || !this._isEnabled) {\n      return;\n    }\n\n    // If callback is true, we do not want to continue with flushing -- the\n    // caller will need to handle it.\n    if (cbResult === true) {\n      return;\n    }\n\n    // addUpdate is called quite frequently - use _debouncedFlush so that it\n    // respects the flush delays and does not flush immediately\n    this._debouncedFlush();\n  }\n\n  /**\n   * Updates the user activity timestamp and resumes recording. This should be\n   * called in an event handler for a user action that we consider as the user\n   * being \"active\" (e.g. a mouse click).\n   */\n   triggerUserActivity() {\n    this._updateUserActivity();\n\n    // This case means that recording was once stopped due to inactivity.\n    // Ensure that recording is resumed.\n    if (!this._stopRecording) {\n      // Create a new session, otherwise when the user action is flushed, it\n      // will get rejected due to an expired session.\n      if (!this._checkSession()) {\n        return;\n      }\n\n      // Note: This will cause a new DOM checkout\n      this.resume();\n      return;\n    }\n\n    // Otherwise... recording was never suspended, continue as normalish\n    this.checkAndHandleExpiredSession();\n\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Updates the user activity timestamp *without* resuming\n   * recording. Some user events (e.g. keydown) can be create\n   * low-value replays that only contain the keypress as a\n   * breadcrumb. Instead this would require other events to\n   * create a new replay after a session has expired.\n   */\n   updateUserActivity() {\n    this._updateUserActivity();\n    this._updateSessionActivity();\n  }\n\n  /**\n   * Only flush if `this.recordingMode === 'session'`\n   */\n   conditionalFlush() {\n    if (this.recordingMode === 'buffer') {\n      return Promise.resolve();\n    }\n\n    return this.flushImmediate();\n  }\n\n  /**\n   * Flush using debounce flush\n   */\n   flush() {\n    return this._debouncedFlush() ;\n  }\n\n  /**\n   * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n   * cases of multiple flushes happening closely together.\n   */\n   flushImmediate() {\n    this._debouncedFlush();\n    // `.flush` is provided by the debounced function, analogously to lodash.debounce\n    return this._debouncedFlush.flush() ;\n  }\n\n  /**\n   * Cancels queued up flushes.\n   */\n   cancelFlush() {\n    this._debouncedFlush.cancel();\n  }\n\n  /** Get the current session (=replay) ID\n   *\n   * @param onlyIfSampled - If true, will only return the session ID if the session is sampled.\n   */\n   getSessionId(onlyIfSampled) {\n    if (onlyIfSampled && this.session?.sampled === false) {\n      return undefined;\n    }\n\n    return this.session?.id;\n  }\n\n  /**\n   * Checks if recording should be stopped due to user inactivity. Otherwise\n   * check if session is expired and create a new session if so. Triggers a new\n   * full snapshot on new session.\n   *\n   * Returns true if session is not expired, false otherwise.\n   * @hidden\n   */\n   checkAndHandleExpiredSession() {\n    // Prevent starting a new session if the last user activity is older than\n    // SESSION_IDLE_PAUSE_DURATION. Otherwise non-user activity can trigger a new\n    // session+recording. This creates noisy replays that do not have much\n    // content in them.\n    if (\n      this._lastActivity &&\n      isExpired(this._lastActivity, this.timeouts.sessionIdlePause) &&\n      this.session &&\n      this.session.sampled === 'session'\n    ) {\n      // Pause recording only for session-based replays. Otherwise, resuming\n      // will create a new replay and will conflict with users who only choose\n      // to record error-based replays only. (e.g. the resumed replay will not\n      // contain a reference to an error)\n      this.pause();\n      return;\n    }\n\n    // --- There is recent user activity --- //\n    // This will create a new session if expired, based on expiry length\n    if (!this._checkSession()) {\n      // Check session handles the refreshing itself\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Capture some initial state that can change throughout the lifespan of the\n   * replay. This is required because otherwise they would be captured at the\n   * first flush.\n   */\n   setInitialState() {\n    const urlPath = `${WINDOW.location.pathname}${WINDOW.location.hash}${WINDOW.location.search}`;\n    const url = `${WINDOW.location.origin}${urlPath}`;\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // Reset _context as well\n    this._clearContext();\n\n    this._context.initialUrl = url;\n    this._context.initialTimestamp = Date.now();\n    this._context.urls.push(url);\n  }\n\n  /**\n   * Add a breadcrumb event, that may be throttled.\n   * If it was throttled, we add a custom breadcrumb to indicate that.\n   */\n   throttledAddEvent(\n    event,\n    isCheckout,\n  ) {\n    const res = this._throttledAddEvent(event, isCheckout);\n\n    // If this is THROTTLED, it means we have throttled the event for the first time\n    // In this case, we want to add a breadcrumb indicating that something was skipped\n    if (res === THROTTLED) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.throttled',\n      });\n\n      this.addUpdate(() => {\n        // Return `false` if the event _was_ added, as that means we schedule a flush\n        return !addEventSync(this, {\n          type: ReplayEventTypeCustom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: 'breadcrumb',\n            payload: breadcrumb,\n            metric: true,\n          },\n        });\n      });\n    }\n\n    return res;\n  }\n\n  /**\n   * This will get the parametrized route name of the current page.\n   * This is only available if performance is enabled, and if an instrumented router is used.\n   */\n   getCurrentRoute() {\n    const lastActiveSpan = this.lastActiveSpan || (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getActiveSpan)();\n    const lastRootSpan = lastActiveSpan && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.getRootSpan)(lastActiveSpan);\n\n    const attributes = (lastRootSpan && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.spanToJSON)(lastRootSpan).data) || {};\n    const source = attributes[_sentry_core__WEBPACK_IMPORTED_MODULE_25__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    if (!lastRootSpan || !source || !['route', 'custom'].includes(source)) {\n      return undefined;\n    }\n\n    return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_13__.spanToJSON)(lastRootSpan).description;\n  }\n\n  /**\n   * Initialize and start all listeners to varying events (DOM,\n   * Performance Observer, Recording, Sentry SDK, etc)\n   */\n   _initializeRecording() {\n    this.setInitialState();\n\n    // this method is generally called on page load or manually - in both cases\n    // we should treat it as an activity\n    this._updateSessionActivity();\n\n    this.eventBuffer = createEventBuffer({\n      useCompression: this._options.useCompression,\n      workerUrl: this._options.workerUrl,\n    });\n\n    this._removeListeners();\n    this._addListeners();\n\n    // Need to set as enabled before we start recording, as `record()` can trigger a flush with a new checkout\n    this._isEnabled = true;\n    this._isPaused = false;\n\n    this.startRecording();\n  }\n\n  /**\n   * Loads (or refreshes) the current session.\n   */\n   _initializeSessionForSampling(previousSessionId) {\n    // Whenever there is _any_ error sample rate, we always allow buffering\n    // Because we decide on sampling when an error occurs, we need to buffer at all times if sampling for errors\n    const allowBuffering = this._options.errorSampleRate > 0;\n\n    const session = loadOrCreateSession(\n      {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n        previousSessionId,\n      },\n      {\n        stickySession: this._options.stickySession,\n        sessionSampleRate: this._options.sessionSampleRate,\n        allowBuffering,\n      },\n    );\n\n    this.session = session;\n  }\n\n  /**\n   * Checks and potentially refreshes the current session.\n   * Returns false if session is not recorded.\n   */\n   _checkSession() {\n    // If there is no session yet, we do not want to refresh anything\n    // This should generally not happen, but to be safe....\n    if (!this.session) {\n      return false;\n    }\n\n    const currentSession = this.session;\n\n    if (\n      shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration,\n      })\n    ) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._refreshSession(currentSession);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Refresh a session with a new one.\n   * This stops the current session (without forcing a flush, as that would never work since we are expired),\n   * and then does a new sampling based on the refreshed session.\n   */\n   async _refreshSession(session) {\n    if (!this._isEnabled) {\n      return;\n    }\n    await this.stop({ reason: 'refresh session' });\n    this.initializeSampling(session.id);\n  }\n\n  /**\n   * Adds listeners to record events for the replay\n   */\n   _addListeners() {\n    try {\n      WINDOW.document.addEventListener('visibilitychange', this._handleVisibilityChange);\n      WINDOW.addEventListener('blur', this._handleWindowBlur);\n      WINDOW.addEventListener('focus', this._handleWindowFocus);\n      WINDOW.addEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.addListeners();\n      }\n\n      // There is no way to remove these listeners, so ensure they are only added once\n      if (!this._hasInitializedCoreListeners) {\n        addGlobalListeners(this);\n\n        this._hasInitializedCoreListeners = true;\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n\n    this._performanceCleanupCallback = setupPerformanceObserver(this);\n  }\n\n  /**\n   * Cleans up listeners that were created in `_addListeners`\n   */\n   _removeListeners() {\n    try {\n      WINDOW.document.removeEventListener('visibilitychange', this._handleVisibilityChange);\n\n      WINDOW.removeEventListener('blur', this._handleWindowBlur);\n      WINDOW.removeEventListener('focus', this._handleWindowFocus);\n      WINDOW.removeEventListener('keydown', this._handleKeyboardEvent);\n\n      if (this.clickDetector) {\n        this.clickDetector.removeListeners();\n      }\n\n      if (this._performanceCleanupCallback) {\n        this._performanceCleanupCallback();\n      }\n    } catch (err) {\n      this.handleException(err);\n    }\n  }\n\n  /**\n   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n   */\n   _doChangeToBackgroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const expired = isSessionExpired(this.session, {\n      maxReplayDuration: this._options.maxReplayDuration,\n      sessionIdleExpire: this.timeouts.sessionIdleExpire,\n    });\n\n    if (expired) {\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Send replay when the page/tab becomes hidden. There is no reason to send\n    // replay if it becomes visible, since no actions we care about were done\n    // while it was hidden\n    // This should never reject\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    void this.conditionalFlush();\n  }\n\n  /**\n   * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n   */\n   _doChangeToForegroundTasks(breadcrumb) {\n    if (!this.session) {\n      return;\n    }\n\n    const isSessionActive = this.checkAndHandleExpiredSession();\n\n    if (!isSessionActive) {\n      // If the user has come back to the page within SESSION_IDLE_PAUSE_DURATION\n      // ms, we will re-use the existing session, otherwise create a new\n      // session\n      DEBUG_BUILD && debug.log('Document has become active, but session has expired');\n      return;\n    }\n\n    if (breadcrumb) {\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n  }\n\n  /**\n   * Update user activity (across session lifespans)\n   */\n   _updateUserActivity(_lastActivity = Date.now()) {\n    this._lastActivity = _lastActivity;\n  }\n\n  /**\n   * Updates the session's last activity timestamp\n   */\n   _updateSessionActivity(_lastActivity = Date.now()) {\n    if (this.session) {\n      this.session.lastActivity = _lastActivity;\n      this._maybeSaveSession();\n    }\n  }\n\n  /**\n   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n   */\n   _createCustomBreadcrumb(breadcrumb) {\n    this.addUpdate(() => {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: breadcrumb.timestamp || 0,\n        data: {\n          tag: 'breadcrumb',\n          payload: breadcrumb,\n        },\n      });\n    });\n  }\n\n  /**\n   * Observed performance events are added to `this.performanceEntries`. These\n   * are included in the replay event before it is finished and sent to Sentry.\n   */\n   _addPerformanceEntries() {\n    let performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n\n    this.performanceEntries = [];\n    this.replayPerformanceEntries = [];\n\n    // If we are manually starting, we want to ensure we only include performance entries\n    // that are after the initial timestamp\n    // The reason for this is that we may have performance entries from the page load, but may decide to start\n    // the replay later on, in which case we do not want to include these entries.\n    // without this, manually started replays can have events long before the actual replay recording starts,\n    // which messes with the timeline etc.\n    if (this._requiresManualStart) {\n      const initialTimestampInSeconds = this._context.initialTimestamp / 1000;\n      performanceEntries = performanceEntries.filter(entry => entry.start >= initialTimestampInSeconds);\n    }\n\n    return Promise.all(createPerformanceSpans(this, performanceEntries));\n  }\n\n  /**\n   * Clear _context\n   */\n   _clearContext() {\n    // XXX: `initialTimestamp` and `initialUrl` do not get cleared\n    this._context.errorIds.clear();\n    this._context.traceIds.clear();\n    this._context.urls = [];\n  }\n\n  /** Update the initial timestamp based on the buffer content. */\n   _updateInitialTimestampFromEventBuffer() {\n    const { session, eventBuffer } = this;\n    // If replay was started manually (=no sample rate was given),\n    // We do not want to back-port the initial timestamp\n    if (!session || !eventBuffer || this._requiresManualStart) {\n      return;\n    }\n\n    // we only ever update this on the initial segment\n    if (session.segmentId) {\n      return;\n    }\n\n    const earliestEvent = eventBuffer.getEarliestTimestamp();\n    if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n      this._context.initialTimestamp = earliestEvent;\n    }\n  }\n\n  /**\n   * Return and clear _context\n   */\n   _popEventContext() {\n    const _context = {\n      initialTimestamp: this._context.initialTimestamp,\n      initialUrl: this._context.initialUrl,\n      errorIds: Array.from(this._context.errorIds),\n      traceIds: Array.from(this._context.traceIds),\n      urls: this._context.urls,\n    };\n\n    this._clearContext();\n\n    return _context;\n  }\n\n  /**\n   * Flushes replay event buffer to Sentry.\n   *\n   * Performance events are only added right before flushing - this is\n   * due to the buffered performance observer events.\n   *\n   * Should never be called directly, only by `flush`\n   */\n   async _runFlush() {\n    const replayId = this.getSessionId();\n\n    if (!this.session || !this.eventBuffer || !replayId) {\n      DEBUG_BUILD && debug.error('No session or eventBuffer found to flush.');\n      return;\n    }\n\n    await this._addPerformanceEntries();\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer?.hasEvents) {\n      return;\n    }\n\n    // Only attach memory event if eventBuffer is not empty\n    await addMemoryEntry(this);\n\n    // Check eventBuffer again, as it could have been stopped in the meanwhile\n    if (!this.eventBuffer) {\n      return;\n    }\n\n    // if this changed in the meanwhile, e.g. because the session was refreshed or similar, we abort here\n    if (replayId !== this.getSessionId()) {\n      return;\n    }\n\n    try {\n      // This uses the data from the eventBuffer, so we need to call this before `finish()\n      this._updateInitialTimestampFromEventBuffer();\n\n      const timestamp = Date.now();\n\n      // Check total duration again, to avoid sending outdated stuff\n      // We leave 30s wiggle room to accommodate late flushing etc.\n      // This _could_ happen when the browser is suspended during flushing, in which case we just want to stop\n      if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 30000) {\n        throw new Error('Session is too long, not sending replay');\n      }\n\n      const eventContext = this._popEventContext();\n      // Always increment segmentId regardless of outcome of sending replay\n      const segmentId = this.session.segmentId++;\n      this._maybeSaveSession();\n\n      // Note this empties the event buffer regardless of outcome of sending replay\n      const recordingData = await this.eventBuffer.finish();\n\n      await sendReplay({\n        replayId,\n        recordingData,\n        segmentId,\n        eventContext,\n        session: this.session,\n        timestamp,\n        onError: err => this.handleException(err),\n      });\n    } catch (err) {\n      this.handleException(err);\n\n      // This means we retried 3 times and all of them failed,\n      // or we ran into a problem we don't want to retry, like rate limiting.\n      // In this case, we want to completely stop the replay - otherwise, we may get inconsistent segments\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'sendReplay' });\n\n      const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n\n      if (client) {\n        const dropReason = err instanceof RateLimitError ? 'ratelimit_backoff' : 'send_error';\n        client.recordDroppedEvent(dropReason, 'replay');\n      }\n    }\n  }\n\n  /**\n   * Flush recording data to Sentry. Creates a lock so that only a single flush\n   * can be active at a time. Do not call this directly.\n   */\n   async _flush({\n    force = false,\n  }\n\n = {}) {\n    if (!this._isEnabled && !force) {\n      // This can happen if e.g. the replay was stopped because of exceeding the retry limit\n      return;\n    }\n\n    if (!this.checkAndHandleExpiredSession()) {\n      DEBUG_BUILD && debug.error('Attempting to finish replay event after session expired.');\n      return;\n    }\n\n    if (!this.session) {\n      // should never happen, as we would have bailed out before\n      return;\n    }\n\n    const start = this.session.started;\n    const now = Date.now();\n    const duration = now - start;\n\n    // A flush is about to happen, cancel any queued flushes\n    this._debouncedFlush.cancel();\n\n    // If session is too short, or too long (allow some wiggle room over maxReplayDuration), do not send it\n    // This _should_ not happen, but it may happen if flush is triggered due to a page activity change or similar\n    const tooShort = duration < this._options.minReplayDuration;\n    const tooLong = duration > this._options.maxReplayDuration + 5000;\n    if (tooShort || tooLong) {\n      DEBUG_BUILD &&\n        debug.log(\n          `Session duration (${Math.floor(duration / 1000)}s) is too ${\n            tooShort ? 'short' : 'long'\n          }, not sending replay.`,\n        );\n\n      if (tooShort) {\n        this._debouncedFlush();\n      }\n      return;\n    }\n\n    const eventBuffer = this.eventBuffer;\n    if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n      DEBUG_BUILD && debug.log('Flushing initial segment without checkout.');\n      // TODO FN: Evaluate if we want to stop here, or remove this again?\n    }\n\n    const _flushInProgress = !!this._flushLock;\n\n    // this._flushLock acts as a lock so that future calls to `_flush()` will\n    // be blocked until current flush is finished (i.e. this promise resolves)\n    if (!this._flushLock) {\n      this._flushLock = this._runFlush();\n    }\n\n    try {\n      await this._flushLock;\n    } catch (err) {\n      this.handleException(err);\n    } finally {\n      this._flushLock = undefined;\n\n      if (_flushInProgress) {\n        // Wait for previous flush to finish, then call the debounced\n        // `_flush()`. It's possible there are other flush requests queued and\n        // waiting for it to resolve. We want to reduce all outstanding\n        // requests (as well as any new flush requests that occur within a\n        // second of the locked flush completing) into a single flush.\n        this._debouncedFlush();\n      }\n    }\n  }\n\n  /** Save the session, if it is sticky */\n   _maybeSaveSession() {\n    if (this.session && this._options.stickySession) {\n      saveSession(this.session);\n    }\n  }\n\n  /** Handler for rrweb.record.onMutation */\n   _onMutationHandler(mutations) {\n    const { ignoreMutations } = this._options._experiments;\n    if (ignoreMutations?.length) {\n      if (\n        mutations.some(mutation => {\n          const el = closestElementOfNode(mutation.target);\n          const selector = ignoreMutations.join(',');\n          return el?.matches(selector);\n        })\n      ) {\n        return false;\n      }\n    }\n\n    const count = mutations.length;\n\n    const mutationLimit = this._options.mutationLimit;\n    const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n    const overMutationLimit = mutationLimit && count > mutationLimit;\n\n    // Create a breadcrumb if a lot of mutations happen at the same time\n    // We can show this in the UI as an information with potential performance improvements\n    if (count > mutationBreadcrumbLimit || overMutationLimit) {\n      const breadcrumb = createBreadcrumb({\n        category: 'replay.mutations',\n        data: {\n          count,\n          limit: overMutationLimit,\n        },\n      });\n      this._createCustomBreadcrumb(breadcrumb);\n    }\n\n    // Stop replay if over the mutation limit\n    if (overMutationLimit) {\n      // This should never reject\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.stop({ reason: 'mutationLimit', forceFlush: this.recordingMode === 'session' });\n      return false;\n    }\n\n    // `true` means we use the regular mutation handling by rrweb\n    return true;\n  }\n}\n\nfunction getOption(selectors, defaultSelectors) {\n  return [\n    ...selectors,\n    // sentry defaults\n    ...defaultSelectors,\n  ].join(',');\n}\n\n/**\n * Returns privacy related configuration for use in rrweb\n */\nfunction getPrivacyOptions({ mask, unmask, block, unblock, ignore }) {\n  const defaultBlockedElements = ['base', 'iframe[srcdoc]:not([src])'];\n\n  const maskSelector = getOption(mask, ['.sentry-mask', '[data-sentry-mask]']);\n  const unmaskSelector = getOption(unmask, []);\n\n  const options = {\n    // We are making the decision to make text and input selectors the same\n    maskTextSelector: maskSelector,\n    unmaskTextSelector: unmaskSelector,\n\n    blockSelector: getOption(block, ['.sentry-block', '[data-sentry-block]', ...defaultBlockedElements]),\n    unblockSelector: getOption(unblock, []),\n    ignoreSelector: getOption(ignore, ['.sentry-ignore', '[data-sentry-ignore]', 'input[type=\"file\"]']),\n  };\n\n  return options;\n}\n\n/**\n * Masks an attribute if necessary, otherwise return attribute value as-is.\n */\nfunction maskAttribute({\n  el,\n  key,\n  maskAttributes,\n  maskAllText,\n  privacyOptions,\n  value,\n}) {\n  // We only mask attributes if `maskAllText` is true\n  if (!maskAllText) {\n    return value;\n  }\n\n  // unmaskTextSelector takes precedence\n  if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n    return value;\n  }\n\n  if (\n    maskAttributes.includes(key) ||\n    // Need to mask `value` attribute for `<input>` if it's a button-like\n    // type\n    (key === 'value' && el.tagName === 'INPUT' && ['submit', 'button'].includes(el.getAttribute('type') || ''))\n  ) {\n    return value.replace(/[\\S]/g, '*');\n  }\n\n  return value;\n}\n\nconst MEDIA_SELECTORS =\n  'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\n\nconst DEFAULT_NETWORK_HEADERS = ['content-length', 'content-type', 'accept'];\n\nlet _initialized = false;\n\n/**\n * Sentry integration for [Session Replay](https://sentry.io/for/session-replay/).\n *\n * See the [Replay documentation](https://docs.sentry.io/platforms/javascript/guides/session-replay/) for more information.\n *\n * @example\n *\n * ```\n * Sentry.init({\n *   dsn: '__DSN__',\n *   integrations: [Sentry.replayIntegration()],\n * });\n * ```\n */\nconst replayIntegration = ((options) => {\n  return new Replay(options);\n}) ;\n\n/**\n * Replay integration\n */\nclass Replay  {\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Options to pass to `rrweb.record()`\n   */\n\n  /**\n   * Initial options passed to the replay integration, merged with default values.\n   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n   * can only be finally set when setupOnce() is called.\n   *\n   * @private\n   */\n\n   constructor({\n    flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n    flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n    minReplayDuration = MIN_REPLAY_DURATION,\n    maxReplayDuration = MAX_REPLAY_DURATION,\n    stickySession = true,\n    useCompression = true,\n    workerUrl,\n    _experiments = {},\n    maskAllText = true,\n    maskAllInputs = true,\n    blockAllMedia = true,\n\n    mutationBreadcrumbLimit = 750,\n    mutationLimit = 10000,\n\n    slowClickTimeout = 7000,\n    slowClickIgnoreSelectors = [],\n\n    networkDetailAllowUrls = [],\n    networkDetailDenyUrls = [],\n    networkCaptureBodies = true,\n    networkRequestHeaders = [],\n    networkResponseHeaders = [],\n\n    mask = [],\n    maskAttributes = ['title', 'placeholder', 'aria-label'],\n    unmask = [],\n    block = [],\n    unblock = [],\n    ignore = [],\n    maskFn,\n\n    beforeAddRecordingEvent,\n    beforeErrorSampling,\n    onError,\n  } = {}) {\n    this.name = 'Replay';\n\n    const privacyOptions = getPrivacyOptions({\n      mask,\n      unmask,\n      block,\n      unblock,\n      ignore,\n    });\n\n    this._recordingOptions = {\n      maskAllInputs,\n      maskAllText,\n      maskInputOptions: { password: true },\n      maskTextFn: maskFn,\n      maskInputFn: maskFn,\n      maskAttributeFn: (key, value, el) =>\n        maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el,\n        }),\n\n      ...privacyOptions,\n\n      // Our defaults\n      slimDOMOptions: 'all',\n      inlineStylesheet: true,\n      // Disable inline images as it will increase segment/replay size\n      inlineImages: false,\n      // collect fonts, but be aware that `sentry.io` needs to be an allowed\n      // origin for playback\n      collectFonts: true,\n      errorHandler: (err) => {\n        try {\n          err.__rrweb__ = true;\n        } catch {\n          // ignore errors here\n          // this can happen if the error is frozen or does not allow mutation for other reasons\n        }\n      },\n      // experimental support for recording iframes from different origins\n      recordCrossOriginIframes: Boolean(_experiments.recordCrossOriginIframes),\n    };\n\n    this._initialOptions = {\n      flushMinDelay,\n      flushMaxDelay,\n      minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n      maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n      stickySession,\n      useCompression,\n      workerUrl,\n      blockAllMedia,\n      maskAllInputs,\n      maskAllText,\n      mutationBreadcrumbLimit,\n      mutationLimit,\n      slowClickTimeout,\n      slowClickIgnoreSelectors,\n      networkDetailAllowUrls,\n      networkDetailDenyUrls,\n      networkCaptureBodies,\n      networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n      networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n      beforeAddRecordingEvent,\n      beforeErrorSampling,\n      onError,\n\n      _experiments,\n    };\n\n    if (this._initialOptions.blockAllMedia) {\n      // `blockAllMedia` is a more user friendly option to configure blocking\n      // embedded media elements\n      this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector\n        ? MEDIA_SELECTORS\n        : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n      this._recordingOptions.ignoreCSSAttributes = new Set(['background-image']);\n    }\n\n    if (this._isInitialized && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_26__.isBrowser)()) {\n      throw new Error('Multiple Sentry Session Replay instances are not supported');\n    }\n\n    this._isInitialized = true;\n  }\n\n  /** If replay has already been initialized */\n   get _isInitialized() {\n    return _initialized;\n  }\n\n  /** Update _isInitialized */\n   set _isInitialized(value) {\n    _initialized = value;\n  }\n\n  /**\n   * Setup and initialize replay container\n   */\n   afterAllSetup(client) {\n    if (!(0,_sentry_core__WEBPACK_IMPORTED_MODULE_26__.isBrowser)() || this._replay) {\n      return;\n    }\n\n    this._setup(client);\n    this._initialize(client);\n  }\n\n  /**\n   * Start a replay regardless of sampling rate. Calling this will always\n   * create a new session. Will log a message if replay is already in progress.\n   *\n   * Creates or loads a session, attaches listeners to varying events (DOM,\n   * PerformanceObserver, Recording, Sentry SDK, etc)\n   */\n   start() {\n    if (!this._replay) {\n      return;\n    }\n    this._replay.start();\n  }\n\n  /**\n   * Start replay buffering. Buffers until `flush()` is called or, if\n   * `replaysOnErrorSampleRate` > 0, until an error occurs.\n   */\n   startBuffering() {\n    if (!this._replay) {\n      return;\n    }\n\n    this._replay.startBuffering();\n  }\n\n  /**\n   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n   * does not support a teardown\n   */\n   stop() {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    return this._replay.stop({ forceFlush: this._replay.recordingMode === 'session' });\n  }\n\n  /**\n   * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n   * If replay is not enabled, a new session replay is started.\n   * Unless `continueRecording` is false, the replay will continue to record and\n   * behave as a \"session\"-based replay.\n   *\n   * Otherwise, queue up a flush.\n   */\n   flush(options) {\n    if (!this._replay) {\n      return Promise.resolve();\n    }\n\n    // assuming a session should be recorded in this case\n    if (!this._replay.isEnabled()) {\n      this._replay.start();\n      return Promise.resolve();\n    }\n\n    return this._replay.sendBufferedReplayOrFlush(options);\n  }\n\n  /**\n   * Get the current session ID.\n   *\n   * @param onlyIfSampled - If true, will only return the session ID if the session is sampled.\n   *\n   */\n   getReplayId(onlyIfSampled) {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.getSessionId(onlyIfSampled);\n  }\n\n  /**\n   * Get the current recording mode. This can be either `session` or `buffer`.\n   *\n   * `session`: Recording the whole session, sending it continuously\n   * `buffer`: Always keeping the last 60s of recording, requires:\n   *   - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n   *   - or calling `flush()` to send the replay\n   */\n   getRecordingMode() {\n    if (!this._replay?.isEnabled()) {\n      return;\n    }\n\n    return this._replay.recordingMode;\n  }\n\n  /**\n   * Initializes replay.\n   */\n   _initialize(client) {\n    if (!this._replay) {\n      return;\n    }\n\n    this._maybeLoadFromReplayCanvasIntegration(client);\n    this._replay.initializeSampling();\n  }\n\n  /** Setup the integration. */\n   _setup(client) {\n    // Client is not available in constructor, so we need to wait until setupOnce\n    const finalOptions = loadReplayOptionsFromClient(this._initialOptions, client);\n\n    this._replay = new ReplayContainer({\n      options: finalOptions,\n      recordingOptions: this._recordingOptions,\n    });\n  }\n\n  /** Get canvas options from ReplayCanvas integration, if it is also added. */\n   _maybeLoadFromReplayCanvasIntegration(client) {\n    // To save bundle size, we skip checking for stuff here\n    // and instead just try-catch everything - as generally this should all be defined\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    try {\n      const canvasIntegration = client.getIntegrationByName('ReplayCanvas')\n\n;\n      if (!canvasIntegration) {\n        return;\n      }\n\n      this._replay['_canvas'] = canvasIntegration.getOptions();\n    } catch {\n      // ignore errors here\n    }\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n  }\n}\n\n/** Parse Replay-related options from SDK options */\nfunction loadReplayOptionsFromClient(initialOptions, client) {\n  const opt = client.getOptions() ;\n\n  const finalOptions = {\n    sessionSampleRate: 0,\n    errorSampleRate: 0,\n    ...initialOptions,\n  };\n\n  const replaysSessionSampleRate = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_27__.parseSampleRate)(opt.replaysSessionSampleRate);\n  const replaysOnErrorSampleRate = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_27__.parseSampleRate)(opt.replaysOnErrorSampleRate);\n\n  if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_8__.consoleSandbox)(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.',\n      );\n    });\n  }\n\n  if (replaysSessionSampleRate != null) {\n    finalOptions.sessionSampleRate = replaysSessionSampleRate;\n  }\n\n  if (replaysOnErrorSampleRate != null) {\n    finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n  }\n\n  return finalOptions;\n}\n\nfunction _getMergedNetworkHeaders(headers) {\n  return [...DEFAULT_NETWORK_HEADERS, ...headers.map(header => header.toLowerCase())];\n}\n\n/**\n * This is a small utility to get a type-safe instance of the Replay integration.\n */\nfunction getReplay() {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_12__.getClient)();\n  return client?.getIntegrationByName('Replay');\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeS1pbnRlcm5hbCtyZXBsYXlAMTAuMjUuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9yZXBsYXkvYnVpbGQvbnBtL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd25CO0FBQzFQOztBQUU5WDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQVU7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0Esa0ZBQWtGLDZEQUE2RDtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUF3RDtBQUN2RztBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsR0FBRyw2Q0FBNkMsRUFBRSxrQ0FBa0M7QUFDL0c7QUFDQSxZQUFZLHFCQUFxQixFQUFFLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwREFBMEQsT0FBTztBQUN2RyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDekQ7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDekQ7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEVBQUUsK0JBQStCLEVBQUUsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUNBQXFDLFNBQVMsV0FBVyxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSw0QkFBNEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsR0FBRyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHFDQUFxQywyREFBMkQsSUFBSTtBQUNwRztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFzRCxJQUFJLEtBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLEtBQUs7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0EsY0FBYyx1REFBdUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUztBQUMxQixPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxrREFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QiwwRUFBWTtBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFdBQVc7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCOztBQUU1QjtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQWdCLFdBQVcsc0JBQXNCO0FBQy9ELElBQUk7QUFDSjtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhEQUFnQixXQUFXLHNCQUFzQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywwRUFBNEI7QUFDdkM7O0FBRUE7QUFDQSxVQUFVLHVDQUF1Qzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxVQUFVLEdBQUcsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVUsR0FBRyxjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQW1FO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixvR0FBb0M7QUFDNUQsR0FBRzs7QUFFSDtBQUNBLElBQUksNEZBQTRCO0FBQ2hDLElBQUksNEZBQTRCO0FBQ2hDLElBQUksNEZBQTRCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtSQUErUix3QkFBd0IsS0FBSyxzQkFBc0IsbUJBQW1CLFFBQVEsS0FBSyxtQkFBbUIsU0FBUyxxQkFBcUIsT0FBTyxTQUFTLHNCQUFzQixvQkFBb0Isc0NBQXNDLFFBQVEsS0FBSyxnQ0FBZ0MseUZBQXlGLHNCQUFzQixrQ0FBa0MsSUFBSSxzQkFBc0IsaUJBQWlCLFFBQVEsSUFBSSwwQkFBMEIsTUFBTSxjQUFjLFdBQVcsUUFBUSxJQUFJLHVFQUF1RSxLQUFLLGlCQUFpQix3QkFBd0IsSUFBSSx5Q0FBeUMsU0FBUyxjQUFjLFFBQVEsTUFBTSxXQUFXLFVBQVUsTUFBTSxXQUFXLFVBQVUsTUFBTSxXQUFXLFVBQVUsTUFBTSxXQUFXLGdCQUFnQixRQUFRLEtBQUssV0FBVyx3Q0FBd0MsZ0JBQWdCLG1CQUFtQixpRUFBaUUsa1NBQWtTLHlCQUF5Qiw2RUFBNkUsU0FBUyxtQkFBbUIsUUFBUSxZQUFZLHFCQUFxQixtQkFBbUIsUUFBUSxZQUFZLG1DQUFtQyxpQkFBaUIsaUJBQWlCLFdBQVcsa0JBQWtCLFdBQVcsRUFBRSwyQkFBMkIsYUFBYSxTQUFTLFNBQVMsc0JBQXNCLG9CQUFvQixTQUFTLHFCQUFxQixlQUFlLFVBQVUsYUFBYSxFQUFFLDhCQUE4QixVQUFVLHdCQUF3QixPQUFPLHFFQUFxRSx3QkFBd0IsYUFBYSxRQUFRLElBQUkseUJBQXlCLGlDQUFpQyxRQUFRLElBQUkscUJBQXFCLHlCQUF5Qiw4QkFBOEIsRUFBRSxJQUFJLEtBQUssYUFBYSxtQkFBbUIsd0JBQXdCLFVBQVUsSUFBSSxFQUFFLGFBQWEsNEJBQTRCLEtBQUssUUFBUSxLQUFLLGFBQWEsc0JBQXNCLElBQUksT0FBTyxnQkFBZ0IsbUJBQW1CLDJEQUEyRCxlQUFlLG1CQUFtQixXQUFXLEVBQUUsa0RBQWtELFNBQVMsS0FBSyxLQUFLLHlCQUF5QixLQUFLLFlBQVksS0FBSyxNQUFNLGdCQUFnQiw4Q0FBOEMsYUFBYSxhQUFhLElBQUksYUFBYSwwQkFBMEIsS0FBSyxJQUFJLE1BQU0sV0FBVyxPQUFPLHVCQUF1QixpQkFBaUIsZ0JBQWdCLFdBQVcsaUJBQWlCLFNBQVMsbUJBQW1CLHdCQUF3Qix5REFBeUQsWUFBWSxJQUFJLGtCQUFrQixpQkFBaUIsbUNBQW1DLG9CQUFvQiwwR0FBMEcsV0FBVyxpQkFBaUIsUUFBUSxXQUFXLGlCQUFpQixrQ0FBa0MsZ0JBQWdCLEtBQUssK0ZBQStGLG9EQUFvRCw0QkFBNEIsOEJBQThCLGVBQWUsOENBQThDLFFBQVEsSUFBSSx1QkFBdUIsT0FBTyxvQkFBb0IsSUFBSSxLQUFLLFlBQVksUUFBUSxZQUFZLEtBQUssZ0JBQWdCLGtFQUFrRSxxQkFBcUIsUUFBUSxJQUFJLEtBQUssWUFBWSxXQUFXLDRFQUE0RSxhQUFhLHlEQUF5RCwyQkFBMkIsOEJBQThCLHNHQUFzRyxrQ0FBa0MsTUFBTSxLQUFLLGdCQUFnQixJQUFJLDJCQUEyQixPQUFPLFNBQVMsZ0JBQWdCLFlBQVksT0FBTyxjQUFjLGlDQUFpQyxLQUFLLEVBQUUsNkJBQTZCLElBQUksZUFBZSw4Q0FBOEMsUUFBUSxjQUFjLG1FQUFtRSx1QkFBdUIsV0FBVyxJQUFJLGdCQUFnQiwrREFBK0QsNENBQTRDLDZCQUE2Qix3R0FBd0csTUFBTSxpQkFBaUIsd0hBQXdILG1DQUFtQywwRUFBMEUsTUFBTSxLQUFLLDRCQUE0Qix1QkFBdUIsVUFBVSxrQ0FBa0MseUNBQXlDLFlBQVksTUFBTSxXQUFXLFFBQVEsS0FBSyxXQUFXLDRCQUE0QixrRkFBa0YsZ0JBQWdCLEVBQUUscUJBQXFCLFlBQVksc0JBQXNCLEtBQUssUUFBUSxxQkFBcUIsNEJBQTRCLFFBQVEsS0FBSyxLQUFLLHFDQUFxQyxzQkFBc0Isd0JBQXdCLE1BQU0sK0JBQStCLDBCQUEwQiw2Q0FBNkMsNEJBQTRCLG9CQUFvQixJQUFJLDBCQUEwQixtRkFBbUYsS0FBSyxhQUFhLE1BQU0sVUFBVSxlQUFlLHFEQUFxRCxNQUFNLHVCQUF1Qix5SEFBeUgsbUJBQW1CLEtBQUssRUFBRSxrQkFBa0IsY0FBYyxnQkFBZ0Isa0NBQWtDLDRCQUE0QixTQUFTLDRCQUE0Qix3Q0FBd0MseUNBQXlDLHNEQUFzRCxtQ0FBbUMsc0NBQXNDLGdDQUFnQyxpQ0FBaUMsd0JBQXdCLG9CQUFvQiw0QkFBNEIsc0JBQXNCLDRDQUE0Qyw2QkFBNkIsME1BQTBNLCtDQUErQywrRkFBK0YsOEJBQThCLGlGQUFpRixHQUFHLEdBQUcsZ0JBQWdCLFFBQVEsRUFBRSxpQkFBaUIsU0FBUyxPQUFPLGNBQWMsZ0JBQWdCLFdBQVcsMEJBQTBCLElBQUksY0FBYyxXQUFXLGNBQWMsT0FBTyxzRUFBc0UscUJBQXFCLGlCQUFpQixzSUFBc0ksT0FBTyxZQUFZLFlBQVksNkJBQTZCLGtDQUFrQyxpQkFBaUIsZ0JBQWdCLHFDQUFxQyxzQ0FBc0MsNENBQTRDLDZCQUE2Qiw4REFBOEQsdUJBQXVCLHNDQUFzQyxrRkFBa0YsVUFBVSxnQ0FBZ0Msb0VBQW9FLDhCQUE4Qiw2QkFBNkIsR0FBRyx5R0FBeUcsSUFBSSxZQUFZLFVBQVUsRUFBRSxVQUFVLGlCQUFpQixjQUFjLGNBQWMsc0NBQXNDLDhEQUE4RCxHQUFHLEdBQUcsZ0JBQWdCLHdCQUF3QixxRUFBcUUsU0FBUyxLQUFLLElBQUksS0FBSyxpQkFBaUIsMEJBQTBCLGFBQWEsc0JBQXNCLCtNQUErTSxnQkFBZ0Isa0JBQWtCLGNBQWMsYUFBYSxRQUFRLGFBQWEsWUFBWSw4Q0FBOEMsK0JBQStCLHlDQUF5QyxTQUFTLHlCQUF5QixvQkFBb0IsUUFBUSw2QkFBNkIsMEJBQTBCLDJCQUEyQixJQUFJLEtBQUssYUFBYSx1QkFBdUIsU0FBUyxxQkFBcUIsc0JBQXNCLFFBQVEsd0ZBQXdGLDJCQUEyQiwyQkFBMkIsdUJBQXVCLHlCQUF5QixJQUFJLFdBQVcsVUFBVSx5RUFBeUUsZUFBZSxLQUFLLHVDQUF1QywrQ0FBK0MsdUNBQXVDLGdCQUFnQixhQUFhLG9DQUFvQyxFQUFFLFNBQVMsYUFBYSw0Q0FBNEMsb0JBQW9CLGVBQWUsbURBQW1ELEVBQUU7O0FBRXBtVSxhQUFhLHNCQUFzQjs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMkRBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQixPQUFPLEVBQUUsUUFBUTtBQUNuQyxLQUFLO0FBQ0wsTUFBTSxPQUFPO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQU87QUFDZjtBQUNBLHdDQUF3QyxxRUFBdUI7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSwrQ0FBTzs7QUFFYjtBQUNBLFFBQVEsK0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLCtDQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkJBQTZCO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksdUNBQXVDOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCwyQkFBMkIsZ0JBQWdCLE9BQU87QUFDMUc7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUEwRDtBQUM5RCxJQUFJLG9CQUFvQixJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0EsbUNBQW1DLHNDQUFzQztBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1CQUFtQjtBQUM5RDs7QUFFQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsdUNBQXVDO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQix3REFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBLEVBQUUsMEVBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQWU7QUFDNUIsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVM7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzRUFBc0U7QUFDMUY7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyx3Q0FBd0MsSUFBSTtBQUMvRSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFlO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw0REFBYTtBQUNsQztBQUNBLGdCQUFnQixnRkFBaUM7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLE1BQU0sY0FBYztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFdBQVc7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsaUVBQWtCLE1BQU0sd0RBQVM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixrRkFBaUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDJFQUEyRTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7QUFDeEQseURBQXlELGdCQUFnQjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyx1RUFBd0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7O0FBRTVCLHVCQUF1Qix1RkFBc0I7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1RkFBc0I7QUFDNUMsNkJBQTZCLDhFQUFhO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwRUFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQXVEOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsZ0ZBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3RkFBdUI7O0FBRTFFLHVFQUF1RSw4RUFBYTtBQUNwRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVM7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBUzs7QUFFMUIsRUFBRSx1R0FBc0M7QUFDeEMsRUFBRSxpR0FBZ0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdFQUFpQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1EQUFtRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQVU7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQixzRUFBWTtBQUNoQyxHQUFHO0FBQ0g7O0FBRUEsa0JBQWtCLG9EQUFVOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRix3QkFBd0I7O0FBRTVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFjO0FBQ3ZCLElBQUkseUVBQTBCLGNBQWMsOEVBQStCO0FBQzNFO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQSw2QkFBNkIsY0FBYyxFQUFFLGNBQWM7QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0Qjs7QUFFQSwrQkFBK0IsMkRBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQWlCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCxVQUFVLDZDQUE2Qzs7QUFFdkQsaUJBQWlCLHdEQUFTO0FBQzFCLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDJDQUEyQzs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlDQUFpQztBQUNqQztBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsK0RBQWdCLEdBQUc7QUFDeEMsTUFBTSw0REFBYTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSx5QkFBeUI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHlEQUFVO0FBQ2Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMEVBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw2Q0FBNkM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQzs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Qsb0JBQW9COztBQUU1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QixJQUFJO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELDBCQUEwQixPQUFPLE9BQU87O0FBRXpGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQkFBMkIsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUIsRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUI7QUFDaEcsbUJBQW1CLHVCQUF1QixFQUFFLFFBQVE7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDREQUFhO0FBQy9ELDJDQUEyQywwREFBVzs7QUFFdEQsd0NBQXdDLHlEQUFVO0FBQ2xELDhCQUE4QiwyRUFBZ0M7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLFdBQVcseURBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7O0FBRXhDLHFCQUFxQix3REFBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBdUU7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQyxHQUFHLGdCQUFnQjtBQUNyRTtBQUNBOztBQUVBLCtCQUErQix3REFBUztBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzREFBc0Q7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsOERBQWU7QUFDbEQsbUNBQW1DLDhEQUFlOztBQUVsRDtBQUNBLElBQUksNERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBUztBQUMxQjtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtzcGFjZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5LWludGVybmFsK3JlcGxheUAxMC4yNS4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL3JlcGxheS9idWlsZC9ucG0vZXNtL2luZGV4LmpzP2ZlNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR0xPQkFMX09CSiwgbm9ybWFsaXplLCBmaWxsLCBodG1sVHJlZUFzU3RyaW5nLCBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luLCBkZWJ1ZyBhcyBkZWJ1ZyQxLCBzZXZlcml0eUxldmVsRnJvbVN0cmluZywgY2FwdHVyZUV4Y2VwdGlvbiwgYWRkQnJlYWRjcnVtYiwgdXVpZDQsIGdldENsaWVudCwgZ2V0TG9jYXRpb25IcmVmLCBnZXRDdXJyZW50U2NvcGUsIGdldEFjdGl2ZVNwYW4sIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiwgaXNTZW50cnlSZXF1ZXN0VXJsLCBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4sIGFkZEV2ZW50UHJvY2Vzc29yLCBkZWJvdW5jZSBhcyBkZWJvdW5jZSQxLCBjcmVhdGVFbnZlbG9wZSwgY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMsIGdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXIsIHByZXBhcmVFdmVudCwgZ2V0SXNvbGF0aW9uU2NvcGUsIHVwZGF0ZVJhdGVMaW1pdHMsIGlzUmF0ZUxpbWl0ZWQsIHNldENvbnRleHQsIGdldFJvb3RTcGFuLCBzcGFuVG9KU09OLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSwgaXNCcm93c2VyLCBwYXJzZVNhbXBsZVJhdGUsIGNvbnNvbGVTYW5kYm94IH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IHNldFRpbWVvdXQgYXMgc2V0VGltZW91dCQzLCBhZGRQZXJmb3JtYW5jZUluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZExjcEluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZENsc0luc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZElucEluc3RydW1lbnRhdGlvbkhhbmRsZXIsIHNlcmlhbGl6ZUZvcm1EYXRhLCBnZXRGZXRjaFJlcXVlc3RBcmdCb2R5LCBnZXRCb2R5U3RyaW5nLCBTRU5UUllfWEhSX0RBVEFfS0VZLCBwYXJzZVhoclJlc3BvbnNlSGVhZGVycywgYWRkQ2xpY2tLZXlwcmVzc0luc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZEhpc3RvcnlJbnN0cnVtZW50YXRpb25IYW5kbGVyIH0gZnJvbSAnQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzJztcblxuLy8gZXhwb3J0aW5nIGEgc2VwYXJhdGUgY29weSBvZiBgV0lORE9XYCByYXRoZXIgdGhhbiBleHBvcnRpbmcgdGhlIG9uZSBmcm9tIGBAc2VudHJ5L2Jyb3dzZXJgXG4vLyBwcmV2ZW50cyB0aGUgYnJvd3NlciBwYWNrYWdlIGZyb20gYmVpbmcgYnVuZGxlZCBpbiB0aGUgQ0ROIGJ1bmRsZSwgYW5kIGF2b2lkcyBhXG4vLyBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGJyb3dzZXIgYW5kIHJlcGxheSBwYWNrYWdlcyBzaG91bGQgYEBzZW50cnkvYnJvd3NlcmAgaW1wb3J0XG4vLyBmcm9tIGBAc2VudHJ5L3JlcGxheWAgaW4gdGhlIGZ1dHVyZVxuY29uc3QgV0lORE9XID0gR0xPQkFMX09CSiA7XG5cbmNvbnN0IFJFUExBWV9TRVNTSU9OX0tFWSA9ICdzZW50cnlSZXBsYXlTZXNzaW9uJztcbmNvbnN0IFJFUExBWV9FVkVOVF9OQU1FID0gJ3JlcGxheV9ldmVudCc7XG5jb25zdCBVTkFCTEVfVE9fU0VORF9SRVBMQVkgPSAnVW5hYmxlIHRvIHNlbmQgUmVwbGF5JztcblxuLy8gVGhlIGlkbGUgbGltaXQgZm9yIGEgc2Vzc2lvbiBhZnRlciB3aGljaCByZWNvcmRpbmcgaXMgcGF1c2VkLlxuY29uc3QgU0VTU0lPTl9JRExFX1BBVVNFX0RVUkFUSU9OID0gMzAwMDAwOyAvLyA1IG1pbnV0ZXMgaW4gbXNcblxuLy8gVGhlIGlkbGUgbGltaXQgZm9yIGEgc2Vzc2lvbiBhZnRlciB3aGljaCB0aGUgc2Vzc2lvbiBleHBpcmVzLlxuY29uc3QgU0VTU0lPTl9JRExFX0VYUElSRV9EVVJBVElPTiA9IDkwMDAwMDsgLy8gMTUgbWludXRlcyBpbiBtc1xuXG4vKiogRGVmYXVsdCBmbHVzaCBkZWxheXMgKi9cbmNvbnN0IERFRkFVTFRfRkxVU0hfTUlOX0RFTEFZID0gNTAwMDtcbi8vIFhYWDogVGVtcCBmaXggZm9yIG91ciBkZWJvdW5jZSBsb2dpYyB3aGVyZSBgbWF4V2FpdGAgd291bGQgbmV2ZXIgb2NjdXIgaWYgaXRcbi8vIHdhcyB0aGUgc2FtZSBhcyBgd2FpdGBcbmNvbnN0IERFRkFVTFRfRkxVU0hfTUFYX0RFTEFZID0gNTUwMDtcblxuLyogSG93IGxvbmcgdG8gd2FpdCBmb3IgZXJyb3IgY2hlY2tvdXRzICovXG5jb25zdCBCVUZGRVJfQ0hFQ0tPVVRfVElNRSA9IDYwMDAwO1xuXG5jb25zdCBSRVRSWV9CQVNFX0lOVEVSVkFMID0gNTAwMDtcbmNvbnN0IFJFVFJZX01BWF9DT1VOVCA9IDM7XG5cbi8qIFRoZSBtYXggKHVuY29tcHJlc3NlZCkgc2l6ZSBpbiBieXRlcyBvZiBhIG5ldHdvcmsgYm9keS4gQW55IGJvZHkgbGFyZ2VyIHRoYW4gdGhpcyB3aWxsIGJlIHRydW5jYXRlZC4gKi9cbmNvbnN0IE5FVFdPUktfQk9EWV9NQVhfU0laRSA9IDE1MDAwMDtcblxuLyogVGhlIG1heCBzaXplIG9mIGEgc2luZ2xlIGNvbnNvbGUgYXJnIHRoYXQgaXMgY2FwdHVyZWQuIEFueSBhcmcgbGFyZ2VyIHRoYW4gdGhpcyB3aWxsIGJlIHRydW5jYXRlZC4gKi9cbmNvbnN0IENPTlNPTEVfQVJHX01BWF9TSVpFID0gNTAwMDtcblxuLyogTWluLiB0aW1lIHRvIHdhaXQgYmVmb3JlIHdlIGNvbnNpZGVyIHNvbWV0aGluZyBhIHNsb3cgY2xpY2suICovXG5jb25zdCBTTE9XX0NMSUNLX1RIUkVTSE9MRCA9IDMwMDA7XG4vKiBGb3Igc2Nyb2xsIGFjdGlvbnMgYWZ0ZXIgYSBjbGljaywgd2Ugb25seSBsb29rIGZvciBhIHZlcnkgc2hvcnQgdGltZSBwZXJpb2QgdG8gZGV0ZWN0IHByb2dyYW1tYXRpYyBzY3JvbGxpbmcuICovXG5jb25zdCBTTE9XX0NMSUNLX1NDUk9MTF9USU1FT1VUID0gMzAwO1xuXG4vKiogV2hlbiBlbmNvdW50ZXJpbmcgYSB0b3RhbCBzZWdtZW50IHNpemUgZXhjZWVkaW5nIHRoaXMgc2l6ZSwgc3RvcCB0aGUgcmVwbGF5IChhcyB3ZSBjYW5ub3QgcHJvcGVybHkgaW5nZXN0IGl0KS4gKi9cbmNvbnN0IFJFUExBWV9NQVhfRVZFTlRfQlVGRkVSX1NJWkUgPSAyMDAwMDAwMDsgLy8gfjIwTUJcblxuLyoqIFJlcGxheXMgbXVzdCBiZSBtaW4uIDVzIGxvbmcgYmVmb3JlIHdlIHNlbmQgdGhlbS4gKi9cbmNvbnN0IE1JTl9SRVBMQVlfRFVSQVRJT04gPSA0OTk5O1xuLyogVGhlIG1heC4gYWxsb3dlZCB2YWx1ZSB0aGF0IHRoZSBtaW5SZXBsYXlEdXJhdGlvbiBjYW4gYmUgc2V0IHRvLiAqL1xuY29uc3QgTUlOX1JFUExBWV9EVVJBVElPTl9MSU1JVCA9IDE1MDAwO1xuXG4vKiogVGhlIG1heC4gbGVuZ3RoIG9mIGEgcmVwbGF5LiAqL1xuY29uc3QgTUFYX1JFUExBWV9EVVJBVElPTiA9IDM2MDAwMDA7IC8vIDYwIG1pbnV0ZXMgaW4gbXM7XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIE5vZGVUeXBlJDIgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUkMiB8fCB7fSk7XG5mdW5jdGlvbiBpc0VsZW1lbnQkMShuMikge1xuICByZXR1cm4gbjIubm9kZVR5cGUgPT09IG4yLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuMikge1xuICBjb25zdCBob3N0ID0gbjI/Lmhvc3Q7XG4gIHJldHVybiBCb29sZWFuKGhvc3Q/LnNoYWRvd1Jvb3QgPT09IG4yKTtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzaGFkb3dSb290KSA9PT0gXCJbb2JqZWN0IFNoYWRvd1Jvb3RdXCI7XG59XG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcbiAgaWYgKGNzc1RleHQuaW5jbHVkZXMoXCIgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSAmJiAhY3NzVGV4dC5pbmNsdWRlcyhcIiAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDtcIikpIHtcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFxuICAgICAgL1xcc2JhY2tncm91bmQtY2xpcDpcXHMqdGV4dDsvZyxcbiAgICAgIFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuZnVuY3Rpb24gZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpIHtcbiAgY29uc3QgeyBjc3NUZXh0IH0gPSBydWxlO1xuICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKSByZXR1cm4gY3NzVGV4dDtcbiAgY29uc3Qgc3RhdGVtZW50ID0gW1wiQGltcG9ydFwiLCBgdXJsKCR7SlNPTi5zdHJpbmdpZnkocnVsZS5ocmVmKX0pYF07XG4gIGlmIChydWxlLmxheWVyTmFtZSA9PT0gXCJcIikge1xuICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcmApO1xuICB9IGVsc2UgaWYgKHJ1bGUubGF5ZXJOYW1lKSB7XG4gICAgc3RhdGVtZW50LnB1c2goYGxheWVyKCR7cnVsZS5sYXllck5hbWV9KWApO1xuICB9XG4gIGlmIChydWxlLnN1cHBvcnRzVGV4dCkge1xuICAgIHN0YXRlbWVudC5wdXNoKGBzdXBwb3J0cygke3J1bGUuc3VwcG9ydHNUZXh0fSlgKTtcbiAgfVxuICBpZiAocnVsZS5tZWRpYS5sZW5ndGgpIHtcbiAgICBzdGF0ZW1lbnQucHVzaChydWxlLm1lZGlhLm1lZGlhVGV4dCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlbWVudC5qb2luKFwiIFwiKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVzaGVldChzMikge1xuICB0cnkge1xuICAgIGNvbnN0IHJ1bGVzMiA9IHMyLnJ1bGVzIHx8IHMyLmNzc1J1bGVzO1xuICAgIHJldHVybiBydWxlczIgPyBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKFxuICAgICAgQXJyYXkuZnJvbShydWxlczIsIHN0cmluZ2lmeVJ1bGUpLmpvaW4oXCJcIilcbiAgICApIDogbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZml4QWxsQ3NzUHJvcGVydHkocnVsZSkge1xuICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHJ1bGUuc3R5bGUubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3Qgc3R5bGVEZWNsYXJhdGlvbiA9IHJ1bGUuc3R5bGU7XG4gICAgY29uc3QgYXR0cmlidXRlID0gc3R5bGVEZWNsYXJhdGlvbltpMl07XG4gICAgY29uc3QgaXNJbXBvcnRhbnQgPSBzdHlsZURlY2xhcmF0aW9uLmdldFByb3BlcnR5UHJpb3JpdHkoYXR0cmlidXRlKTtcbiAgICBzdHlsZXMgKz0gYCR7YXR0cmlidXRlfToke3N0eWxlRGVjbGFyYXRpb24uZ2V0UHJvcGVydHlWYWx1ZShhdHRyaWJ1dGUpfSR7aXNJbXBvcnRhbnQgPyBgICFpbXBvcnRhbnRgIDogXCJcIn07YDtcbiAgfVxuICByZXR1cm4gYCR7cnVsZS5zZWxlY3RvclRleHR9IHsgJHtzdHlsZXN9IH1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlKSB7XG4gIGxldCBpbXBvcnRTdHJpbmdpZmllZDtcbiAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlKSkge1xuICAgIHRyeSB7XG4gICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IC8vIGZvciBzYW1lLW9yaWdpbiBzdHlsZXNoZWV0cyxcbiAgICAgIC8vIHdlIGNhbiBhY2Nlc3MgdGhlIGltcG9ydGVkIHN0eWxlc2hlZXQgcnVsZXMgZGlyZWN0bHlcbiAgICAgIHN0cmluZ2lmeVN0eWxlc2hlZXQocnVsZS5zdHlsZVNoZWV0KSB8fCAvLyB3b3JrIGFyb3VuZCBicm93c2VyIGlzc3VlcyB3aXRoIHRoZSByYXcgc3RyaW5nIGBAaW1wb3J0IHVybCguLi4pYCBzdGF0ZW1lbnRcbiAgICAgIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NTU1N0eWxlUnVsZShydWxlKSkge1xuICAgIGxldCBjc3NUZXh0ID0gcnVsZS5jc3NUZXh0O1xuICAgIGNvbnN0IG5lZWRzU2FmYXJpQ29sb25GaXggPSBydWxlLnNlbGVjdG9yVGV4dC5pbmNsdWRlcyhcIjpcIik7XG4gICAgY29uc3QgbmVlZHNBbGxGaXggPSB0eXBlb2YgcnVsZS5zdHlsZVtcImFsbFwiXSA9PT0gXCJzdHJpbmdcIiAmJiBydWxlLnN0eWxlW1wiYWxsXCJdO1xuICAgIGlmIChuZWVkc0FsbEZpeCkge1xuICAgICAgY3NzVGV4dCA9IGZpeEFsbENzc1Byb3BlcnR5KHJ1bGUpO1xuICAgIH1cbiAgICBpZiAobmVlZHNTYWZhcmlDb2xvbkZpeCkge1xuICAgICAgY3NzVGV4dCA9IGZpeFNhZmFyaUNvbG9ucyhjc3NUZXh0KTtcbiAgICB9XG4gICAgaWYgKG5lZWRzU2FmYXJpQ29sb25GaXggfHwgbmVlZHNBbGxGaXgpIHtcbiAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW1wb3J0U3RyaW5naWZpZWQgfHwgcnVsZS5jc3NUZXh0O1xufVxuZnVuY3Rpb24gZml4U2FmYXJpQ29sb25zKGNzc1N0cmluZ2lmaWVkKSB7XG4gIGNvbnN0IHJlZ2V4ID0gLyhcXFsoPzpbXFx3LV0rKVteXFxcXF0pKDooPzpbXFx3LV0rKVxcXSkvZ207XG4gIHJldHVybiBjc3NTdHJpbmdpZmllZC5yZXBsYWNlKHJlZ2V4LCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuIFwic3R5bGVTaGVldFwiIGluIHJ1bGU7XG59XG5mdW5jdGlvbiBpc0NTU1N0eWxlUnVsZShydWxlKSB7XG4gIHJldHVybiBcInNlbGVjdG9yVGV4dFwiIGluIHJ1bGU7XG59XG5jbGFzcyBNaXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpZE5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibm9kZU1ldGFNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICB9XG4gIGdldElkKG4yKSB7XG4gICAgaWYgKCFuMikgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRNZXRhKG4yKT8uaWQ7XG4gICAgcmV0dXJuIGlkID8/IC0xO1xuICB9XG4gIGdldE5vZGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldElkcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlkTm9kZU1hcC5rZXlzKCkpO1xuICB9XG4gIGdldE1ldGEobjIpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobjIpIHx8IG51bGw7XG4gIH1cbiAgLy8gcmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGlkTm9kZU1hcFxuICAvLyBkb2Vzbid0IHJlbW92ZSB0aGUgbm9kZSBmcm9tIG5vZGVNZXRhTWFwXG4gIHJlbW92ZU5vZGVGcm9tTWFwKG4yKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElkKG4yKTtcbiAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xuICAgIGlmIChuMi5jaGlsZE5vZGVzKSB7XG4gICAgICBuMi5jaGlsZE5vZGVzLmZvckVhY2goXG4gICAgICAgIChjaGlsZE5vZGUpID0+IHRoaXMucmVtb3ZlTm9kZUZyb21NYXAoY2hpbGROb2RlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XG4gIH1cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUpO1xuICB9XG4gIGFkZChuMiwgbWV0YSkge1xuICAgIGNvbnN0IGlkID0gbWV0YS5pZDtcbiAgICB0aGlzLmlkTm9kZU1hcC5zZXQoaWQsIG4yKTtcbiAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gIH1cbiAgcmVwbGFjZShpZCwgbjIpIHtcbiAgICBjb25zdCBvbGROb2RlID0gdGhpcy5nZXROb2RlKGlkKTtcbiAgICBpZiAob2xkTm9kZSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMubm9kZU1ldGFNYXAuZ2V0KG9sZE5vZGUpO1xuICAgICAgaWYgKG1ldGEpIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pZE5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubm9kZU1ldGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWlycm9yJDIoKSB7XG4gIHJldHVybiBuZXcgTWlycm9yKCk7XG59XG5mdW5jdGlvbiBzaG91bGRNYXNrSW5wdXQoe1xuICBtYXNrSW5wdXRPcHRpb25zLFxuICB0YWdOYW1lLFxuICB0eXBlXG59KSB7XG4gIGlmICh0YWdOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgdGFnTmFtZSA9IFwiU0VMRUNUXCI7XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1t0eXBlXSB8fCB0eXBlID09PSBcInBhc3N3b3JkXCIgfHwgLy8gRGVmYXVsdCB0byBcInRleHRcIiBvcHRpb24gZm9yIGlucHV0cyB3aXRob3V0IGEgXCJ0eXBlXCIgYXR0cmlidXRlIGRlZmluZWRcbiAgICB0YWdOYW1lID09PSBcIklOUFVUXCIgJiYgIXR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1tcInRleHRcIl1cbiAgKTtcbn1cbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHtcbiAgaXNNYXNrZWQsXG4gIGVsZW1lbnQsXG4gIHZhbHVlLFxuICBtYXNrSW5wdXRGblxufSkge1xuICBsZXQgdGV4dCA9IHZhbHVlIHx8IFwiXCI7XG4gIGlmICghaXNNYXNrZWQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBpZiAobWFza0lucHV0Rm4pIHtcbiAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIFwiKlwiLnJlcGVhdCh0ZXh0Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyKSB7XG4gIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmNvbnN0IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gXCJfX3Jyd2ViX29yaWdpbmFsX19cIjtcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayhjYW52YXMpIHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybiB0cnVlO1xuICBjb25zdCBjaHVua1NpemUgPSA1MDtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHggKz0gY2h1bmtTaXplKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSkge1xuICAgICAgY29uc3QgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsR2V0SW1hZ2VEYXRhID0gT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgaW4gZ2V0SW1hZ2VEYXRhID8gZ2V0SW1hZ2VEYXRhW09SSUdJTkFMX0FUVFJJQlVURV9OQU1FXSA6IGdldEltYWdlRGF0YTtcbiAgICAgIGNvbnN0IHBpeGVsQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIG9yaWdpbmFsR2V0SW1hZ2VEYXRhLmNhbGwoXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgpLFxuICAgICAgICAgIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpXG4gICAgICAgICkuZGF0YS5idWZmZXJcbiAgICAgICk7XG4gICAgICBpZiAocGl4ZWxCdWZmZXIuc29tZSgocGl4ZWwpID0+IHBpeGVsICE9PSAwKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtcnItaXMtcGFzc3dvcmRcIikgPyBcInBhc3N3b3JkXCIgOiB0eXBlID8gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICB0b0xvd2VyQ2FzZSh0eXBlKVxuICApIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldElucHV0VmFsdWUoZWwsIHRhZ05hbWUsIHR5cGUpIHtcbiAgaWYgKHRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gZWwudmFsdWU7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZUV4dGVuc2lvbihwYXRoLCBiYXNlVVJMKSB7XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMID8/IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVnZXggPSAvXFwuKFswLTlhLXpdKykoPzokKS9pO1xuICBjb25zdCBtYXRjaCA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaD8uWzFdID8/IG51bGw7XG59XG5jb25zdCBjYWNoZWRJbXBsZW1lbnRhdGlvbnMkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0SW1wbGVtZW50YXRpb24kMShuYW1lKSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlZEltcGxlbWVudGF0aW9ucyQxW25hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCBkb2N1bWVudDIgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGxldCBpbXBsID0gd2luZG93W25hbWVdO1xuICBpZiAoZG9jdW1lbnQyICYmIHR5cGVvZiBkb2N1bWVudDIuY3JlYXRlRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhbmRib3ggPSBkb2N1bWVudDIuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIHNhbmRib3guaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50Mi5oZWFkLmFwcGVuZENoaWxkKHNhbmRib3gpO1xuICAgICAgY29uc3QgY29udGVudFdpbmRvdyA9IHNhbmRib3guY29udGVudFdpbmRvdztcbiAgICAgIGlmIChjb250ZW50V2luZG93ICYmIGNvbnRlbnRXaW5kb3dbbmFtZV0pIHtcbiAgICAgICAgaW1wbCA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgY29udGVudFdpbmRvd1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50Mi5oZWFkLnJlbW92ZUNoaWxkKHNhbmRib3gpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZWRJbXBsZW1lbnRhdGlvbnMkMVtuYW1lXSA9IGltcGwuYmluZChcbiAgICB3aW5kb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIHNldFRpbWVvdXQkMiguLi5yZXN0KSB7XG4gIHJldHVybiBnZXRJbXBsZW1lbnRhdGlvbiQxKFwic2V0VGltZW91dFwiKSguLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dCQxKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uJDEoXCJjbGVhclRpbWVvdXRcIikoLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBnZXRJZnJhbWVDb250ZW50RG9jdW1lbnQoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbn1cbmxldCBfaWQgPSAxO1xuY29uc3QgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteYS16MC05LV86XVwiKTtcbmNvbnN0IElHTk9SRURfTk9ERSA9IC0yO1xuZnVuY3Rpb24gZ2VuSWQoKSB7XG4gIHJldHVybiBfaWQrKztcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZSQxKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJmb3JtXCI7XG4gIH1cbiAgY29uc3QgcHJvY2Vzc2VkVGFnTmFtZSA9IHRvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lUmVnZXgudGVzdChwcm9jZXNzZWRUYWdOYW1lKSkge1xuICAgIHJldHVybiBcImRpdlwiO1xuICB9XG4gIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xufVxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcbiAgbGV0IG9yaWdpbiA9IFwiXCI7XG4gIGlmICh1cmwuaW5kZXhPZihcIi8vXCIpID4gLTEpIHtcbiAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIilbMF07XG4gIH1cbiAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KFwiP1wiKVswXTtcbiAgcmV0dXJuIG9yaWdpbjtcbn1cbmxldCBjYW52YXNTZXJ2aWNlO1xubGV0IGNhbnZhc0N0eDtcbmNvbnN0IFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xuY29uc3QgVVJMX1BST1RPQ09MX01BVENIID0gL14oPzpbYS16K10rOik/XFwvXFwvL2k7XG5jb25zdCBVUkxfV1dXX01BVENIID0gL153d3dcXC4uKi9pO1xuY29uc3QgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcbmZ1bmN0aW9uIGZpbHRlckNTU1Byb3BlcnRpZXNGcm9tSW5saW5lU3R5bGUoY3NzVGV4dCwgaWdub3JlZFByb3BlcnRpZXMpIHtcbiAgaWYgKCFjc3NUZXh0IHx8IGlnbm9yZWRQcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gY3NzVGV4dDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBjc3NUZXh0LnNwbGl0KFwiO1wiKTtcbiAgICBjb25zdCBmaWx0ZXJlZFByb3BlcnRpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRyaW0oKTtcbiAgICAgIGlmICghcHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgY29sb25JbmRleCA9IHByb3BlcnR5LmluZGV4T2YoXCI6XCIpO1xuICAgICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGZpbHRlcmVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS5zbGljZSgwLCBjb2xvbkluZGV4KS50cmltKCk7XG4gICAgICBpZiAoIWlnbm9yZWRQcm9wZXJ0aWVzLmhhcyhwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIGZpbHRlcmVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcGVydGllcy5qb2luKFwiOyBcIikgKyAoZmlsdGVyZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDAgJiYgY3NzVGV4dC5lbmRzV2l0aChcIjtcIikgPyBcIjtcIiA6IFwiXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihcIkVycm9yIGZpbHRlcmluZyBDU1MgcHJvcGVydGllczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBjc3NUZXh0O1xuICB9XG59XG5mdW5jdGlvbiBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBocmVmKSB7XG4gIHJldHVybiAoY3NzVGV4dCB8fCBcIlwiKS5yZXBsYWNlKFxuICAgIFVSTF9JTl9DU1NfUkVGLFxuICAgIChvcmlnaW4sIHF1b3RlMSwgcGF0aDEsIHF1b3RlMiwgcGF0aDIsIHBhdGgzKSA9PiB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgxIHx8IHBhdGgyIHx8IHBhdGgzO1xuICAgICAgY29uc3QgbWF5YmVRdW90ZSA9IHF1b3RlMSB8fCBxdW90ZTIgfHwgXCJcIjtcbiAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChVUkxfUFJPVE9DT0xfTUFUQ0gudGVzdChmaWxlUGF0aCkgfHwgVVJMX1dXV19NQVRDSC50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtmaWxlUGF0aH0ke21heWJlUXVvdGV9KWA7XG4gICAgICB9XG4gICAgICBpZiAoREFUQV9VUkkudGVzdChmaWxlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtleHRyYWN0T3JpZ2luKGhyZWYpICsgZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhY2sgPSBocmVmLnNwbGl0KFwiL1wiKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IFwiLlwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7c3RhY2suam9pbihcIi9cIil9JHttYXliZVF1b3RlfSlgO1xuICAgIH1cbiAgKTtcbn1cbmNvbnN0IFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xuY29uc3QgU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMgPSAvXlssIFxcdFxcblxcclxcdTAwMGNdKy87XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gIGlmIChhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XG4gIH1cbiAgbGV0IHBvcyA9IDA7XG4gIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XG4gICAgbGV0IGNoYXJzMjtcbiAgICBjb25zdCBtYXRjaCA9IHJlZ0V4LmV4ZWMoYXR0cmlidXRlVmFsdWUuc3Vic3RyaW5nKHBvcykpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY2hhcnMyID0gbWF0Y2hbMF07XG4gICAgICBwb3MgKz0gY2hhcnMyLmxlbmd0aDtcbiAgICAgIHJldHVybiBjaGFyczI7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTKTtcbiAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCB1cmwgPSBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfTk9UX1NQQUNFUyk7XG4gICAgaWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSkpO1xuICAgICAgb3V0cHV0LnB1c2godXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlc2NyaXB0b3JzU3RyID0gXCJcIjtcbiAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwpO1xuICAgICAgbGV0IGluUGFyZW5zID0gZmFsc2U7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBjMiA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xuICAgICAgICBpZiAoYzIgPT09IFwiXCIpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoIWluUGFyZW5zKSB7XG4gICAgICAgICAgaWYgKGMyID09PSBcIixcIikge1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMyID09PSBcIihcIikge1xuICAgICAgICAgICAgaW5QYXJlbnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYzIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICBpblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yc1N0ciArPSBjMjtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbihcIiwgXCIpO1xufVxuY29uc3QgY2FjaGVkRG9jdW1lbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0SHJlZihkb2MsIGF0dHJpYnV0ZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xuICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSBcInN2Z1wiIHx8IGVsLm93bmVyU1ZHRWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXRIcmVmKGRvYywgY3VzdG9tSHJlZikge1xuICBsZXQgYTIgPSBjYWNoZWREb2N1bWVudC5nZXQoZG9jKTtcbiAgaWYgKCFhMikge1xuICAgIGEyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGNhY2hlZERvY3VtZW50LnNldChkb2MsIGEyKTtcbiAgfVxuICBpZiAoIWN1c3RvbUhyZWYpIHtcbiAgICBjdXN0b21IcmVmID0gXCJcIjtcbiAgfSBlbHNlIGlmIChjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCBjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiBjdXN0b21IcmVmO1xuICB9XG4gIGEyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgY3VzdG9tSHJlZik7XG4gIHJldHVybiBhMi5ocmVmO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgbmFtZSwgdmFsdWUsIGVsZW1lbnQsIG1hc2tBdHRyaWJ1dGVGbiwgaWdub3JlQ1NTQXR0cmlidXRlcykge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChuYW1lID09PSBcInNyY1wiIHx8IG5hbWUgPT09IFwiaHJlZlwiICYmICEodGFnTmFtZSA9PT0gXCJ1c2VcIiAmJiB2YWx1ZVswXSA9PT0gXCIjXCIpKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ4bGluazpocmVmXCIgJiYgdmFsdWVbMF0gIT09IFwiI1wiKSB7XG4gICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIgJiYgKHRhZ05hbWUgPT09IFwidGFibGVcIiB8fCB0YWdOYW1lID09PSBcInRkXCIgfHwgdGFnTmFtZSA9PT0gXCJ0aFwiKSkge1xuICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3Jjc2V0XCIpIHtcbiAgICByZXR1cm4gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0eWxlID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQodmFsdWUsIGdldEhyZWYoZG9jKSk7XG4gICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMgJiYgaWdub3JlQ1NTQXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgcHJvY2Vzc2VkU3R5bGUgPSBmaWx0ZXJDU1NQcm9wZXJ0aWVzRnJvbUlubGluZVN0eWxlKFxuICAgICAgICBwcm9jZXNzZWRTdHlsZSxcbiAgICAgICAgaWdub3JlQ1NTQXR0cmlidXRlc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NlZFN0eWxlO1xuICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgbmFtZSA9PT0gXCJkYXRhXCIpIHtcbiAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIG1hc2tBdHRyaWJ1dGVGbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG1hc2tBdHRyaWJ1dGVGbihuYW1lLCB2YWx1ZSwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIG5hbWUsIF92YWx1ZSkge1xuICByZXR1cm4gKHRhZ05hbWUgPT09IFwidmlkZW9cIiB8fCB0YWdOYW1lID09PSBcImF1ZGlvXCIpICYmIG5hbWUgPT09IFwiYXV0b3BsYXlcIjtcbn1cbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHVuYmxvY2tTZWxlY3Rvcikge1xuICB0cnkge1xuICAgIGlmICh1bmJsb2NrU2VsZWN0b3IgJiYgZWxlbWVudC5tYXRjaGVzKHVuYmxvY2tTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGVJbmRleCA9IGVsZW1lbnQuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07ICkge1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTGlzdFtlSW5kZXhdO1xuICAgICAgICBpZiAoYmxvY2tDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhibG9ja1NlbGVjdG9yKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZWxlbWVudENsYXNzTWF0Y2hlc1JlZ2V4KGVsLCByZWdleCkge1xuICBmb3IgKGxldCBlSW5kZXggPSBlbC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTsgKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZWwuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgaWYgKHJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlVG9NYXRjaChub2RlLCBtYXRjaFByZWRpY2F0ZSwgbGltaXQgPSBJbmZpbml0eSwgZGlzdGFuY2UgPSAwKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIC0xO1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5FTEVNRU5UX05PREUpIHJldHVybiAtMTtcbiAgaWYgKGRpc3RhbmNlID4gbGltaXQpIHJldHVybiAtMTtcbiAgaWYgKG1hdGNoUHJlZGljYXRlKG5vZGUpKSByZXR1cm4gZGlzdGFuY2U7XG4gIHJldHVybiBkaXN0YW5jZVRvTWF0Y2gobm9kZS5wYXJlbnROb2RlLCBtYXRjaFByZWRpY2F0ZSwgbGltaXQsIGRpc3RhbmNlICsgMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXRjaFByZWRpY2F0ZShjbGFzc05hbWUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsID0gbm9kZTtcbiAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChlbC5tYXRjaGVzKGAuJHtjbGFzc05hbWV9YCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRDbGFzc01hdGNoZXNSZWdleChlbCwgY2xhc3NOYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0b3IgJiYgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCB1bm1hc2tUZXh0Q2xhc3MsIHVubWFza1RleHRTZWxlY3RvciwgbWFza0FsbFRleHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgICBjb25zdCBhdXRvY29tcGxldGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIik7XG4gICAgICBjb25zdCBkaXNhbGxvd2VkQXV0b2NvbXBsZXRlVmFsdWVzID0gW1xuICAgICAgICBcImN1cnJlbnQtcGFzc3dvcmRcIixcbiAgICAgICAgXCJuZXctcGFzc3dvcmRcIixcbiAgICAgICAgXCJjYy1udW1iZXJcIixcbiAgICAgICAgXCJjYy1leHBcIixcbiAgICAgICAgXCJjYy1leHAtbW9udGhcIixcbiAgICAgICAgXCJjYy1leHAteWVhclwiLFxuICAgICAgICBcImNjLWNzY1wiXG4gICAgICBdO1xuICAgICAgaWYgKGRpc2FsbG93ZWRBdXRvY29tcGxldGVWYWx1ZXMuaW5jbHVkZXMoYXV0b2NvbXBsZXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hc2tEaXN0YW5jZSA9IC0xO1xuICAgIGxldCB1bm1hc2tEaXN0YW5jZSA9IC0xO1xuICAgIGlmIChtYXNrQWxsVGV4dCkge1xuICAgICAgdW5tYXNrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goXG4gICAgICAgIGVsLFxuICAgICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZSh1bm1hc2tUZXh0Q2xhc3MsIHVubWFza1RleHRTZWxlY3RvcilcbiAgICAgICk7XG4gICAgICBpZiAodW5tYXNrRGlzdGFuY2UgPCAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbWFza0Rpc3RhbmNlID0gZGlzdGFuY2VUb01hdGNoKFxuICAgICAgICBlbCxcbiAgICAgICAgY3JlYXRlTWF0Y2hQcmVkaWNhdGUobWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciksXG4gICAgICAgIHVubWFza0Rpc3RhbmNlID49IDAgPyB1bm1hc2tEaXN0YW5jZSA6IEluZmluaXR5XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXNrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goXG4gICAgICAgIGVsLFxuICAgICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZShtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yKVxuICAgICAgKTtcbiAgICAgIGlmIChtYXNrRGlzdGFuY2UgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHVubWFza0Rpc3RhbmNlID0gZGlzdGFuY2VUb01hdGNoKFxuICAgICAgICBlbCxcbiAgICAgICAgY3JlYXRlTWF0Y2hQcmVkaWNhdGUodW5tYXNrVGV4dENsYXNzLCB1bm1hc2tUZXh0U2VsZWN0b3IpLFxuICAgICAgICBtYXNrRGlzdGFuY2UgPj0gMCA/IG1hc2tEaXN0YW5jZSA6IEluZmluaXR5XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbWFza0Rpc3RhbmNlID49IDAgPyB1bm1hc2tEaXN0YW5jZSA+PSAwID8gbWFza0Rpc3RhbmNlIDw9IHVubWFza0Rpc3RhbmNlIDogdHJ1ZSA6IHVubWFza0Rpc3RhbmNlID49IDAgPyBmYWxzZSA6ICEhbWFza0FsbFRleHQ7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuICEhbWFza0FsbFRleHQ7XG59XG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcbiAgY29uc3Qgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGZpcmVkID0gZmFsc2U7XG4gIGxldCByZWFkeVN0YXRlO1xuICB0cnkge1xuICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCQyKCgpID0+IHtcbiAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQkMSh0aW1lcik7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBibGFua1VybCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fCBpZnJhbWVFbC5zcmMgPT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gXCJcIikge1xuICAgIHNldFRpbWVvdXQkMihsaXN0ZW5lciwgMCk7XG4gICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbiAgfVxuICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBvbmNlU3R5bGVzaGVldExvYWRlZChsaW5rLCBsaXN0ZW5lciwgc3R5bGVTaGVldExvYWRUaW1lb3V0KSB7XG4gIGxldCBmaXJlZCA9IGZhbHNlO1xuICBsZXQgc3R5bGVTaGVldExvYWRlZDtcbiAgdHJ5IHtcbiAgICBzdHlsZVNoZWV0TG9hZGVkID0gbGluay5zaGVldDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpIHJldHVybjtcbiAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0JDIoKCkgPT4ge1xuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgfVxuICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xuICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQkMSh0aW1lcik7XG4gICAgZmlyZWQgPSB0cnVlO1xuICAgIGxpc3RlbmVyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZG9jLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tBbGxUZXh0LFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIHVubWFza1RleHRDbGFzcyxcbiAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgIG1hc2tJbnB1dE9wdGlvbnMgPSB7fSxcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIGRhdGFVUkxPcHRpb25zID0ge30sXG4gICAgaW5saW5lSW1hZ2VzLFxuICAgIHJlY29yZENhbnZhcyxcbiAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByb290SWQgPSBnZXRSb290SWQoZG9jLCBtaXJyb3IyKTtcbiAgc3dpdGNoIChuMi5ub2RlVHlwZSkge1xuICAgIGNhc2UgbjIuRE9DVU1FTlRfTk9ERTpcbiAgICAgIGlmIChuMi5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgY29tcGF0TW9kZTogbjIuY29tcGF0TW9kZVxuICAgICAgICAgIC8vIHByb2JhYmx5IFwiQmFja0NvbXBhdFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGROb2RlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIG4yLkRPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuRG9jdW1lbnRUeXBlLFxuICAgICAgICBuYW1lOiBuMi5uYW1lLFxuICAgICAgICBwdWJsaWNJZDogbjIucHVibGljSWQsXG4gICAgICAgIHN5c3RlbUlkOiBuMi5zeXN0ZW1JZCxcbiAgICAgICAgcm9vdElkXG4gICAgICB9O1xuICAgIGNhc2UgbjIuRUxFTUVOVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIGNhc2UgbjIuVEVYVF9OT0RFOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4yLCB7XG4gICAgICAgIGRvYyxcbiAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICBtYXNrVGV4dEZuLFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgcm9vdElkXG4gICAgICB9KTtcbiAgICBjYXNlIG4yLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE5vZGVUeXBlJDIuQ0RBVEEsXG4gICAgICAgIHRleHRDb250ZW50OiBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgY2FzZSBuMi5DT01NRU5UX05PREU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQyLkNvbW1lbnQsXG4gICAgICAgIHRleHRDb250ZW50OiBuMi50ZXh0Q29udGVudCB8fCBcIlwiLFxuICAgICAgICByb290SWRcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Um9vdElkKGRvYywgbWlycm9yMikge1xuICBpZiAoIW1pcnJvcjIuaGFzTm9kZShkb2MpKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBkb2NJZCA9IG1pcnJvcjIuZ2V0SWQoZG9jKTtcbiAgcmV0dXJuIGRvY0lkID09PSAxID8gdm9pZCAwIDogZG9jSWQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuMiwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbWFza0FsbFRleHQsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHJvb3RJZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGFyZW50VGFnTmFtZSA9IG4yLnBhcmVudE5vZGUgJiYgbjIucGFyZW50Tm9kZS50YWdOYW1lO1xuICBsZXQgdGV4dENvbnRlbnQgPSBuMi50ZXh0Q29udGVudDtcbiAgY29uc3QgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09IFwiU1RZTEVcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTQ1JJUFRcIiA/IHRydWUgOiB2b2lkIDA7XG4gIGNvbnN0IGlzVGV4dGFyZWEgPSBwYXJlbnRUYWdOYW1lID09PSBcIlRFWFRBUkVBXCIgPyB0cnVlIDogdm9pZCAwO1xuICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAobjIubmV4dFNpYmxpbmcgfHwgbjIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICB9IGVsc2UgaWYgKG4yLnBhcmVudE5vZGUuc2hlZXQ/LmNzc1J1bGVzKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gc3RyaW5naWZ5U3R5bGVzaGVldChcbiAgICAgICAgICBuMi5wYXJlbnROb2RlLnNoZWV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBDYW5ub3QgZ2V0IENTUyBzdHlsZXMgZnJvbSB0ZXh0J3MgcGFyZW50Tm9kZS4gRXJyb3I6ICR7ZXJyfWAsXG4gICAgICAgIG4yXG4gICAgICApO1xuICAgIH1cbiAgICB0ZXh0Q29udGVudCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KHRleHRDb250ZW50LCBnZXRIcmVmKG9wdGlvbnMuZG9jKSk7XG4gIH1cbiAgaWYgKGlzU2NyaXB0KSB7XG4gICAgdGV4dENvbnRlbnQgPSBcIlNDUklQVF9QTEFDRUhPTERFUlwiO1xuICB9XG4gIGNvbnN0IGZvcmNlTWFzayA9IG5lZWRNYXNraW5nVGV4dChcbiAgICBuMixcbiAgICBtYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICBtYXNrQWxsVGV4dFxuICApO1xuICBpZiAoIWlzU3R5bGUgJiYgIWlzU2NyaXB0ICYmICFpc1RleHRhcmVhICYmIHRleHRDb250ZW50ICYmIGZvcmNlTWFzaykge1xuICAgIHRleHRDb250ZW50ID0gbWFza1RleHRGbiA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnQsIG4yLnBhcmVudEVsZW1lbnQpIDogdGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICB9XG4gIGlmIChpc1RleHRhcmVhICYmIHRleHRDb250ZW50ICYmIChtYXNrSW5wdXRPcHRpb25zLnRleHRhcmVhIHx8IGZvcmNlTWFzaykpIHtcbiAgICB0ZXh0Q29udGVudCA9IG1hc2tJbnB1dEZuID8gbWFza0lucHV0Rm4odGV4dENvbnRlbnQsIG4yLnBhcmVudE5vZGUpIDogdGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICB9XG4gIGlmIChwYXJlbnRUYWdOYW1lID09PSBcIk9QVElPTlwiICYmIHRleHRDb250ZW50KSB7XG4gICAgY29uc3QgaXNJbnB1dE1hc2tlZCA9IHNob3VsZE1hc2tJbnB1dCh7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgdGFnTmFtZTogcGFyZW50VGFnTmFtZSxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnNcbiAgICB9KTtcbiAgICB0ZXh0Q29udGVudCA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgIGlzTWFza2VkOiBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgIG4yLFxuICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgaXNJbnB1dE1hc2tlZFxuICAgICAgKSxcbiAgICAgIGVsZW1lbnQ6IG4yLFxuICAgICAgdmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgbWFza0lucHV0Rm5cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IE5vZGVUeXBlJDIuVGV4dCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQgfHwgXCJcIixcbiAgICBpc1N0eWxlLFxuICAgIHJvb3RJZFxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50ID0gZmFsc2UsXG4gICAgcm9vdElkLFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5lZWRCbG9jayA9IF9pc0Jsb2NrZWRFbGVtZW50KFxuICAgIG4yLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICB1bmJsb2NrU2VsZWN0b3JcbiAgKTtcbiAgY29uc3QgdGFnTmFtZSA9IGdldFZhbGlkVGFnTmFtZSQxKG4yKTtcbiAgbGV0IGF0dHJpYnV0ZXMyID0ge307XG4gIGNvbnN0IGxlbiA9IG4yLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgY29uc3QgYXR0ciA9IG4yLmF0dHJpYnV0ZXNbaTJdO1xuICAgIGlmIChhdHRyLm5hbWUgJiYgIWlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzMlthdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKFxuICAgICAgICBkb2MsXG4gICAgICAgIHRhZ05hbWUsXG4gICAgICAgIHRvTG93ZXJDYXNlKGF0dHIubmFtZSksXG4gICAgICAgIGF0dHIudmFsdWUsXG4gICAgICAgIG4yLFxuICAgICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImxpbmtcIiAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XG4gICAgY29uc3Qgc3R5bGVzaGVldCA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maW5kKChzMikgPT4ge1xuICAgICAgcmV0dXJuIHMyLmhyZWYgPT09IG4yLmhyZWY7XG4gICAgfSk7XG4gICAgbGV0IGNzc1RleHQgPSBudWxsO1xuICAgIGlmIChzdHlsZXNoZWV0KSB7XG4gICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChzdHlsZXNoZWV0KTtcbiAgICB9XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGF0dHJpYnV0ZXMyLnJlbCA9IG51bGw7XG4gICAgICBhdHRyaWJ1dGVzMi5ocmVmID0gbnVsbDtcbiAgICAgIGF0dHJpYnV0ZXMyLmNyb3Nzb3JpZ2luID0gbnVsbDtcbiAgICAgIGF0dHJpYnV0ZXMyLl9jc3NUZXh0ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgc3R5bGVzaGVldC5ocmVmKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwic3R5bGVcIiAmJiBuMi5zaGVldCAmJiAvLyBUT0RPOiBDdXJyZW50bHkgd2Ugb25seSB0cnkgdG8gZ2V0IGR5bmFtaWMgc3R5bGVzaGVldCB3aGVuIGl0IGlzIGFuIGVtcHR5IHN0eWxlIGVsZW1lbnRcbiAgIShuMi5pbm5lclRleHQgfHwgbjIudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpLmxlbmd0aCkge1xuICAgIGNvbnN0IGNzc1RleHQgPSBzdHJpbmdpZnlTdHlsZXNoZWV0KFxuICAgICAgbjIuc2hlZXRcbiAgICApO1xuICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICBhdHRyaWJ1dGVzMi5fY3NzVGV4dCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KGNzc1RleHQsIGdldEhyZWYoZG9jKSk7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZ05hbWUgPT09IFwic2VsZWN0XCIgfHwgdGFnTmFtZSA9PT0gXCJvcHRpb25cIikge1xuICAgIGNvbnN0IGVsID0gbjI7XG4gICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZShlbCk7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dFZhbHVlKGVsLCB0b1VwcGVyQ2FzZSh0YWdOYW1lKSwgdHlwZSk7XG4gICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgaWYgKHR5cGUgIT09IFwic3VibWl0XCIgJiYgdHlwZSAhPT0gXCJidXR0b25cIiAmJiB2YWx1ZSkge1xuICAgICAgY29uc3QgZm9yY2VNYXNrID0gbmVlZE1hc2tpbmdUZXh0KFxuICAgICAgICBlbCxcbiAgICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgIHNob3VsZE1hc2tJbnB1dCh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0YWdOYW1lOiB0b1VwcGVyQ2FzZSh0YWdOYW1lKSxcbiAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgYXR0cmlidXRlczIudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgIGlzTWFza2VkOiBmb3JjZU1hc2ssXG4gICAgICAgIGVsZW1lbnQ6IGVsLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbWFza0lucHV0Rm5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgYXR0cmlidXRlczIuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcIm9wdGlvblwiKSB7XG4gICAgaWYgKG4yLnNlbGVjdGVkICYmICFtYXNrSW5wdXRPcHRpb25zW1wic2VsZWN0XCJdKSB7XG4gICAgICBhdHRyaWJ1dGVzMi5zZWxlY3RlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzMi5zZWxlY3RlZDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiY2FudmFzXCIgJiYgcmVjb3JkQ2FudmFzKSB7XG4gICAgaWYgKG4yLl9fY29udGV4dCA9PT0gXCIyZFwiKSB7XG4gICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayhuMikpIHtcbiAgICAgICAgYXR0cmlidXRlczIucnJfZGF0YVVSTCA9IG4yLnRvRGF0YVVSTChcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy50eXBlLFxuICAgICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXCJfX2NvbnRleHRcIiBpbiBuMikpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0RhdGFVUkwgPSBuMi50b0RhdGFVUkwoXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnR5cGUsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLnF1YWxpdHlcbiAgICAgICk7XG4gICAgICBjb25zdCBibGFua0NhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuMi53aWR0aDtcbiAgICAgIGJsYW5rQ2FudmFzLmhlaWdodCA9IG4yLmhlaWdodDtcbiAgICAgIGNvbnN0IGJsYW5rQ2FudmFzRGF0YVVSTCA9IGJsYW5rQ2FudmFzLnRvRGF0YVVSTChcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMucXVhbGl0eVxuICAgICAgKTtcbiAgICAgIGlmIChjYW52YXNEYXRhVVJMICE9PSBibGFua0NhbnZhc0RhdGFVUkwpIHtcbiAgICAgICAgYXR0cmlidXRlczIucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImltZ1wiICYmIGlubGluZUltYWdlcykge1xuICAgIGlmICghY2FudmFzU2VydmljZSkge1xuICAgICAgY2FudmFzU2VydmljZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlID0gbjI7XG4gICAgY29uc3QgaW1hZ2VTcmMgPSBpbWFnZS5jdXJyZW50U3JjIHx8IGltYWdlLmdldEF0dHJpYnV0ZShcInNyY1wiKSB8fCBcIjx1bmtub3duLXNyYz5cIjtcbiAgICBjb25zdCBwcmlvckNyb3NzT3JpZ2luID0gaW1hZ2UuY3Jvc3NPcmlnaW47XG4gICAgY29uc3QgcmVjb3JkSW5saW5lSW1hZ2UgPSAoKSA9PiB7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgICB0cnkge1xuICAgICAgICBjYW52YXNTZXJ2aWNlLndpZHRoID0gaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICBjYW52YXNTZXJ2aWNlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICBhdHRyaWJ1dGVzMi5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMudHlwZSxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luICE9PSBcImFub255bW91c1wiKSB7XG4gICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApXG4gICAgICAgICAgICByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgICAgICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgQ2Fubm90IGlubGluZSBpbWcgc3JjPSR7aW1hZ2VTcmN9ISBFcnJvcjogJHtlcnJ9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiA9PT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICBwcmlvckNyb3NzT3JpZ2luID8gYXR0cmlidXRlczIuY3Jvc3NPcmlnaW4gPSBwcmlvckNyb3NzT3JpZ2luIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKSByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICB9XG4gIGlmICh0YWdOYW1lID09PSBcImF1ZGlvXCIgfHwgdGFnTmFtZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgYXR0cmlidXRlczIucnJfbWVkaWFTdGF0ZSA9IG4yLnBhdXNlZCA/IFwicGF1c2VkXCIgOiBcInBsYXllZFwiO1xuICAgIGF0dHJpYnV0ZXMyLnJyX21lZGlhQ3VycmVudFRpbWUgPSBuMi5jdXJyZW50VGltZTtcbiAgfVxuICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XG4gICAgaWYgKG4yLnNjcm9sbExlZnQpIHtcbiAgICAgIGF0dHJpYnV0ZXMyLnJyX3Njcm9sbExlZnQgPSBuMi5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBpZiAobjIuc2Nyb2xsVG9wKSB7XG4gICAgICBhdHRyaWJ1dGVzMi5ycl9zY3JvbGxUb3AgPSBuMi5zY3JvbGxUb3A7XG4gICAgfVxuICB9XG4gIGlmIChuZWVkQmxvY2spIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG4yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGF0dHJpYnV0ZXMyID0ge1xuICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMyLmNsYXNzLFxuICAgICAgcnJfd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgIHJyX2hlaWdodDogYCR7aGVpZ2h0fXB4YFxuICAgIH07XG4gIH1cbiAgaWYgKHRhZ05hbWUgPT09IFwiaWZyYW1lXCIgJiYgIWtlZXBJZnJhbWVTcmNGbihhdHRyaWJ1dGVzMi5zcmMpKSB7XG4gICAgaWYgKCFuZWVkQmxvY2sgJiYgIWdldElmcmFtZUNvbnRlbnREb2N1bWVudChuMikpIHtcbiAgICAgIGF0dHJpYnV0ZXMyLnJyX3NyYyA9IGF0dHJpYnV0ZXMyLnNyYztcbiAgICB9XG4gICAgZGVsZXRlIGF0dHJpYnV0ZXMyLnNyYztcbiAgfVxuICBsZXQgaXNDdXN0b21FbGVtZW50O1xuICB0cnkge1xuICAgIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIGlzQ3VzdG9tRWxlbWVudCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBOb2RlVHlwZSQyLkVsZW1lbnQsXG4gICAgdGFnTmFtZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzMixcbiAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICBpc1NWRzogaXNTVkdFbGVtZW50KG4yKSB8fCB2b2lkIDAsXG4gICAgbmVlZEJsb2NrLFxuICAgIHJvb3RJZCxcbiAgICBpc0N1c3RvbTogaXNDdXN0b21FbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xuICBpZiAobWF5YmVBdHRyID09PSB2b2lkIDAgfHwgbWF5YmVBdHRyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1heWJlQXR0ci50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XG4gIGlmIChzbGltRE9NT3B0aW9ucy5jb21tZW50ICYmIHNuLnR5cGUgPT09IE5vZGVUeXBlJDIuQ29tbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHNuLnR5cGUgPT09IE5vZGVUeXBlJDIuRWxlbWVudCkge1xuICAgIGlmIChzbGltRE9NT3B0aW9ucy5zY3JpcHQgJiYgLy8gc2NyaXB0IHRhZ1xuICAgIChzbi50YWdOYW1lID09PSBcInNjcmlwdFwiIHx8IC8vIChtb2R1bGUpcHJlbG9hZCBsaW5rXG4gICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgKHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiB8fCBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJtb2R1bGVwcmVsb2FkXCIpIHx8IC8vIHByZWZldGNoIGxpbmtcbiAgICBzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVmZXRjaFwiICYmIHR5cGVvZiBzbi5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc24uYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJqc1wiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkRmF2aWNvbiAmJiAoc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwic2hvcnRjdXQgaWNvblwiIHx8IHNuLnRhZ05hbWUgPT09IFwibWV0YVwiICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goXG4gICAgICAvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkL1xuICAgICkgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImFwcGxpY2F0aW9uLW5hbWVcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJpY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiYXBwbGUtdG91Y2gtaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcInNob3J0Y3V0IGljb25cIikpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNuLnRhZ05hbWUgPT09IFwibWV0YVwiKSB7XG4gICAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFEZXNjS2V5d29yZHMgJiYgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eZGVzY3JpcHRpb258a2V5d29yZHMkLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eKG9nfHR3aXR0ZXJ8ZmIpOi8pIHx8IC8vIG9nID0gb3BlbmdyYXBoIChmYWNlYm9vaylcbiAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicGludGVyZXN0XCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVJvYm90cyAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInJvYm90c1wiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGVib3RcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYmluZ2JvdFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFIdHRwRXF1aXYgJiYgc24uYXR0cmlidXRlc1tcImh0dHAtZXF1aXZcIl0gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFBdXRob3JzaGlwICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXV0aG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdlbmVyYXRvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJmcmFtZXdvcmtcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHVibGlzaGVyXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInByb2dpZFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15wcm9kdWN0Oi8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFWZXJpZmljYXRpb24gJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGUtc2l0ZS12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwieWFuZGV4LXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJjc3JmLXRva2VuXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInA6ZG9tYWluX3ZlcmlmeVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZnktdjFcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInNob3BpZnktY2hlY2tvdXQtYXBpLXRva2VuXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgbWFza0FsbFRleHQsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgc2tpcENoaWxkID0gZmFsc2UsXG4gICAgaW5saW5lU3R5bGVzaGVldCA9IHRydWUsXG4gICAgbWFza0lucHV0T3B0aW9ucyA9IHt9LFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHNsaW1ET01PcHRpb25zLFxuICAgIGRhdGFVUkxPcHRpb25zID0ge30sXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcmVjb3JkQ2FudmFzID0gZmFsc2UsXG4gICAgb25TZXJpYWxpemUsXG4gICAgb25JZnJhbWVMb2FkLFxuICAgIGlmcmFtZUxvYWRUaW1lb3V0ID0gNWUzLFxuICAgIG9uQmxvY2tlZEltYWdlTG9hZCxcbiAgICBvblN0eWxlc2hlZXRMb2FkLFxuICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IDVlMyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLFxuICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB7IHByZXNlcnZlV2hpdGVTcGFjZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IF9zZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZU5vZGUobjIsIHtcbiAgICBkb2MsXG4gICAgbWlycm9yOiBtaXJyb3IyLFxuICAgIGJsb2NrQ2xhc3MsXG4gICAgYmxvY2tTZWxlY3RvcixcbiAgICBtYXNrQWxsVGV4dCxcbiAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgbWFza1RleHRDbGFzcyxcbiAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgbWFza1RleHRTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50LFxuICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgfSk7XG4gIGlmICghX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc29sZS53YXJuKG4yLCBcIm5vdCBzZXJpYWxpemVkXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBpZDtcbiAgaWYgKG1pcnJvcjIuaGFzTm9kZShuMikpIHtcbiAgICBpZCA9IG1pcnJvcjIuZ2V0SWQobjIpO1xuICB9IGVsc2UgaWYgKHNsaW1ET01FeGNsdWRlZChfc2VyaWFsaXplZE5vZGUsIHNsaW1ET01PcHRpb25zKSB8fCAhcHJlc2VydmVXaGl0ZVNwYWNlICYmIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQyLlRleHQgJiYgIV9zZXJpYWxpemVkTm9kZS5pc1N0eWxlICYmICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sIFwiXCIpLmxlbmd0aCkge1xuICAgIGlkID0gSUdOT1JFRF9OT0RFO1xuICB9IGVsc2Uge1xuICAgIGlkID0gZ2VuSWQoKTtcbiAgfVxuICBjb25zdCBzZXJpYWxpemVkTm9kZTIgPSBPYmplY3QuYXNzaWduKF9zZXJpYWxpemVkTm9kZSwgeyBpZCB9KTtcbiAgbWlycm9yMi5hZGQobjIsIHNlcmlhbGl6ZWROb2RlMik7XG4gIGlmIChpZCA9PT0gSUdOT1JFRF9OT0RFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9uU2VyaWFsaXplKSB7XG4gICAgb25TZXJpYWxpemUobjIpO1xuICB9XG4gIGxldCByZWNvcmRDaGlsZCA9ICFza2lwQ2hpbGQ7XG4gIGlmIChzZXJpYWxpemVkTm9kZTIudHlwZSA9PT0gTm9kZVR5cGUkMi5FbGVtZW50KSB7XG4gICAgcmVjb3JkQ2hpbGQgPSByZWNvcmRDaGlsZCAmJiAhc2VyaWFsaXplZE5vZGUyLm5lZWRCbG9jaztcbiAgICBjb25zdCBzaGFkb3dSb290ID0gbjIuc2hhZG93Um9vdDtcbiAgICBpZiAoc2hhZG93Um9vdCAmJiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290KSlcbiAgICAgIHNlcmlhbGl6ZWROb2RlMi5pc1NoYWRvd0hvc3QgPSB0cnVlO1xuICB9XG4gIGlmICgoc2VyaWFsaXplZE5vZGUyLnR5cGUgPT09IE5vZGVUeXBlJDIuRG9jdW1lbnQgfHwgc2VyaWFsaXplZE5vZGUyLnR5cGUgPT09IE5vZGVUeXBlJDIuRWxlbWVudCkgJiYgcmVjb3JkQ2hpbGQpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZFdoaXRlc3BhY2UgJiYgc2VyaWFsaXplZE5vZGUyLnR5cGUgPT09IE5vZGVUeXBlJDIuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZTIudGFnTmFtZSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBieXBhc3NPcHRpb25zID0ge1xuICAgICAgZG9jLFxuICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXNrQWxsVGV4dCxcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgc2tpcENoaWxkLFxuICAgICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICBtYXNrVGV4dEZuLFxuICAgICAgbWFza0lucHV0Rm4sXG4gICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgb25TZXJpYWxpemUsXG4gICAgICBvbklmcmFtZUxvYWQsXG4gICAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICAgIG9uQmxvY2tlZEltYWdlTG9hZCxcbiAgICAgIG9uU3R5bGVzaGVldExvYWQsXG4gICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gbjIuY2hpbGROb2RlcyA/IEFycmF5LmZyb20objIuY2hpbGROb2RlcykgOiBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgc2VyaWFsaXplZE5vZGUyLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudCQxKG4yKSAmJiBuMi5zaGFkb3dSb290KSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBBcnJheS5mcm9tKG4yLnNoYWRvd1Jvb3QuY2hpbGROb2RlcykpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgICBpc05hdGl2ZVNoYWRvd0RvbShuMi5zaGFkb3dSb290KSAmJiAoc2VyaWFsaXplZENoaWxkTm9kZS5pc1NoYWRvdyA9IHRydWUpO1xuICAgICAgICAgIHNlcmlhbGl6ZWROb2RlMi5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG4yLnBhcmVudE5vZGUgJiYgaXNTaGFkb3dSb290KG4yLnBhcmVudE5vZGUpICYmIGlzTmF0aXZlU2hhZG93RG9tKG4yLnBhcmVudE5vZGUpKSB7XG4gICAgc2VyaWFsaXplZE5vZGUyLmlzU2hhZG93ID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2VyaWFsaXplZE5vZGUyLnR5cGUgPT09IE5vZGVUeXBlJDIuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZTIudGFnTmFtZSA9PT0gXCJpZnJhbWVcIiAmJiAhc2VyaWFsaXplZE5vZGUyLm5lZWRCbG9jaykge1xuICAgIG9uY2VJZnJhbWVMb2FkZWQoXG4gICAgICBuMixcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gZ2V0SWZyYW1lQ29udGVudERvY3VtZW50KG4yKTtcbiAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XG4gICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIHNlcmlhbGl6ZWRJZnJhbWVOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlmcmFtZUxvYWRUaW1lb3V0XG4gICAgKTtcbiAgfVxuICBpZiAoc2VyaWFsaXplZE5vZGUyLnR5cGUgPT09IE5vZGVUeXBlJDIuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZTIudGFnTmFtZSA9PT0gXCJpbWdcIiAmJiAhbjIuY29tcGxldGUgJiYgc2VyaWFsaXplZE5vZGUyLm5lZWRCbG9jaykge1xuICAgIGNvbnN0IGltYWdlID0gbjI7XG4gICAgY29uc3QgdXBkYXRlSW1hZ2VEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKGltYWdlLmlzQ29ubmVjdGVkICYmICFpbWFnZS5jb21wbGV0ZSAmJiBvbkJsb2NrZWRJbWFnZUxvYWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWN0ID0gaW1hZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgb25CbG9ja2VkSW1hZ2VMb2FkKGltYWdlLCBzZXJpYWxpemVkTm9kZTIsIHJlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdXBkYXRlSW1hZ2VEaW1lbnNpb25zKTtcbiAgICB9O1xuICAgIGlmIChpbWFnZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdXBkYXRlSW1hZ2VEaW1lbnNpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlcmlhbGl6ZWROb2RlMi50eXBlID09PSBOb2RlVHlwZSQyLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUyLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZTIuYXR0cmlidXRlcy5yZWwgPT09IFwic3RyaW5nXCIgJiYgKHNlcmlhbGl6ZWROb2RlMi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgc2VyaWFsaXplZE5vZGUyLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUyLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZTIuYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJjc3NcIikpIHtcbiAgICBvbmNlU3R5bGVzaGVldExvYWRlZChcbiAgICAgIG4yLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5rTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZExpbmtOb2RlKSB7XG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkKFxuICAgICAgICAgICAgICBuMixcbiAgICAgICAgICAgICAgc2VyaWFsaXplZExpbmtOb2RlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dFxuICAgICk7XG4gIH1cbiAgaWYgKHNlcmlhbGl6ZWROb2RlMi50eXBlID09PSBOb2RlVHlwZSQyLkVsZW1lbnQpIHtcbiAgICBkZWxldGUgc2VyaWFsaXplZE5vZGUyLm5lZWRCbG9jaztcbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZE5vZGUyO1xufVxuZnVuY3Rpb24gc25hcHNob3QobjIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG1pcnJvcjogbWlycm9yMiA9IG5ldyBNaXJyb3IoKSxcbiAgICBibG9ja0NsYXNzID0gXCJyci1ibG9ja1wiLFxuICAgIGJsb2NrU2VsZWN0b3IgPSBudWxsLFxuICAgIHVuYmxvY2tTZWxlY3RvciA9IG51bGwsXG4gICAgbWFza0FsbFRleHQgPSBmYWxzZSxcbiAgICBtYXNrVGV4dENsYXNzID0gXCJyci1tYXNrXCIsXG4gICAgdW5tYXNrVGV4dENsYXNzID0gbnVsbCxcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIGlubGluZUltYWdlcyA9IGZhbHNlLFxuICAgIHJlY29yZENhbnZhcyA9IGZhbHNlLFxuICAgIG1hc2tBbGxJbnB1dHMgPSBmYWxzZSxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXNrSW5wdXRGbixcbiAgICBzbGltRE9NID0gZmFsc2UsXG4gICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICBvbkJsb2NrZWRJbWFnZUxvYWQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsXG4gICAgaWdub3JlQ1NTQXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgY29sb3I6IHRydWUsXG4gICAgZGF0ZTogdHJ1ZSxcbiAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgZW1haWw6IHRydWUsXG4gICAgbW9udGg6IHRydWUsXG4gICAgbnVtYmVyOiB0cnVlLFxuICAgIHJhbmdlOiB0cnVlLFxuICAgIHNlYXJjaDogdHJ1ZSxcbiAgICB0ZWw6IHRydWUsXG4gICAgdGV4dDogdHJ1ZSxcbiAgICB0aW1lOiB0cnVlLFxuICAgIHVybDogdHJ1ZSxcbiAgICB3ZWVrOiB0cnVlLFxuICAgIHRleHRhcmVhOiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZVxuICB9IDogbWFza0FsbElucHV0cyA9PT0gZmFsc2UgPyB7fSA6IG1hc2tBbGxJbnB1dHM7XG4gIGNvbnN0IHNsaW1ET01PcHRpb25zID0gc2xpbURPTSA9PT0gdHJ1ZSB8fCBzbGltRE9NID09PSBcImFsbFwiID8gKFxuICAgIC8vIGlmIHRydWU6IHNldCBvZiBzZW5zaWJsZSBvcHRpb25zIHRoYXQgc2hvdWxkIG5vdCB0aHJvdyBhd2F5IGFueSBpbmZvcm1hdGlvblxuICAgIHtcbiAgICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHNsaW1ET00gPT09IFwiYWxsXCIsXG4gICAgICAvLyBkZXN0cnVjdGl2ZVxuICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcbiAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLFxuICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWVcbiAgICB9XG4gICkgOiBzbGltRE9NID09PSBmYWxzZSA/IHt9IDogc2xpbURPTTtcbiAgcmV0dXJuIHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICBkb2M6IG4yLFxuICAgIG1pcnJvcjogbWlycm9yMixcbiAgICBibG9ja0NsYXNzLFxuICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgIG1hc2tBbGxUZXh0LFxuICAgIG1hc2tUZXh0Q2xhc3MsXG4gICAgdW5tYXNrVGV4dENsYXNzLFxuICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgdW5tYXNrVGV4dFNlbGVjdG9yLFxuICAgIHNraXBDaGlsZDogZmFsc2UsXG4gICAgaW5saW5lU3R5bGVzaGVldCxcbiAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgIG1hc2tBdHRyaWJ1dGVGbixcbiAgICBtYXNrVGV4dEZuLFxuICAgIG1hc2tJbnB1dEZuLFxuICAgIHNsaW1ET01PcHRpb25zLFxuICAgIGRhdGFVUkxPcHRpb25zLFxuICAgIGlubGluZUltYWdlcyxcbiAgICByZWNvcmRDYW52YXMsXG4gICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgIG9uU2VyaWFsaXplLFxuICAgIG9uSWZyYW1lTG9hZCxcbiAgICBpZnJhbWVMb2FkVGltZW91dCxcbiAgICBvbkJsb2NrZWRJbWFnZUxvYWQsXG4gICAgb25TdHlsZXNoZWV0TG9hZCxcbiAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAga2VlcElmcmFtZVNyY0ZuLFxuICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzXG4gIH0pO1xufVxuZnVuY3Rpb24gb24odHlwZSwgZm4sIHRhcmdldCA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfTtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xufVxuY29uc3QgREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HID0gXCJQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsXFxyXFxubm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsXFxyXFxub3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLlwiO1xubGV0IF9taXJyb3IgPSB7XG4gIG1hcDoge30sXG4gIGdldElkKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gLTE7XG4gIH0sXG4gIGdldE5vZGUoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZW1vdmVOb2RlRnJvbU1hcCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gIH0sXG4gIGhhcygpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZXNldCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gIH1cbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuUHJveHkgJiYgd2luZG93LlJlZmxlY3QpIHtcbiAgX21pcnJvciA9IG5ldyBQcm94eShfbWlycm9yLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChwcm9wID09PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUkMShmdW5jLCB3YWl0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICBsZXQgcHJldmlvdXMgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCQyKHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCQxKCgpID0+IHtcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSwgcmVtYWluaW5nKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBkLCBpc1Jldm9rZWQsIHdpbiA9IHdpbmRvdykge1xuICBjb25zdCBvcmlnaW5hbCA9IHdpbi5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICB0YXJnZXQsXG4gICAga2V5LFxuICAgIGlzUmV2b2tlZCA/IGQgOiB7XG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgc2V0VGltZW91dCQxKCgpID0+IHtcbiAgICAgICAgICBkLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcbiAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiAoKSA9PiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKCEobmFtZSBpbiBzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XG4gICAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWQsIHtcbiAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbn1cbmxldCBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcbmlmICghLyogQF9fUFVSRV9fICovIC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSB7XG4gIG5vd1RpbWVzdGFtcCA9ICgpID0+ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKHdpbikge1xuICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVhPZmZzZXQgOiBkb2M/LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYz8uYm9keT8ucGFyZW50RWxlbWVudD8uc2Nyb2xsTGVmdCB8fCBkb2M/LmJvZHk/LnNjcm9sbExlZnQgfHwgMCxcbiAgICB0b3A6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIDogd2luLnBhZ2VZT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVlPZmZzZXQgOiBkb2M/LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jPy5ib2R5Py5wYXJlbnRFbGVtZW50Py5zY3JvbGxUb3AgfHwgZG9jPy5ib2R5Py5zY3JvbGxUb3AgfHwgMFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRPZk5vZGUkMShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSA/IG5vZGUgOiBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBpc0Jsb2NrZWQobm9kZSwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZWwgPSBjbG9zZXN0RWxlbWVudE9mTm9kZSQxKG5vZGUpO1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrZWRQcmVkaWNhdGUgPSBjcmVhdGVNYXRjaFByZWRpY2F0ZShibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgaWYgKCFjaGVja0FuY2VzdG9ycykge1xuICAgIGNvbnN0IGlzVW5ibG9ja2VkID0gdW5ibG9ja1NlbGVjdG9yICYmIGVsLm1hdGNoZXModW5ibG9ja1NlbGVjdG9yKTtcbiAgICByZXR1cm4gYmxvY2tlZFByZWRpY2F0ZShlbCkgJiYgIWlzVW5ibG9ja2VkO1xuICB9XG4gIGNvbnN0IGJsb2NrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goZWwsIGJsb2NrZWRQcmVkaWNhdGUpO1xuICBsZXQgdW5ibG9ja0Rpc3RhbmNlID0gLTE7XG4gIGlmIChibG9ja0Rpc3RhbmNlIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodW5ibG9ja1NlbGVjdG9yKSB7XG4gICAgdW5ibG9ja0Rpc3RhbmNlID0gZGlzdGFuY2VUb01hdGNoKFxuICAgICAgZWwsXG4gICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZShudWxsLCB1bmJsb2NrU2VsZWN0b3IpXG4gICAgKTtcbiAgfVxuICBpZiAoYmxvY2tEaXN0YW5jZSA+IC0xICYmIHVuYmxvY2tEaXN0YW5jZSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYmxvY2tEaXN0YW5jZSA8IHVuYmxvY2tEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZChuMiwgbWlycm9yMikge1xuICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG4yLCBtaXJyb3IyKSB7XG4gIHJldHVybiBtaXJyb3IyLmdldElkKG4yKSA9PT0gSUdOT1JFRF9OT0RFO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IyKSB7XG4gIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgaWYgKCFtaXJyb3IyLmhhcyhpZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGFyZ2V0LnBhcmVudE5vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LnBhcmVudE5vZGUsIG1pcnJvcjIpO1xufVxuZnVuY3Rpb24gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkge1xuICByZXR1cm4gQm9vbGVhbihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XG59XG5mdW5jdGlvbiBwb2x5ZmlsbCQxKHdpbiA9IHdpbmRvdykge1xuICBpZiAoXCJOb2RlTGlzdFwiIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIH1cbiAgaWYgKFwiRE9NVG9rZW5MaXN0XCIgaW4gd2luICYmICF3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB9XG4gIGlmICghTm9kZS5wcm90b3R5cGUuY29udGFpbnMpIHtcbiAgICBOb2RlLnByb3RvdHlwZS5jb250YWlucyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGFyZ3NbMF07XG4gICAgICBpZiAoISgwIGluIGFyZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIxIGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChub2RlID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcjIpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbjIubm9kZU5hbWUgPT09IFwiTElOS1wiICYmIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREUgJiYgbjIuZ2V0QXR0cmlidXRlICYmIG4yLmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PT0gXCJzdHlsZXNoZWV0XCIgJiYgbWlycm9yMi5nZXRNZXRhKG4yKVxuICApO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICByZXR1cm4gQm9vbGVhbihuMj8uc2hhZG93Um9vdCk7XG59XG5jbGFzcyBTdHlsZVNoZWV0TWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IDE7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXRJZChzdHlsZXNoZWV0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkgPz8gLTE7XG4gIH1cbiAgaGFzKHN0eWxlc2hlZXQpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgSWYgdGhlIHN0eWxlc2hlZXQgaXMgaW4gdGhlIG1pcnJvciwgcmV0dXJucyB0aGUgaWQgb2YgdGhlIHN0eWxlc2hlZXQuIElmIG5vdCwgcmV0dXJuIHRoZSBuZXcgYXNzaWduZWQgaWQuXG4gICAqL1xuICBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICBpZiAodGhpcy5oYXMoc3R5bGVzaGVldCkpIHJldHVybiB0aGlzLmdldElkKHN0eWxlc2hlZXQpO1xuICAgIGxldCBuZXdJZDtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgfSBlbHNlIG5ld0lkID0gaWQ7XG4gICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgcmV0dXJuIG5ld0lkO1xuICB9XG4gIGdldFN0eWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRTdHlsZU1hcC5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZUlETWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkID0gMTtcbiAgfVxuICBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmlkKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3QobjIpIHtcbiAgbGV0IHNoYWRvd0hvc3QgPSBudWxsO1xuICBpZiAobjIuZ2V0Um9vdE5vZGU/LigpPy5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIG4yLmdldFJvb3ROb2RlKCkuaG9zdClcbiAgICBzaGFkb3dIb3N0ID0gbjIuZ2V0Um9vdE5vZGUoKS5ob3N0O1xuICByZXR1cm4gc2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4yKSB7XG4gIGxldCByb290U2hhZG93SG9zdCA9IG4yO1xuICBsZXQgc2hhZG93SG9zdDtcbiAgd2hpbGUgKHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHJvb3RTaGFkb3dIb3N0KSlcbiAgICByb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XG4gIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICBjb25zdCBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3QobjIpO1xuICByZXR1cm4gZG9jLmNvbnRhaW5zKHNoYWRvd0hvc3QpO1xufVxuZnVuY3Rpb24gaW5Eb20objIpIHtcbiAgY29uc3QgZG9jID0gbjIub3duZXJEb2N1bWVudDtcbiAgaWYgKCFkb2MpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGRvYy5jb250YWlucyhuMikgfHwgc2hhZG93SG9zdEluRG9tKG4yKTtcbn1cbmNvbnN0IGNhY2hlZEltcGxlbWVudGF0aW9ucyA9IHt9O1xuZnVuY3Rpb24gZ2V0SW1wbGVtZW50YXRpb24obmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZWRJbXBsZW1lbnRhdGlvbnNbbmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IGRvY3VtZW50MiA9IHdpbmRvdy5kb2N1bWVudDtcbiAgbGV0IGltcGwgPSB3aW5kb3dbbmFtZV07XG4gIGlmIChkb2N1bWVudDIgJiYgdHlwZW9mIGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2FuZGJveCA9IGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgc2FuZGJveC5oaWRkZW4gPSB0cnVlO1xuICAgICAgZG9jdW1lbnQyLmhlYWQuYXBwZW5kQ2hpbGQoc2FuZGJveCk7XG4gICAgICBjb25zdCBjb250ZW50V2luZG93ID0gc2FuZGJveC5jb250ZW50V2luZG93O1xuICAgICAgaWYgKGNvbnRlbnRXaW5kb3cgJiYgY29udGVudFdpbmRvd1tuYW1lXSkge1xuICAgICAgICBpbXBsID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICBjb250ZW50V2luZG93W25hbWVdO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQyLmhlYWQucmVtb3ZlQ2hpbGQoc2FuZGJveCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXSA9IGltcGwuYmluZChcbiAgICB3aW5kb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpKC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gc2V0VGltZW91dCQxKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwic2V0VGltZW91dFwiKSguLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dCQyKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwiY2xlYXJUaW1lb3V0XCIpKC4uLnJlc3QpO1xufVxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKE1vdXNlSW50ZXJhY3Rpb25zMikgPT4ge1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDbGlja1wiXSA9IDJdID0gXCJDbGlja1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJGb2N1c1wiXSA9IDVdID0gXCJGb2N1c1wiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoTW92ZV9EZXBhcnRlZFwiXSA9IDhdID0gXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgcmV0dXJuIE1vdXNlSW50ZXJhY3Rpb25zMjtcbn0pKE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gKChQb2ludGVyVHlwZXMyKSA9PiB7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiVG91Y2hcIl0gPSAyXSA9IFwiVG91Y2hcIjtcbiAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIE1lZGlhSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTWVkaWFJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQbGF5XCJdID0gMF0gPSBcIlBsYXlcIjtcbiAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJTZWVrZWRcIl0gPSAyXSA9IFwiU2Vla2VkXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJWb2x1bWVDaGFuZ2VcIl0gPSAzXSA9IFwiVm9sdW1lQ2hhbmdlXCI7XG4gIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgcmV0dXJuIE1lZGlhSW50ZXJhY3Rpb25zMjtcbn0pKE1lZGlhSW50ZXJhY3Rpb25zIHx8IHt9KTtcbmZ1bmN0aW9uIGdldElGcmFtZUNvbnRlbnREb2N1bWVudChpZnJhbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgfSBjYXRjaCAoZTIpIHtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SUZyYW1lQ29udGVudFdpbmRvdyhpZnJhbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gIH0gY2F0Y2ggKGUyKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTm9kZUluTGlua2VkTGlzdChuMikge1xuICByZXR1cm4gXCJfX2xuXCIgaW4gbjI7XG59XG5jbGFzcyBEb3VibGVMaW5rZWRMaXN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuICBnZXQocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZVwiKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBvc2l0aW9uOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudD8ubmV4dCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBhZGROb2RlKG4yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHZhbHVlOiBuMixcbiAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbjIuX19sbiA9IG5vZGU7XG4gICAgaWYgKG4yLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3QobjIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgY29uc3QgY3VycmVudCA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQ7XG4gICAgICBub2RlLm5leHQgPSBjdXJyZW50O1xuICAgICAgbm9kZS5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGU7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4yLm5leHRTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5uZXh0U2libGluZykgJiYgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xuICAgICAgY29uc3QgY3VycmVudCA9IG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXM7XG4gICAgICBub2RlLnByZXZpb3VzID0gY3VycmVudDtcbiAgICAgIG5vZGUubmV4dCA9IG4yLm5leHRTaWJsaW5nLl9fbG47XG4gICAgICBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzID0gbm9kZTtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQubmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoKys7XG4gIH1cbiAgcmVtb3ZlTm9kZShuMikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBuMi5fX2xuO1xuICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5wcmV2aW91cykge1xuICAgICAgdGhpcy5oZWFkID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xuICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YWlsID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4yLl9fbG4pIHtcbiAgICAgIGRlbGV0ZSBuMi5fX2xuO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aC0tO1xuICB9XG59XG5jb25zdCBtb3ZlS2V5ID0gKGlkLCBwYXJlbnRJZCkgPT4gYCR7aWR9QCR7cGFyZW50SWR9YDtcbmNsYXNzIE11dGF0aW9uQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMudGV4dHMgPSBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMucmVtb3ZlcyA9IFtdO1xuICAgIHRoaXMubWFwUmVtb3ZlcyA9IFtdO1xuICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICB0aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLm1vdmVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmRyb3BwZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMucHJvY2Vzc011dGF0aW9ucyA9IChtdXRhdGlvbnMpID0+IHtcbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKHRoaXMucHJvY2Vzc011dGF0aW9uKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5lbWl0ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFkZHMgPSBbXTtcbiAgICAgIGNvbnN0IGFkZGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGFkZExpc3QgPSBuZXcgRG91YmxlTGlua2VkTGlzdCgpO1xuICAgICAgY29uc3QgZ2V0TmV4dElkID0gKG4yKSA9PiB7XG4gICAgICAgIGxldCBucyA9IG4yO1xuICAgICAgICBsZXQgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xuICAgICAgICB3aGlsZSAobmV4dElkID09PSBJR05PUkVEX05PREUpIHtcbiAgICAgICAgICBucyA9IG5zICYmIG5zLm5leHRTaWJsaW5nO1xuICAgICAgICAgIG5leHRJZCA9IG5zICYmIHRoaXMubWlycm9yLmdldElkKG5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dElkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHB1c2hBZGQgPSAobjIpID0+IHtcbiAgICAgICAgaWYgKCFuMi5wYXJlbnROb2RlIHx8ICFpbkRvbShuMikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QobjIucGFyZW50Tm9kZSkgPyB0aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4yKSkgOiB0aGlzLm1pcnJvci5nZXRJZChuMi5wYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgZG9jOiB0aGlzLmRvYyxcbiAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICAgIGJsb2NrQ2xhc3M6IHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yOiB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgbWFza0FsbFRleHQ6IHRoaXMubWFza0FsbFRleHQsXG4gICAgICAgICAgdW5ibG9ja1NlbGVjdG9yOiB0aGlzLnVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICBtYXNrVGV4dENsYXNzOiB0aGlzLm1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgdW5tYXNrVGV4dENsYXNzOiB0aGlzLnVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiB0aGlzLm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgdW5tYXNrVGV4dFNlbGVjdG9yOiB0aGlzLnVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICBtYXNrQXR0cmlidXRlRm46IHRoaXMubWFza0F0dHJpYnV0ZUZuLFxuICAgICAgICAgIG1hc2tUZXh0Rm46IHRoaXMubWFza1RleHRGbixcbiAgICAgICAgICBtYXNrSW5wdXRGbjogdGhpcy5tYXNrSW5wdXRGbixcbiAgICAgICAgICBzbGltRE9NT3B0aW9uczogdGhpcy5zbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICBkYXRhVVJMT3B0aW9uczogdGhpcy5kYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICByZWNvcmRDYW52YXM6IHRoaXMucmVjb3JkQ2FudmFzLFxuICAgICAgICAgIGlubGluZUltYWdlczogdGhpcy5pbmxpbmVJbWFnZXMsXG4gICAgICAgICAgb25TZXJpYWxpemU6IChjdXJyZW50TikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShjdXJyZW50TiwgdGhpcy5taXJyb3IpICYmICFpc0Jsb2NrZWQoXG4gICAgICAgICAgICAgIGN1cnJlbnROLFxuICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIHRoaXMuaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUoY3VycmVudE4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQoY3VycmVudE4sIHRoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQoXG4gICAgICAgICAgICAgICAgY3VycmVudE5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuMi5zaGFkb3dSb290LCB0aGlzLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQoXG4gICAgICAgICAgICAgIGlmcmFtZSxcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgICB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIHRoaXMudW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XG4gICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmFkZFdpbmRvdyhpZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogKGxpbmssIGNoaWxkU24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGluaywgY2hpbGRTbik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJsb2NrZWRJbWFnZUxvYWQ6IChfaW1hZ2VFbCwgc2VyaWFsaXplZE5vZGUsIHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgICBhZGRzOiBbXSxcbiAgICAgICAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBzZXJpYWxpemVkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXM6IHRoaXMuaWdub3JlQ1NTQXR0cmlidXRlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNuKSB7XG4gICAgICAgICAgYWRkcy5wdXNoKHtcbiAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgbmV4dElkLFxuICAgICAgICAgICAgbm9kZTogc25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhZGRlZElkcy5hZGQoc24uaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2hpbGUgKHRoaXMubWFwUmVtb3Zlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAodGhpcy5tYXBSZW1vdmVzLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuMiBvZiB0aGlzLm1vdmVkU2V0KSB7XG4gICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuMiwgdGhpcy5taXJyb3IpICYmICF0aGlzLm1vdmVkU2V0LmhhcyhuMi5wYXJlbnROb2RlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuMiBvZiB0aGlzLmFkZGVkU2V0KSB7XG4gICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KHRoaXMuZHJvcHBlZFNldCwgbjIpICYmICFpc1BhcmVudFJlbW92ZWQodGhpcy5yZW1vdmVzLCBuMiwgdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgcHVzaEFkZChuMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KHRoaXMubW92ZWRTZXQsIG4yKSkge1xuICAgICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZHJvcHBlZFNldC5hZGQobjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHdoaWxlIChhZGRMaXN0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IHRoaXMubWlycm9yLmdldElkKGNhbmRpZGF0ZS52YWx1ZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoY2FuZGlkYXRlLnZhbHVlKTtcbiAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIGxldCB0YWlsTm9kZSA9IGFkZExpc3QudGFpbDtcbiAgICAgICAgICB3aGlsZSAodGFpbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IF9ub2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKF9ub2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoX25vZGUudmFsdWUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IGdldE5leHRJZChfbm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChuZXh0SWQgPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlICYmIHVuaGFuZGxlZE5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGFkb3dIb3N0ID0gdW5oYW5kbGVkTm9kZS5wYXJlbnROb2RlLmhvc3Q7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZDIgPSB0aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHdoaWxlIChhZGRMaXN0LmhlYWQpIHtcbiAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShhZGRMaXN0LmhlYWQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGUgPSBub2RlLnByZXZpb3VzO1xuICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUobm9kZS52YWx1ZSk7XG4gICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0ZXh0czogdGhpcy50ZXh0cy5tYXAoKHRleHQpID0+ICh7XG4gICAgICAgICAgaWQ6IHRoaXMubWlycm9yLmdldElkKHRleHQubm9kZSksXG4gICAgICAgICAgdmFsdWU6IHRleHQudmFsdWVcbiAgICAgICAgfSkpLmZpbHRlcigodGV4dCkgPT4gIWFkZGVkSWRzLmhhcyh0ZXh0LmlkKSkuZmlsdGVyKCh0ZXh0KSA9PiB0aGlzLm1pcnJvci5oYXModGV4dC5pZCkpLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5zdHlsZURpZmYpO1xuICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuX3VuY2hhbmdlZFN0eWxlcyk7XG4gICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgoZGlmZkFzU3RyICsgdW5jaGFuZ2VkQXNTdHIpLnNwbGl0KFwidmFyKFwiKS5sZW5ndGggPT09IGF0dHJpYnV0ZXMuc3R5bGUuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBhdHRyaWJ1dGUuc3R5bGVEaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQoYXR0cmlidXRlLm5vZGUpLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcigoYXR0cmlidXRlKSA9PiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCkpLmZpbHRlcigoYXR0cmlidXRlKSA9PiB0aGlzLm1pcnJvci5oYXMoYXR0cmlidXRlLmlkKSksXG4gICAgICAgIHJlbW92ZXM6IHRoaXMucmVtb3ZlcyxcbiAgICAgICAgYWRkc1xuICAgICAgfTtcbiAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiYgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiYgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiYgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0cyA9IFtdO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICB0aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5yZW1vdmVzID0gW107XG4gICAgICB0aGlzLmFkZGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5kcm9wcGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgIHRoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcbiAgICB9O1xuICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKG0pID0+IHtcbiAgICAgIGlmIChpc0lnbm9yZWQobS50YXJnZXQsIHRoaXMubWlycm9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG0udHlwZSkge1xuICAgICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBtLnRhcmdldC50ZXh0Q29udGVudDtcbiAgICAgICAgICBpZiAoIWlzQmxvY2tlZChcbiAgICAgICAgICAgIG0udGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkgJiYgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQoXG4gICAgICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgIHRoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0aGlzLnVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICB0aGlzLnVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tBbGxUZXh0XG4gICAgICAgICAgICAgICkgJiYgdmFsdWUgPyB0aGlzLm1hc2tUZXh0Rm4gPyB0aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlJDEobS50YXJnZXQpKSA6IHZhbHVlLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKSA6IHZhbHVlLFxuICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzXCI6IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBtLnRhcmdldDtcbiAgICAgICAgICBsZXQgYXR0cmlidXRlTmFtZSA9IG0uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lO1xuICAgICAgICAgICAgdmFsdWUgPSBnZXRJbnB1dFZhbHVlKHRhcmdldCwgdGFnTmFtZSwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBpc0lucHV0TWFza2VkID0gc2hvdWxkTWFza0lucHV0KHtcbiAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICB0YWdOYW1lLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlTWFzayA9IG5lZWRNYXNraW5nVGV4dChcbiAgICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICAgIHRoaXMubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICB0aGlzLnVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgdGhpcy51bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICAgIGlzSW5wdXRNYXNrZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgaXNNYXNrZWQ6IGZvcmNlTWFzayxcbiAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNCbG9ja2VkKFxuICAgICAgICAgICAgbS50YXJnZXQsXG4gICAgICAgICAgICB0aGlzLmJsb2NrQ2xhc3MsXG4gICAgICAgICAgICB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLnVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSB8fCB2YWx1ZSA9PT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XG4gICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSBcIklGUkFNRVwiICYmIGF0dHJpYnV0ZU5hbWUgPT09IFwic3JjXCIgJiYgIXRoaXMua2VlcElmcmFtZVNyY0ZuKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgaWZyYW1lRG9jID0gZ2V0SUZyYW1lQ29udGVudERvY3VtZW50KFxuICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWlmcmFtZURvYykge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJycl9zcmNcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXG4gICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcC5zZXQobS50YXJnZXQsIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ0eXBlXCIgJiYgdGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiAobS5vbGRWYWx1ZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJyLWlzLXBhc3N3b3JkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFyZ2V0LnRhZ05hbWUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIHRoaXMuZG9jLFxuICAgICAgICAgICAgICB0b0xvd2VyQ2FzZSh0YXJnZXQudGFnTmFtZSksXG4gICAgICAgICAgICAgIHRvTG93ZXJDYXNlKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICB0aGlzLm1hc2tBdHRyaWJ1dGVGblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnVuYXR0YWNoZWREb2MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhpcy51bmF0dGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9IHRoaXMuZG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLnVuYXR0YWNoZWREb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgIGlmIChtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2xkLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIG0ub2xkVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbSh0YXJnZXQuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJpb3JpdHkgPSB0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgfHwgbmV3UHJpb3JpdHkgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld1ByaW9yaXR5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGVEaWZmW3BuYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW25ld1ZhbHVlLCBuZXdQcmlvcml0eV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0uX3VuY2hhbmdlZFN0eWxlc1twbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwbmFtZSBvZiBBcnJheS5mcm9tKG9sZC5zdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNoaWxkTGlzdFwiOiB7XG4gICAgICAgICAgaWYgKGlzQmxvY2tlZChcbiAgICAgICAgICAgIG0udGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy51bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtLmFkZGVkTm9kZXMuZm9yRWFjaCgobjIpID0+IHRoaXMuZ2VuQWRkcyhuMiwgbS50YXJnZXQpKTtcbiAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy5taXJyb3IuZ2V0SWQobjIpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QobS50YXJnZXQpID8gdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQuaG9zdCkgOiB0aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKFxuICAgICAgICAgICAgICBtLnRhcmdldCxcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgICB0aGlzLmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIHRoaXMudW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKSB8fCBpc0lnbm9yZWQobjIsIHRoaXMubWlycm9yKSB8fCAhaXNTZXJpYWxpemVkKG4yLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4yKSkge1xuICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMuYWRkZWRTZXQsIG4yKTtcbiAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG0udGFyZ2V0KSAmJiBub2RlSWQgPT09IC0xKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgdGhpcy5taXJyb3IpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1vdmVkU2V0LmhhcyhuMikgJiYgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KG5vZGVJZCwgcGFyZW50SWQpXSkge1xuICAgICAgICAgICAgICBkZWVwRGVsZXRlKHRoaXMubW92ZWRTZXQsIG4yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlzU2hhZG93OiBpc1NoYWRvd1Jvb3QobS50YXJnZXQpICYmIGlzTmF0aXZlU2hhZG93RG9tKG0udGFyZ2V0KSA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcFJlbW92ZXMucHVzaChuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2VuQWRkcyA9IChuMiwgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5pbk90aGVyQnVmZmVyKG4yLCB0aGlzKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4yKSB8fCB0aGlzLm1vdmVkU2V0LmhhcyhuMikpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLm1pcnJvci5oYXNOb2RlKG4yKSkge1xuICAgICAgICBpZiAoaXNJZ25vcmVkKG4yLCB0aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlZFNldC5hZGQobjIpO1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHRoaXMubWlycm9yLmhhc05vZGUodGFyZ2V0KSkge1xuICAgICAgICAgIHRhcmdldElkID0gdGhpcy5taXJyb3IuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KHRoaXMubWlycm9yLmdldElkKG4yKSwgdGFyZ2V0SWQpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmRlbGV0ZShuMik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQmxvY2tlZChcbiAgICAgICAgbjIsXG4gICAgICAgIHRoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICB0aGlzLnVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgZmFsc2VcbiAgICAgICkpIHtcbiAgICAgICAgaWYgKG4yLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICBuMi5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTikgPT4gdGhpcy5nZW5BZGRzKGNoaWxkTikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIG4yLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuYWRkKGNoaWxkTiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmdlbkFkZHMoY2hpbGROLCBuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIFtcbiAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgIFwidW5ibG9ja1NlbGVjdG9yXCIsXG4gICAgICBcIm1hc2tBbGxUZXh0XCIsXG4gICAgICBcIm1hc2tUZXh0Q2xhc3NcIixcbiAgICAgIFwidW5tYXNrVGV4dENsYXNzXCIsXG4gICAgICBcIm1hc2tUZXh0U2VsZWN0b3JcIixcbiAgICAgIFwidW5tYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgXCJtYXNrQXR0cmlidXRlRm5cIixcbiAgICAgIFwibWFza1RleHRGblwiLFxuICAgICAgXCJtYXNrSW5wdXRGblwiLFxuICAgICAgXCJrZWVwSWZyYW1lU3JjRm5cIixcbiAgICAgIFwicmVjb3JkQ2FudmFzXCIsXG4gICAgICBcImlubGluZUltYWdlc1wiLFxuICAgICAgXCJzbGltRE9NT3B0aW9uc1wiLFxuICAgICAgXCJkYXRhVVJMT3B0aW9uc1wiLFxuICAgICAgXCJkb2NcIixcbiAgICAgIFwibWlycm9yXCIsXG4gICAgICBcImlmcmFtZU1hbmFnZXJcIixcbiAgICAgIFwic3R5bGVzaGVldE1hbmFnZXJcIixcbiAgICAgIFwic2hhZG93RG9tTWFuYWdlclwiLFxuICAgICAgXCJjYW52YXNNYW5hZ2VyXCIsXG4gICAgICBcInByb2Nlc3NlZE5vZGVNYW5hZ2VyXCIsXG4gICAgICBcImlnbm9yZUNTU0F0dHJpYnV0ZXNcIlxuICAgIF0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfSk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIuZnJlZXplKCk7XG4gIH1cbiAgdW5mcmVlemUoKSB7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5mcmVlemUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBpc0Zyb3plbigpIHtcbiAgICByZXR1cm4gdGhpcy5mcm96ZW47XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcbiAgfVxuICB1bmxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5sb2NrKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XG4gICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbjIpIHtcbiAgYWRkc1NldC5kZWxldGUobjIpO1xuICBuMi5jaGlsZE5vZGVzPy5mb3JFYWNoKChjaGlsZE4pID0+IGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKSk7XG59XG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgaWYgKHJlbW92ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBtaXJyb3IyKTtcbn1cbmZ1bmN0aW9uIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgbGV0IG5vZGUgPSBuMi5wYXJlbnROb2RlO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IHBhcmVudElkID0gbWlycm9yMi5nZXRJZChub2RlKTtcbiAgICBpZiAocmVtb3Zlcy5zb21lKChyMikgPT4gcjIuaWQgPT09IHBhcmVudElkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgaWYgKHNldC5zaXplID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpO1xufVxuZnVuY3Rpb24gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKSB7XG4gIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gbjI7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc2V0LmhhcyhwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XG59XG5sZXQgZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckVycm9ySGFuZGxlcigpIHtcbiAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxuY29uc3QgY2FsbGJhY2tXcmFwcGVyID0gKGNiKSA9PiB7XG4gIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGNiO1xuICB9XG4gIGNvbnN0IHJyd2ViV3JhcHBlZCA9ICguLi5yZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYiguLi5yZXN0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBycndlYldyYXBwZWQ7XG59O1xuY29uc3QgbXV0YXRpb25CdWZmZXJzID0gW107XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICB0cnkge1xuICAgIGlmIChcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50KSB7XG4gICAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInBhdGhcIiBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnBhdGhbMF07XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XG4gIGNvbnN0IG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XG4gIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcbiAgbXV0YXRpb25CdWZmZXIuaW5pdChvcHRpb25zKTtcbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgLyoqXG4gICogU29tZSB3ZWJzaXRlcyBtYXkgZGlzYWJsZSBNdXRhdGlvbk9ic2VydmVyIGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICogSWYgc29tZW9uZSBpcyB1c2luZyBycndlYiB0byBidWlsZCBhIGJyb3dzZXIgZXh0ZW50aW9uIG9yIHRoaW5ncyBsaWtlIGl0LCB0aGV5XG4gICogY291bGQgbm90IGNoYW5nZSB0aGUgd2Vic2l0ZSdzIGNvZGUgYnV0IGNhbiBoYXZlIGFuIG9wcG9ydHVuaXR5IHRvIGluamVjdCBzb21lXG4gICogY29kZSBiZWZvcmUgdGhlIHdlYnNpdGUgZXhlY3V0aW5nIGl0cyBKUyBsb2dpYy5cbiAgKiBUaGVuIHRoZXkgY2FuIGRvIHRoaXMgdG8gc3RvcmUgdGhlIG5hdGl2ZSBNdXRhdGlvbk9ic2VydmVyOlxuICAqIHdpbmRvdy5fX3JyTXV0YXRpb25PYnNlcnZlciA9IE11dGF0aW9uT2JzZXJ2ZXJcbiAgKi9cbiAgd2luZG93Ll9fcnJNdXRhdGlvbk9ic2VydmVyO1xuICBjb25zdCBhbmd1bGFyWm9uZVN5bWJvbCA9IHdpbmRvdz8uWm9uZT8uX19zeW1ib2xfXz8uKFwiTXV0YXRpb25PYnNlcnZlclwiKTtcbiAgaWYgKGFuZ3VsYXJab25lU3ltYm9sICYmIHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF0pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvd1thbmd1bGFyWm9uZVN5bWJvbF07XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgbXV0YXRpb25PYnNlcnZlckN0b3IoXG4gICAgY2FsbGJhY2tXcmFwcGVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLm9uTXV0YXRpb24gJiYgb3B0aW9ucy5vbk11dGF0aW9uKG11dGF0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikobXV0YXRpb25zKTtcbiAgICB9KVxuICApO1xuICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbCwge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIoe1xuICBtb3VzZW1vdmVDYixcbiAgc2FtcGxpbmcsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyXG59KSB7XG4gIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcbiAgY29uc3QgY2FsbGJhY2tUaHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA6IDUwMDtcbiAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICBsZXQgdGltZUJhc2VsaW5lO1xuICBjb25zdCB3cmFwcGVkQ2IgPSB0aHJvdHRsZSQxKFxuICAgIGNhbGxiYWNrV3JhcHBlcihcbiAgICAgIChzb3VyY2UpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xuICAgICAgICBtb3VzZW1vdmVDYihcbiAgICAgICAgICBwb3NpdGlvbnMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzb3VyY2VcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb25zID0gW107XG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XG4gICAgICB9XG4gICAgKSxcbiAgICBjYWxsYmFja1RocmVzaG9sZFxuICApO1xuICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICB0aHJvdHRsZSQxKFxuICAgICAgY2FsbGJhY2tXcmFwcGVyKChldnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dCkgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldnQ7XG4gICAgICAgIGlmICghdGltZUJhc2VsaW5lKSB7XG4gICAgICAgICAgdGltZUJhc2VsaW5lID0gbm93VGltZXN0YW1wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2goe1xuICAgICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgICBpZDogbWlycm9yMi5nZXRJZCh0YXJnZXQpLFxuICAgICAgICAgIHRpbWVPZmZzZXQ6IG5vd1RpbWVzdGFtcCgpIC0gdGltZUJhc2VsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwcGVkQ2IoXG4gICAgICAgICAgdHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldnQgaW5zdGFuY2VvZiBEcmFnRXZlbnQgPyBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSA6IEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZVxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICB7XG4gICAgICAgIHRyYWlsaW5nOiBmYWxzZVxuICAgICAgfVxuICAgIClcbiAgKTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgb24oXCJtb3VzZW1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgb24oXCJ0b3VjaG1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgb24oXCJkcmFnXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpXG4gIF07XG4gIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1vdXNlSW50ZXJhY3Rpb25DYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHVuYmxvY2tTZWxlY3RvcixcbiAgc2FtcGxpbmdcbn0pIHtcbiAgaWYgKHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHZvaWQgMCA/IHt9IDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgbGV0IGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gIGNvbnN0IGdldEhhbmRsZXIgPSAoZXZlbnRLZXkpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgbGV0IHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Ub3VjaCkge1xuICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XG4gICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgIGlmICghZTIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGUyO1xuICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoe1xuICAgICAgICB0eXBlOiBNb3VzZUludGVyYWN0aW9uc1t0aGlzRXZlbnRLZXldLFxuICAgICAgICBpZCxcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgLi4ucG9pbnRlclR5cGUgIT09IG51bGwgJiYgeyBwb2ludGVyVHlwZSB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKFxuICAgIChrZXkpID0+IE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiYgIWtleS5lbmRzV2l0aChcIl9EZXBhcnRlZFwiKSAmJiBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlXG4gICkuZm9yRWFjaCgoZXZlbnRLZXkpID0+IHtcbiAgICBsZXQgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgc3dpdGNoIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pIHtcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcbiAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcbiAgICAgICAgICAgIFwibW91c2VcIixcbiAgICAgICAgICAgIFwicG9pbnRlclwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICBzY3JvbGxDYixcbiAgZG9jLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGJsb2NrQ2xhc3MsXG4gIGJsb2NrU2VsZWN0b3IsXG4gIHVuYmxvY2tTZWxlY3RvcixcbiAgc2FtcGxpbmdcbn0pIHtcbiAgY29uc3QgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZChcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXG4gICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbENiKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc2FtcGxpbmcuc2Nyb2xsIHx8IDEwMFxuICAgIClcbiAgKTtcbiAgcmV0dXJuIG9uKFwic2Nyb2xsXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xufVxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoeyB2aWV3cG9ydFJlc2l6ZUNiIH0sIHsgd2luIH0pIHtcbiAgbGV0IGxhc3RIID0gLTE7XG4gIGxldCBsYXN0VyA9IC0xO1xuICBjb25zdCB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIoXG4gICAgdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xuICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2Ioe1xuICAgICAgICAgICAgd2lkdGg6IE51bWJlcih3aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihoZWlnaHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdEggPSBoZWlnaHQ7XG4gICAgICAgICAgbGFzdFcgPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAyMDBcbiAgICApXG4gICk7XG4gIHJldHVybiBvbihcInJlc2l6ZVwiLCB1cGRhdGVEaW1lbnNpb24sIHdpbik7XG59XG5jb25zdCBJTlBVVF9UQUdTID0gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXTtcbmNvbnN0IGxhc3RJbnB1dFZhbHVlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBpbml0SW5wdXRPYnNlcnZlcih7XG4gIGlucHV0Q2IsXG4gIGRvYyxcbiAgbWlycm9yOiBtaXJyb3IyLFxuICBibG9ja0NsYXNzLFxuICBibG9ja1NlbGVjdG9yLFxuICB1bmJsb2NrU2VsZWN0b3IsXG4gIGlnbm9yZUNsYXNzLFxuICBpZ25vcmVTZWxlY3RvcixcbiAgbWFza0lucHV0T3B0aW9ucyxcbiAgbWFza0lucHV0Rm4sXG4gIHNhbXBsaW5nLFxuICB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcbiAgbWFza1RleHRDbGFzcyxcbiAgdW5tYXNrVGV4dENsYXNzLFxuICBtYXNrVGV4dFNlbGVjdG9yLFxuICB1bm1hc2tUZXh0U2VsZWN0b3Jcbn0pIHtcbiAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBjb25zdCB1c2VyVHJpZ2dlcmVkID0gZXZlbnQuaXNUcnVzdGVkO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YXJnZXQgJiYgdG9VcHBlckNhc2UodGFyZ2V0LnRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lID09PSBcIk9QVElPTlwiKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZChcbiAgICAgIHRhcmdldCxcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgdHJ1ZVxuICAgICkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWwgPSB0YXJnZXQ7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykgfHwgaWdub3JlU2VsZWN0b3IgJiYgZWwubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpO1xuICAgIGxldCB0ZXh0ID0gZ2V0SW5wdXRWYWx1ZShlbCwgdGFnTmFtZSwgdHlwZSk7XG4gICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlzSW5wdXRNYXNrZWQgPSBzaG91bGRNYXNrSW5wdXQoe1xuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIHRhZ05hbWUsXG4gICAgICB0eXBlXG4gICAgfSk7XG4gICAgY29uc3QgZm9yY2VNYXNrID0gbmVlZE1hc2tpbmdUZXh0KFxuICAgICAgdGFyZ2V0LFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICB1bm1hc2tUZXh0Q2xhc3MsXG4gICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBpc0lucHV0TWFza2VkXG4gICAgKTtcbiAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgfVxuICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICBpc01hc2tlZDogZm9yY2VNYXNrLFxuICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBtYXNrSW5wdXRGblxuICAgIH0pO1xuICAgIGNiV2l0aERlZHVwKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7IHRleHQsIGlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZCB9IDogeyB0ZXh0LCBpc0NoZWNrZWQgfVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7bmFtZX1cIl1gKS5mb3JFYWNoKChlbDIpID0+IHtcbiAgICAgICAgaWYgKGVsMiAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgdGV4dDIgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAvLyBzaGFyZSBtYXNrIGJlaGF2aW9yIG9mIGB0YXJnZXRgXG4gICAgICAgICAgICBpc01hc2tlZDogZm9yY2VNYXNrLFxuICAgICAgICAgICAgZWxlbWVudDogZWwyLFxuICAgICAgICAgICAgdmFsdWU6IGdldElucHV0VmFsdWUoZWwyLCB0YWdOYW1lLCB0eXBlKSxcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2JXaXRoRGVkdXAoXG4gICAgICAgICAgICBlbDIsXG4gICAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCA/IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZDogZmFsc2UgfSA6IHsgdGV4dDogdGV4dDIsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNiV2l0aERlZHVwKHRhcmdldCwgdjIpIHtcbiAgICBjb25zdCBsYXN0SW5wdXRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlTWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghbGFzdElucHV0VmFsdWUgfHwgbGFzdElucHV0VmFsdWUudGV4dCAhPT0gdjIudGV4dCB8fCBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYyLmlzQ2hlY2tlZCkge1xuICAgICAgbGFzdElucHV0VmFsdWVNYXAuc2V0KHRhcmdldCwgdjIpO1xuICAgICAgY29uc3QgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoe1xuICAgICAgICAuLi52MixcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudHMgPSBzYW1wbGluZy5pbnB1dCA9PT0gXCJsYXN0XCIgPyBbXCJjaGFuZ2VcIl0gOiBbXCJpbnB1dFwiLCBcImNoYW5nZVwiXTtcbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMubWFwKFxuICAgIChldmVudE5hbWUpID0+IG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYylcbiAgKTtcbiAgY29uc3QgY3VycmVudFdpbmRvdyA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3IgPSBjdXJyZW50V2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICBcInZhbHVlXCJcbiAgKTtcbiAgY29uc3QgaG9va1Byb3BlcnRpZXMgPSBbXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsIFwiY2hlY2tlZFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgW2N1cnJlbnRXaW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudC5wcm90b3R5cGUsIFwidmFsdWVcIl0sXG4gICAgLy8gU29tZSBVSSBsaWJyYXJ5IHVzZSBzZWxlY3RlZEluZGV4IHRvIHNldCBzZWxlY3QgdmFsdWVcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiXSxcbiAgICBbY3VycmVudFdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIl1cbiAgXTtcbiAgaWYgKHByb3BlcnR5RGVzY3JpcHRvciAmJiBwcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSB7XG4gICAgaGFuZGxlcnMucHVzaChcbiAgICAgIC4uLmhvb2tQcm9wZXJ0aWVzLm1hcChcbiAgICAgICAgKHApID0+IGhvb2tTZXR0ZXIoXG4gICAgICAgICAgcFswXSxcbiAgICAgICAgICBwWzFdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gdXNlclRyaWdnZXJlZCB0byBmYWxzZSBhcyB0aGlzIGNvdWxkIHdlbGwgYmUgcHJvZ3JhbW1hdGljXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgY3VycmVudFdpbmRvd1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnMocnVsZSkge1xuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgZnVuY3Rpb24gcmVjdXJzZShjaGlsZFJ1bGUsIHBvcykge1xuICAgIGlmIChoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpICYmIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikgJiYgY2hpbGRSdWxlLnBhcmVudFJ1bGUgaW5zdGFuY2VvZiBDU1NNZWRpYVJ1bGUgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU1N1cHBvcnRzUnVsZSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSAmJiBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oXG4gICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaW5kZXggPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQpIHtcbiAgICAgIGNvbnN0IHJ1bGVzMiA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xuICAgICAgY29uc3QgaW5kZXggPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgcG9zLnVuc2hpZnQoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIHJldHVybiByZWN1cnNlKHJ1bGUsIHBvc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRJZEFuZFN0eWxlSWQoc2hlZXQsIG1pcnJvcjIsIHN0eWxlTWlycm9yKSB7XG4gIGxldCBpZCwgc3R5bGVJZDtcbiAgaWYgKCFzaGVldCkgcmV0dXJuIHt9O1xuICBpZiAoc2hlZXQub3duZXJOb2RlKSBpZCA9IG1pcnJvcjIuZ2V0SWQoc2hlZXQub3duZXJOb2RlKTtcbiAgZWxzZSBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICByZXR1cm4ge1xuICAgIHN0eWxlSWQsXG4gICAgaWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGluaXRTdHlsZVNoZWV0T2JzZXJ2ZXIoeyBzdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3I6IG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyIH0sIHsgd2luIH0pIHtcbiAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoaW5zZXJ0UnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgYWRkczogW3sgcnVsZSwgaW5kZXggfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIGNvbnN0IGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcbiAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xuICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoXG4gICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IFtpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXggfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgfVxuICAgIClcbiAgfSk7XG4gIGxldCByZXBsYWNlO1xuICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UpIHtcbiAgICByZXBsYWNlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2U7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSBuZXcgUHJveHkocmVwbGFjZSwge1xuICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlcGxhY2VTeW5jO1xuICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jKSB7XG4gICAgcmVwbGFjZVN5bmMgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmM7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gbmV3IFByb3h5KHJlcGxhY2VTeW5jLCB7XG4gICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3RleHRdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoXG4gICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgbWlycm9yMixcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgcmVwbGFjZVN5bmM6IHRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XG4gIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NHcm91cGluZ1J1bGVcIikpIHtcbiAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpKSB7XG4gICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcbiAgICB9XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0NvbmRpdGlvblJ1bGVcIikpIHtcbiAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NDb25kaXRpb25SdWxlID0gd2luLkNTU0NvbmRpdGlvblJ1bGU7XG4gICAgfVxuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NTdXBwb3J0c1J1bGVcIikpIHtcbiAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NTdXBwb3J0c1J1bGUgPSB3aW4uQ1NTU3VwcG9ydHNSdWxlO1xuICAgIH1cbiAgfVxuICBjb25zdCB1bm1vZGlmaWVkRnVuY3Rpb25zID0ge307XG4gIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XG4gICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XSA9IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGluc2VydFJ1bGU6IHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBkZWxldGVSdWxlOiB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlXG4gICAgfTtcbiAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KFxuICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlLFxuICAgICAge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtydWxlLCBpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgICAgICB0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsXG4gICAgICAgICAgICAgIG1pcnJvcjIsXG4gICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggfHwgMFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDBcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eShcbiAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSxcbiAgICAgIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICAgICAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZChcbiAgICAgICAgICAgICAgdGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LFxuICAgICAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IFsuLi5nZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBpbmRleF0gfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGluc2VydFJ1bGU7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBkZWxldGVSdWxlO1xuICAgIHJlcGxhY2UgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gcmVwbGFjZSk7XG4gICAgcmVwbGFjZVN5bmMgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IHJlcGxhY2VTeW5jKTtcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goKFt0eXBlS2V5LCB0eXBlXSkgPT4ge1xuICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZTtcbiAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoe1xuICBtaXJyb3I6IG1pcnJvcjIsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCBob3N0KSB7XG4gIGxldCBob3N0SWQgPSBudWxsO1xuICBpZiAoaG9zdC5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIikgaG9zdElkID0gbWlycm9yMi5nZXRJZChob3N0KTtcbiAgZWxzZSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QuaG9zdCk7XG4gIGNvbnN0IHBhdGNoVGFyZ2V0ID0gaG9zdC5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiA/IGhvc3QuZGVmYXVsdFZpZXc/LkRvY3VtZW50IDogaG9zdC5vd25lckRvY3VtZW50Py5kZWZhdWx0Vmlldz8uU2hhZG93Um9vdDtcbiAgY29uc3Qgb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IgPSBwYXRjaFRhcmdldD8ucHJvdG90eXBlID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICBwYXRjaFRhcmdldD8ucHJvdG90eXBlLFxuICAgIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCJcbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fCBob3N0SWQgPT09IC0xIHx8ICFwYXRjaFRhcmdldCB8fCAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdCwgXCJhZG9wdGVkU3R5bGVTaGVldHNcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldD8uY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldChzaGVldHMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldD8uY2FsbCh0aGlzLCBzaGVldHMpO1xuICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGdldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXRcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHtcbiAgc3R5bGVEZWNsYXJhdGlvbkNiLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gIHN0eWxlc2hlZXRNYW5hZ2VyXG59LCB7IHdpbiB9KSB7XG4gIGNvbnN0IHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcbiAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKFxuICAgICAgKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xuICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0gPSBhcmd1bWVudHNMaXN0O1xuICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcucGFyZW50UnVsZT8ucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBwcmlvcml0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgIH1cbiAgICApXG4gIH0pO1xuICBjb25zdCByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcbiAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XG4gICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihcbiAgICAgICh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcbiAgICAgICAgY29uc3QgW3Byb3BlcnR5XSA9IGFyZ3VtZW50c0xpc3Q7XG4gICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlUHJvcGVydHkuYXBwbHkodGhpc0FyZywgW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKFxuICAgICAgICAgIHRoaXNBcmcucGFyZW50UnVsZT8ucGFyZW50U3R5bGVTaGVldCxcbiAgICAgICAgICBtaXJyb3IyLFxuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICByZW1vdmU6IHtcbiAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICB9XG4gICAgKVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcih7XG4gIG1lZGlhSW50ZXJhY3Rpb25DYixcbiAgYmxvY2tDbGFzcyxcbiAgYmxvY2tTZWxlY3RvcixcbiAgdW5ibG9ja1NlbGVjdG9yLFxuICBtaXJyb3I6IG1pcnJvcjIsXG4gIHNhbXBsaW5nLFxuICBkb2Ncbn0pIHtcbiAgY29uc3QgaGFuZGxlciA9IGNhbGxiYWNrV3JhcHBlcihcbiAgICAodHlwZSkgPT4gdGhyb3R0bGUkMShcbiAgICAgIGNhbGxiYWNrV3JhcHBlcigoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSB9ID0gdGFyZ2V0O1xuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICBjdXJyZW50VGltZSxcbiAgICAgICAgICB2b2x1bWUsXG4gICAgICAgICAgbXV0ZWQsXG4gICAgICAgICAgcGxheWJhY2tSYXRlXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBzYW1wbGluZy5tZWRpYSB8fCA1MDBcbiAgICApXG4gICk7XG4gIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgIG9uKFwicGxheVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBsYXkpLCBkb2MpLFxuICAgIG9uKFwicGF1c2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QYXVzZSksIGRvYyksXG4gICAgb24oXCJzZWVrZWRcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5TZWVrZWQpLCBkb2MpLFxuICAgIG9uKFwidm9sdW1lY2hhbmdlXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuVm9sdW1lQ2hhbmdlKSwgZG9jKSxcbiAgICBvbihcInJhdGVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5SYXRlQ2hhbmdlKSwgZG9jKVxuICBdO1xuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRGb250T2JzZXJ2ZXIoeyBmb250Q2IsIGRvYyB9KSB7XG4gIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgaWYgKCF3aW4pIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgY29uc3QgZm9udE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xuICB3aW4uRm9udEZhY2UgPSBmdW5jdGlvbiBGb250RmFjZTIoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZm9udEZhY2UgPSBuZXcgb3JpZ2luYWxGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpO1xuICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XG4gICAgICBmYW1pbHksXG4gICAgICBidWZmZXI6IHR5cGVvZiBzb3VyY2UgIT09IFwic3RyaW5nXCIsXG4gICAgICBkZXNjcmlwdG9ycyxcbiAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgPyBzb3VyY2UgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKVxuICAgIH0pO1xuICAgIHJldHVybiBmb250RmFjZTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICBkb2MuZm9udHMsXG4gICAgXCJhZGRcIixcbiAgICBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRGYWNlKSB7XG4gICAgICAgIHNldFRpbWVvdXQkMShcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtmb250RmFjZV0pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIGhhbmRsZXJzLnB1c2goKCkgPT4ge1xuICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gIH0pO1xuICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgY29uc3Qge1xuICAgIGRvYyxcbiAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgYmxvY2tDbGFzcyxcbiAgICBibG9ja1NlbGVjdG9yLFxuICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICBzZWxlY3Rpb25DYlxuICB9ID0gcGFyYW07XG4gIGxldCBjb2xsYXBzZWQgPSB0cnVlO1xuICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBjb2xsYXBzZWQgJiYgc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkgcmV0dXJuO1xuICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBjb3VudCA9IHNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IDA7XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGNvdW50OyBpMisrKSB7XG4gICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkyKTtcbiAgICAgIGNvbnN0IHsgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCB9ID0gcmFuZ2U7XG4gICAgICBjb25zdCBibG9ja2VkID0gaXNCbG9ja2VkKFxuICAgICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICB0cnVlXG4gICAgICApIHx8IGlzQmxvY2tlZChcbiAgICAgICAgZW5kQ29udGFpbmVyLFxuICAgICAgICBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBpZiAoYmxvY2tlZCkgY29udGludWU7XG4gICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZDogbWlycm9yMi5nZXRJZChlbmRDb250YWluZXIpLFxuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DYih7IHJhbmdlcyB9KTtcbiAgfSk7XG4gIHVwZGF0ZVNlbGVjdGlvbigpO1xuICByZXR1cm4gb24oXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdXBkYXRlU2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRDdXN0b21FbGVtZW50T2JzZXJ2ZXIoe1xuICBkb2MsXG4gIGN1c3RvbUVsZW1lbnRDYlxufSkge1xuICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgd2luLmN1c3RvbUVsZW1lbnRzLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICBkZWZpbmU6IHtcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbbmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnNdKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XG59XG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8yLCBfaG9va3MgPSB7fSkge1xuICBjb25zdCBjdXJyZW50V2luZG93ID0gbzIuZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgbGV0IG11dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gIH1cbiAgY29uc3QgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICBjb25zdCBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgY29uc3Qgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgfSk7XG4gIGNvbnN0IGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgY29uc3QgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgbGV0IHN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHtcbiAgfTtcbiAgbGV0IGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBmb250T2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIH07XG4gIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcbiAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgY29uc3QgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gIGNvbnN0IHBsdWdpbkhhbmRsZXJzID0gW107XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIG8yLnBsdWdpbnMpIHtcbiAgICBwbHVnaW5IYW5kbGVycy5wdXNoKFxuICAgICAgcGx1Z2luLm9ic2VydmVyKHBsdWdpbi5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luLm9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYikgPT4gYi5yZXNldCgpKTtcbiAgICBtdXRhdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgIGlucHV0SGFuZGxlcigpO1xuICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgIGZvbnRPYnNlcnZlcigpO1xuICAgIHNlbGVjdGlvbk9ic2VydmVyKCk7XG4gICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUocHJvcCkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGVcbiAgKTtcbn1cbmNsYXNzIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGdldElkKGlmcmFtZSwgcmVtb3RlSWQsIGlkVG9SZW1vdGVNYXAsIHJlbW90ZVRvSWRNYXApIHtcbiAgICBjb25zdCBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XG4gICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIGxldCBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZUlkRm4oKTtcbiAgICAgIGlkVG9SZW1vdGVJZE1hcC5zZXQocmVtb3RlSWQsIGlkKTtcbiAgICAgIHJlbW90ZUlkVG9JZE1hcC5zZXQoaWQsIHJlbW90ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGdldElkcyhpZnJhbWUsIHJlbW90ZUlkKSB7XG4gICAgY29uc3QgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgIHJldHVybiByZW1vdGVJZC5tYXAoXG4gICAgICAoaWQpID0+IHRoaXMuZ2V0SWQoaWZyYW1lLCBpZCwgaWRUb1JlbW90ZUlkTWFwLCByZW1vdGVJZFRvSWRNYXApXG4gICAgKTtcbiAgfVxuICBnZXRSZW1vdGVJZChpZnJhbWUsIGlkLCBtYXApIHtcbiAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcIm51bWJlclwiKSByZXR1cm4gaWQ7XG4gICAgY29uc3QgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlbW90ZUlkKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHJlbW90ZUlkO1xuICB9XG4gIGdldFJlbW90ZUlkcyhpZnJhbWUsIGlkcykge1xuICAgIGNvbnN0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiB0aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCkpO1xuICB9XG4gIHJlc2V0KGlmcmFtZSkge1xuICAgIGlmICghaWZyYW1lKSB7XG4gICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gIH1cbiAgZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xuICAgIGxldCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIWlkVG9SZW1vdGVJZE1hcCkge1xuICAgICAgaWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLnNldChpZnJhbWUsIGlkVG9SZW1vdGVJZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiBpZFRvUmVtb3RlSWRNYXA7XG4gIH1cbiAgZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xuICAgIGxldCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5nZXQoaWZyYW1lKTtcbiAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xuICAgICAgcmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVJZFRvSWRNYXA7XG4gIH1cbn1cbmNsYXNzIElmcmFtZU1hbmFnZXJOb29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5JZCk7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGFkZElmcmFtZSgpIHtcbiAgfVxuICBhZGRMb2FkTGlzdGVuZXIoKSB7XG4gIH1cbiAgYXR0YWNoSWZyYW1lKCkge1xuICB9XG59XG5jbGFzcyBJZnJhbWVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaWZyYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKTtcbiAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgIHRoaXMud3JhcHBlZEVtaXQgPSBvcHRpb25zLndyYXBwZWRFbWl0O1xuICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIgPSBvcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgIHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXM7XG4gICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yID0gbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKFxuICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQoXG4gICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3JcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBhZGRJZnJhbWUoaWZyYW1lRWwpIHtcbiAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcbiAgICBpZiAoaWZyYW1lRWwuY29udGVudFdpbmRvdylcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuc2V0KGlmcmFtZUVsLmNvbnRlbnRXaW5kb3csIGlmcmFtZUVsKTtcbiAgfVxuICBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcbiAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xuICB9XG4gIGF0dGFjaElmcmFtZShpZnJhbWVFbCwgY2hpbGRTbikge1xuICAgIHRoaXMubXV0YXRpb25DYih7XG4gICAgICBhZGRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICBub2RlOiBjaGlsZFNuXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICByZW1vdmVzOiBbXSxcbiAgICAgIHRleHRzOiBbXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpXG4gICAgICBpZnJhbWVFbC5jb250ZW50V2luZG93Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgdGhpcy5sb2FkTGlzdGVuZXI/LihpZnJhbWVFbCk7XG4gICAgY29uc3QgaWZyYW1lRG9jID0gZ2V0SUZyYW1lQ29udGVudERvY3VtZW50KGlmcmFtZUVsKTtcbiAgICBpZiAoaWZyYW1lRG9jICYmIGlmcmFtZURvYy5hZG9wdGVkU3R5bGVTaGVldHMgJiYgaWZyYW1lRG9jLmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxuICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICBpZnJhbWVEb2MuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVEb2MpXG4gICAgICApO1xuICB9XG4gIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50ID0gbWVzc2FnZTtcbiAgICBpZiAoY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS50eXBlICE9PSBcInJyd2ViXCIgfHwgLy8gVG8gZmlsdGVyIG91dCB0aGUgcnJ3ZWIgbWVzc2FnZXMgd2hpY2ggYXJlIGZvcndhcmRlZCBieSBzb21lIHNpdGVzLlxuICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50Lm9yaWdpbiAhPT0gY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5vcmlnaW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaWZyYW1lU291cmNlV2luZG93ID0gbWVzc2FnZS5zb3VyY2U7XG4gICAgaWYgKCFpZnJhbWVTb3VyY2VXaW5kb3cpIHJldHVybjtcbiAgICBjb25zdCBpZnJhbWVFbCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuZ2V0KG1lc3NhZ2Uuc291cmNlKTtcbiAgICBpZiAoIWlmcmFtZUVsKSByZXR1cm47XG4gICAgY29uc3QgdHJhbnNmb3JtZWRFdmVudCA9IHRoaXMudHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChcbiAgICAgIGlmcmFtZUVsLFxuICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5ldmVudFxuICAgICk7XG4gICAgaWYgKHRyYW5zZm9ybWVkRXZlbnQpXG4gICAgICB0aGlzLndyYXBwZWRFbWl0KFxuICAgICAgICB0cmFuc2Zvcm1lZEV2ZW50LFxuICAgICAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmlzQ2hlY2tvdXRcbiAgICAgICk7XG4gIH1cbiAgdHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgZTIpIHtcbiAgICBzd2l0Y2ggKGUyLnR5cGUpIHtcbiAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDoge1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZTIuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgIGNvbnN0IHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRpbWVzdGFtcDogZTIudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlOiBlMi5kYXRhLm5vZGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRXZlbnRUeXBlLk1ldGE6XG4gICAgICBjYXNlIEV2ZW50VHlwZS5Mb2FkOlxuICAgICAgY2FzZSBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjYXNlIEV2ZW50VHlwZS5QbHVnaW46IHtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuQ3VzdG9tOiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhcbiAgICAgICAgICBlMi5kYXRhLnBheWxvYWQsXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgW1wiaWRcIiwgXCJwYXJlbnRJZFwiLCBcInByZXZpb3VzSWRcIiwgXCJuZXh0SWRcIl1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgfVxuICAgICAgY2FzZSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDoge1xuICAgICAgICBzd2l0Y2ggKGUyLmRhdGEuc291cmNlKSB7XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5hZGRzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICBjb25zdCByb290SWQgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgIHJvb3RJZCAmJiB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4yLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJwYXJlbnRJZFwiLCBcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goKG4yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcImlkXCJdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZTIuZGF0YS50ZXh0cy5mb3JFYWNoKChuMikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOiB7XG4gICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhwLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNjcm9sbDpcbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOlxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXCJpZFwiXSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wic3R5bGVJZFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRm9udDoge1xuICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbjoge1xuICAgICAgICAgICAgZTIuZGF0YS5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1wic3RhcnRcIiwgXCJlbmRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQ6IHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1wiaWRcIl0pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcInN0eWxlSWRzXCJdKTtcbiAgICAgICAgICAgIGUyLmRhdGEuc3R5bGVzPy5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhzdHlsZSwgaWZyYW1lRWwsIFtcInN0eWxlSWRcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgdHlwZW9mIG9ialtrZXldICE9PSBcIm51bWJlclwiKSBjb250aW51ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoXG4gICAgICAgICAgaWZyYW1lRWwsXG4gICAgICAgICAgb2JqW2tleV1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgfVxuICByZXBsYWNlSWRPbk5vZGUobm9kZSwgaWZyYW1lRWwpIHtcbiAgICB0aGlzLnJlcGxhY2VJZHMobm9kZSwgaWZyYW1lRWwsIFtcImlkXCIsIFwicm9vdElkXCJdKTtcbiAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZSkge1xuICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGNoaWxkLCBpZnJhbWVFbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGF0Y2hSb290SWRPbk5vZGUobm9kZSwgcm9vdElkKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gTm9kZVR5cGUkMi5Eb2N1bWVudCAmJiAhbm9kZS5yb290SWQpIG5vZGUucm9vdElkID0gcm9vdElkO1xuICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlKSB7XG4gICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2hhZG93RG9tTWFuYWdlck5vb3Age1xuICBpbml0KCkge1xuICB9XG4gIGFkZFNoYWRvd1Jvb3QoKSB7XG4gIH1cbiAgb2JzZXJ2ZUF0dGFjaFNoYWRvdygpIHtcbiAgfVxuICByZXNldCgpIHtcbiAgfVxufVxuY2xhc3MgU2hhZG93RG9tTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNoYWRvd0RvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICB0aGlzLnNjcm9sbENiID0gb3B0aW9ucy5zY3JvbGxDYjtcbiAgICB0aGlzLmJ5cGFzc09wdGlvbnMgPSBvcHRpb25zLmJ5cGFzc09wdGlvbnM7XG4gICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KEVsZW1lbnQsIGRvY3VtZW50KTtcbiAgfVxuICBhZGRTaGFkb3dSb290KHNoYWRvd1Jvb3QsIGRvYykge1xuICAgIGlmICghaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdCkpIHJldHVybjtcbiAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290KSkgcmV0dXJuO1xuICAgIHRoaXMuc2hhZG93RG9tcy5hZGQoc2hhZG93Um9vdCk7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zLmNhbnZhc01hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290KTtcbiAgICBjb25zdCBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKFxuICAgICAge1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIGRvYyxcbiAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzXG4gICAgICB9LFxuICAgICAgc2hhZG93Um9vdFxuICAgICk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICBpbml0U2Nyb2xsT2JzZXJ2ZXIoe1xuICAgICAgICAuLi50aGlzLmJ5cGFzc09wdGlvbnMsXG4gICAgICAgIHNjcm9sbENiOiB0aGlzLnNjcm9sbENiLFxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wcmF2ZWVucHVnbGlhLzA4MzJkYTY4N2VkNWE1ZDdhMDkwNzA0NmM5ZWYxODEzXG4gICAgICAgIC8vIHNjcm9sbCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIHRoZSBib3VuZGFyeSwgc28gd2UgbmVlZCB0byBsaXN0ZW4gdGhlIHNoYWRvdyBkb2N1bWVudFxuICAgICAgICBkb2M6IHNoYWRvd1Jvb3QsXG4gICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgICBzZXRUaW1lb3V0JDEoKCkgPT4ge1xuICAgICAgaWYgKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzICYmIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICAgIHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICAgIHRoaXMubWlycm9yLmdldElkKHNoYWRvd1Jvb3QuaG9zdClcbiAgICAgICAgKTtcbiAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICAgIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCAnYXR0YWNoU2hhZG93JyBvZiBhbiBJRnJhbWVFbGVtZW50IHRvIG9ic2VydmUgbmV3bHkgYWRkZWQgc2hhZG93IGRvbXMuXG4gICAqL1xuICBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICBjb25zdCBpZnJhbWVEb2MgPSBnZXRJRnJhbWVDb250ZW50RG9jdW1lbnQoaWZyYW1lRWxlbWVudCk7XG4gICAgY29uc3QgaWZyYW1lV2luZG93ID0gZ2V0SUZyYW1lQ29udGVudFdpbmRvdyhpZnJhbWVFbGVtZW50KTtcbiAgICBpZiAoIWlmcmFtZURvYyB8fCAhaWZyYW1lV2luZG93KSByZXR1cm47XG4gICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhcbiAgICAgIGlmcmFtZVdpbmRvdy5FbGVtZW50LFxuICAgICAgaWZyYW1lRG9jXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2ggJ2F0dGFjaFNoYWRvdycgdG8gb2JzZXJ2ZSBuZXdseSBhZGRlZCBzaGFkb3cgZG9tcy5cbiAgICovXG4gIHBhdGNoQXR0YWNoU2hhZG93KGVsZW1lbnQsIGRvYykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goXG4gICAgICBwYXRjaChcbiAgICAgICAgZWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIFwiYXR0YWNoU2hhZG93XCIsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IG9yaWdpbmFsLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QgJiYgaW5Eb20odGhpcykpXG4gICAgICAgICAgICAgIG1hbmFnZXIuYWRkU2hhZG93Um9vdCh0aGlzLnNoYWRvd1Jvb3QsIGRvYyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XG4gICAgdGhpcy5zaGFkb3dEb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy5ieXBhc3NPcHRpb25zLmNhbnZhc01hbmFnZXIucmVzZXRTaGFkb3dSb290cygpO1xuICB9XG59XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG5jbGFzcyBDYW52YXNNYW5hZ2VyTm9vcCB7XG4gIHJlc2V0KCkge1xuICB9XG4gIGZyZWV6ZSgpIHtcbiAgfVxuICB1bmZyZWV6ZSgpIHtcbiAgfVxuICBsb2NrKCkge1xuICB9XG4gIHVubG9jaygpIHtcbiAgfVxuICBzbmFwc2hvdCgpIHtcbiAgfVxuICBhZGRXaW5kb3coKSB7XG4gIH1cbiAgYWRkU2hhZG93Um9vdCgpIHtcbiAgfVxuICByZXNldFNoYWRvd1Jvb3RzKCkge1xuICB9XG59XG5jbGFzcyBTdHlsZXNoZWV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLnN0eWxlTWlycm9yID0gbmV3IFN0eWxlU2hlZXRNaXJyb3IoKTtcbiAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiID0gb3B0aW9ucy5hZG9wdGVkU3R5bGVTaGVldENiO1xuICB9XG4gIGF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbikge1xuICAgIGlmIChcIl9jc3NUZXh0XCIgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKVxuICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgYWRkczogW10sXG4gICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICB0ZXh0czogW10sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogY2hpbGRTbi5pZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNoaWxkU24uYXR0cmlidXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgdGhpcy50cmFja0xpbmtFbGVtZW50KGxpbmtFbCk7XG4gIH1cbiAgdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcbiAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKSByZXR1cm47XG4gICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmFkZChsaW5rRWwpO1xuICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xuICB9XG4gIGFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpIHtcbiAgICBpZiAoc2hlZXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSA9IHtcbiAgICAgIGlkOiBob3N0SWQsXG4gICAgICBzdHlsZUlkczogW11cbiAgICB9O1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2hlZXQgb2Ygc2hlZXRzKSB7XG4gICAgICBsZXQgc3R5bGVJZDtcbiAgICAgIGlmICghdGhpcy5zdHlsZU1pcnJvci5oYXMoc2hlZXQpKSB7XG4gICAgICAgIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmFkZChzaGVldCk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIChyMiwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIyKSxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHN0eWxlSWQgPSB0aGlzLnN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcbiAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZUlkcy5wdXNoKHN0eWxlSWQpO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XG4gICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiKGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZU1pcnJvci5yZXNldCgpO1xuICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICB9XG4gIC8vIFRPRE86IHRha2Ugc25hcHNob3Qgb24gc3R5bGVzaGVldCByZWxvYWQgYnkgYXBwbHlpbmcgZXZlbnQgbGlzdGVuZXJcbiAgdHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChfbGlua0VsKSB7XG4gIH1cbn1cbmNsYXNzIFByb2Nlc3NlZE5vZGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ub2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxuICBpbk90aGVyQnVmZmVyKG5vZGUsIHRoaXNCdWZmZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gdGhpcy5ub2RlTWFwLmdldChub2RlKTtcbiAgICByZXR1cm4gYnVmZmVycyAmJiBBcnJheS5mcm9tKGJ1ZmZlcnMpLnNvbWUoKGJ1ZmZlcikgPT4gYnVmZmVyICE9PSB0aGlzQnVmZmVyKTtcbiAgfVxuICBhZGQobm9kZSwgYnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLmFkZChidWZmZXIpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG59XG5sZXQgd3JhcHBlZEVtaXQ7XG5sZXQgX3Rha2VGdWxsU25hcHNob3Q7XG50cnkge1xuICBpZiAoQXJyYXkuZnJvbShbMV0sICh4KSA9PiB4ICogMilbMF0gIT09IDIpIHtcbiAgICBjb25zdCBjbGVhbkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgIEFycmF5LmZyb20gPSBjbGVhbkZyYW1lLmNvbnRlbnRXaW5kb3c/LkFycmF5LmZyb20gfHwgQXJyYXkuZnJvbTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsZWFuRnJhbWUpO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG5jb25zdCBtaXJyb3IgPSBjcmVhdGVNaXJyb3IkMigpO1xuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZW1pdCxcbiAgICBjaGVja291dEV2ZXJ5Tm1zLFxuICAgIGNoZWNrb3V0RXZlcnlOdGgsXG4gICAgYmxvY2tDbGFzcyA9IFwicnItYmxvY2tcIixcbiAgICBibG9ja1NlbGVjdG9yID0gbnVsbCxcbiAgICB1bmJsb2NrU2VsZWN0b3IgPSBudWxsLFxuICAgIGlnbm9yZUNsYXNzID0gXCJyci1pZ25vcmVcIixcbiAgICBpZ25vcmVTZWxlY3RvciA9IG51bGwsXG4gICAgbWFza0FsbFRleHQgPSBmYWxzZSxcbiAgICBtYXNrVGV4dENsYXNzID0gXCJyci1tYXNrXCIsXG4gICAgdW5tYXNrVGV4dENsYXNzID0gbnVsbCxcbiAgICBtYXNrVGV4dFNlbGVjdG9yID0gbnVsbCxcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3IgPSBudWxsLFxuICAgIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLFxuICAgIG1hc2tBbGxJbnB1dHMsXG4gICAgbWFza0lucHV0T3B0aW9uczogX21hc2tJbnB1dE9wdGlvbnMsXG4gICAgc2xpbURPTU9wdGlvbnM6IF9zbGltRE9NT3B0aW9ucyxcbiAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgbWFza0lucHV0Rm4sXG4gICAgbWFza1RleHRGbixcbiAgICBtYXhDYW52YXNTaXplID0gbnVsbCxcbiAgICBwYWNrRm4sXG4gICAgc2FtcGxpbmcgPSB7fSxcbiAgICBkYXRhVVJMT3B0aW9ucyA9IHt9LFxuICAgIG1vdXNlbW92ZVdhaXQsXG4gICAgcmVjb3JkRE9NID0gdHJ1ZSxcbiAgICByZWNvcmRDYW52YXMgPSBmYWxzZSxcbiAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBmYWxzZSxcbiAgICByZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiLFxuICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gZmFsc2UsXG4gICAgY29sbGVjdEZvbnRzID0gZmFsc2UsXG4gICAgaW5saW5lSW1hZ2VzID0gZmFsc2UsXG4gICAgcGx1Z2lucyxcbiAgICBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSxcbiAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pLFxuICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyMixcbiAgICBvbk11dGF0aW9uLFxuICAgIGdldENhbnZhc01hbmFnZXJcbiAgfSA9IG9wdGlvbnM7XG4gIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcjIpO1xuICBjb25zdCBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPyB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cgOiB0cnVlO1xuICBsZXQgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQpIHtcbiAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoIWluRW1pdHRpbmdGcmFtZSAmJiAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHZvaWQgMCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHZvaWQgMCkge1xuICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XG4gIH1cbiAgbWlycm9yLnJlc2V0KCk7XG4gIGNvbnN0IG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgIGNvbG9yOiB0cnVlLFxuICAgIGRhdGU6IHRydWUsXG4gICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgIGVtYWlsOiB0cnVlLFxuICAgIG1vbnRoOiB0cnVlLFxuICAgIG51bWJlcjogdHJ1ZSxcbiAgICByYW5nZTogdHJ1ZSxcbiAgICBzZWFyY2g6IHRydWUsXG4gICAgdGVsOiB0cnVlLFxuICAgIHRleHQ6IHRydWUsXG4gICAgdGltZTogdHJ1ZSxcbiAgICB1cmw6IHRydWUsXG4gICAgd2VlazogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBzZWxlY3Q6IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWVcbiAgfSA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBfbWFza0lucHV0T3B0aW9ucyA6IHt9O1xuICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgc2NyaXB0OiB0cnVlLFxuICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXG4gICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAvLyBhcyB0aGV5IGRlc3Ryb3kgc29tZSAoaGlkZGVuKSBpbmZvOlxuICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiLFxuICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCJcbiAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICBwb2x5ZmlsbCQxKCk7XG4gIGxldCBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XG4gIGxldCBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICBjb25zdCBldmVudFByb2Nlc3NvciA9IChlMikgPT4ge1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMgfHwgW10pIHtcbiAgICAgIGlmIChwbHVnaW4uZXZlbnRQcm9jZXNzb3IpIHtcbiAgICAgICAgZTIgPSBwbHVnaW4uZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFja0ZuICYmIC8vIERpc2FibGUgcGFja2luZyBldmVudHMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIHRvIHBhcmVudCBmcmFtZXMuXG4gICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgfVxuICAgIHJldHVybiBlMjtcbiAgfTtcbiAgd3JhcHBlZEVtaXQgPSAocjIsIGlzQ2hlY2tvdXQpID0+IHtcbiAgICBjb25zdCBlMiA9IHIyO1xuICAgIGUyLnRpbWVzdGFtcCA9IG5vd1RpbWVzdGFtcCgpO1xuICAgIGlmIChtdXRhdGlvbkJ1ZmZlcnNbMF0/LmlzRnJvemVuKCkgJiYgZTIudHlwZSAhPT0gRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCAmJiAhKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIGUyLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbikpIHtcbiAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi51bmZyZWV6ZSgpKTtcbiAgICB9XG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSkge1xuICAgICAgZW1pdD8uKGV2ZW50UHJvY2Vzc29yKGUyKSwgaXNDaGVja291dCk7XG4gICAgfSBlbHNlIGlmIChwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJycndlYlwiLFxuICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZTIpLFxuICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIGlzQ2hlY2tvdXRcbiAgICAgIH07XG4gICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgICB9XG4gICAgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGUyO1xuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90KSB7XG4gICAgICBpZiAoZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uICYmIGUyLmRhdGEuaXNBdHRhY2hJZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XG4gICAgICBjb25zdCBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XG4gICAgICBjb25zdCBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJiBsYXN0RnVsbFNuYXBzaG90RXZlbnQgJiYgZTIudGltZXN0YW1wIC0gbGFzdEZ1bGxTbmFwc2hvdEV2ZW50LnRpbWVzdGFtcCA+IGNoZWNrb3V0RXZlcnlObXM7XG4gICAgICBpZiAoZXhjZWVkQ291bnQgfHwgZXhjZWVkVGltZSkge1xuICAgICAgICB0YWtlRnVsbFNuYXBzaG90Mih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRNdXRhdGlvbkVtaXQgPSAobSkgPT4ge1xuICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAuLi5tXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHdyYXBwZWRTY3JvbGxFbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICAgIC4uLnBcbiAgICB9XG4gIH0pO1xuICBjb25zdCB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uLFxuICAgICAgLi4ucFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSAoYTIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICBkYXRhOiB7XG4gICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0LFxuICAgICAgLi4uYTJcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdHlsZXNoZWV0TWFuYWdlciA9IG5ldyBTdHlsZXNoZWV0TWFuYWdlcih7XG4gICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICBhZG9wdGVkU3R5bGVTaGVldENiOiB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0XG4gIH0pO1xuICBjb25zdCBpZnJhbWVNYW5hZ2VyID0gdHlwZW9mIF9fUlJXRUJfRVhDTFVERV9JRlJBTUVfXyA9PT0gXCJib29sZWFuXCIgJiYgX19SUldFQl9FWENMVURFX0lGUkFNRV9fID8gbmV3IElmcmFtZU1hbmFnZXJOb29wKCkgOiBuZXcgSWZyYW1lTWFuYWdlcih7XG4gICAgbWlycm9yLFxuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxuICAgIHdyYXBwZWRFbWl0XG4gIH0pO1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XG4gICAgaWYgKHBsdWdpbi5nZXRNaXJyb3IpXG4gICAgICBwbHVnaW4uZ2V0TWlycm9yKHtcbiAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxuICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXG4gICAgICB9KTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWROb2RlTWFuYWdlciA9IG5ldyBQcm9jZXNzZWROb2RlTWFuYWdlcigpO1xuICBjb25zdCBjYW52YXNNYW5hZ2VyID0gX2dldENhbnZhc01hbmFnZXIoXG4gICAgZ2V0Q2FudmFzTWFuYWdlcixcbiAgICB7XG4gICAgICBtaXJyb3IsXG4gICAgICB3aW46IHdpbmRvdyxcbiAgICAgIG11dGF0aW9uQ2I6IChwKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvbixcbiAgICAgICAgICAuLi5wXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICBtYXhDYW52YXNTaXplLFxuICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nW1wiY2FudmFzXCJdLFxuICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcjJcbiAgICB9XG4gICk7XG4gIGNvbnN0IHNoYWRvd0RvbU1hbmFnZXIgPSB0eXBlb2YgX19SUldFQl9FWENMVURFX1NIQURPV19ET01fXyA9PT0gXCJib29sZWFuXCIgJiYgX19SUldFQl9FWENMVURFX1NIQURPV19ET01fXyA/IG5ldyBTaGFkb3dEb21NYW5hZ2VyTm9vcCgpIDogbmV3IFNoYWRvd0RvbU1hbmFnZXIoe1xuICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgIGJ5cGFzc09wdGlvbnM6IHtcbiAgICAgIG9uTXV0YXRpb24sXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIG1hc2tBbGxUZXh0LFxuICAgICAgbWFza1RleHRDbGFzcyxcbiAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICB1bm1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgbWFza0lucHV0T3B0aW9ucyxcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgICAgbWFza1RleHRGbixcbiAgICAgIG1hc2tJbnB1dEZuLFxuICAgICAgcmVjb3JkQ2FudmFzLFxuICAgICAgaW5saW5lSW1hZ2VzLFxuICAgICAgc2FtcGxpbmcsXG4gICAgICBzbGltRE9NT3B0aW9ucyxcbiAgICAgIGlmcmFtZU1hbmFnZXIsXG4gICAgICBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgIGNhbnZhc01hbmFnZXIsXG4gICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcbiAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXNcbiAgICB9LFxuICAgIG1pcnJvclxuICB9KTtcbiAgY29uc3QgdGFrZUZ1bGxTbmFwc2hvdDIgPSAoaXNDaGVja291dCA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKCFyZWNvcmRET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NZXRhLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgd2lkdGg6IGdldFdpbmRvd1dpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNDaGVja291dFxuICAgICk7XG4gICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcbiAgICBzaGFkb3dEb21NYW5hZ2VyLmluaXQoKTtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYubG9jaygpKTtcbiAgICBjb25zdCBub2RlID0gc25hcHNob3QoZG9jdW1lbnQsIHtcbiAgICAgIG1pcnJvcixcbiAgICAgIGJsb2NrQ2xhc3MsXG4gICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgbWFza0FsbFRleHQsXG4gICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgdW5tYXNrVGV4dENsYXNzLFxuICAgICAgbWFza1RleHRTZWxlY3RvcixcbiAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgbWFza0F0dHJpYnV0ZUZuLFxuICAgICAgbWFza0lucHV0Rm4sXG4gICAgICBtYXNrVGV4dEZuLFxuICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXG4gICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGlubGluZUltYWdlcyxcbiAgICAgIG9uU2VyaWFsaXplOiAobjIpID0+IHtcbiAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yKSkge1xuICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yKSkge1xuICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuMi5zaGFkb3dSb290LCBkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcbiAgICAgICAgaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcbiAgICAgICAgaWYgKGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgY2FudmFzTWFuYWdlci5hZGRXaW5kb3coaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIHNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgfSxcbiAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rRWwsIGNoaWxkU24pID0+IHtcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKTtcbiAgICAgIH0sXG4gICAgICBvbkJsb2NrZWRJbWFnZUxvYWQ6IChfaW1hZ2VFbCwgc2VyaWFsaXplZE5vZGUsIHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgIHdyYXBwZWRNdXRhdGlvbkVtaXQoe1xuICAgICAgICAgIGFkZHM6IFtdLFxuICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBzZXJpYWxpemVkTm9kZS5pZCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzXG4gICAgfSk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudFwiKTtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoe1xuICAgICAgdHlwZTogRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5pdGlhbE9mZnNldDogZ2V0V2luZG93U2Nyb2xsKHdpbmRvdylcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5sb2NrKCkpO1xuICAgIGlmIChkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXG4gICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKFxuICAgICAgICBkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsXG4gICAgICAgIG1pcnJvci5nZXRJZChkb2N1bWVudClcbiAgICAgICk7XG4gIH07XG4gIF90YWtlRnVsbFNuYXBzaG90ID0gdGFrZUZ1bGxTbmFwc2hvdDI7XG4gIHRyeSB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICBjb25zdCBvYnNlcnZlID0gKGRvYykgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihpbml0T2JzZXJ2ZXJzKShcbiAgICAgICAge1xuICAgICAgICAgIG9uTXV0YXRpb24sXG4gICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgICBtb3VzZW1vdmVDYjogKHBvc2l0aW9ucywgc291cmNlKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAuLi5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICAgICAgICAgICAgLi4uZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlucHV0Q2I6ICh2MikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgICAgICAgICAgIC4uLnYyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiAocCkgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2I6IChyMikgPT4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGUsXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiAocjIpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgIC4uLnIyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgICBmb250Q2I6IChwKSA9PiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Gb250LFxuICAgICAgICAgICAgICAuLi5wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgc2VsZWN0aW9uQ2I6IChwKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgLi4ucFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogKGMyKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DdXN0b21FbGVtZW50LFxuICAgICAgICAgICAgICAgIC4uLmMyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBpZ25vcmVDbGFzcyxcbiAgICAgICAgICBpZ25vcmVTZWxlY3RvcixcbiAgICAgICAgICBtYXNrQWxsVGV4dCxcbiAgICAgICAgICBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgIHVubWFza1RleHRDbGFzcyxcbiAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgIHVubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgc2FtcGxpbmcsXG4gICAgICAgICAgcmVjb3JkRE9NLFxuICAgICAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgICAgICBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQsXG4gICAgICAgICAgY29sbGVjdEZvbnRzLFxuICAgICAgICAgIGRvYyxcbiAgICAgICAgICBtYXNrQXR0cmlidXRlRm4sXG4gICAgICAgICAgbWFza0lucHV0Rm4sXG4gICAgICAgICAgbWFza1RleHRGbixcbiAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgbWlycm9yLFxuICAgICAgICAgIGlmcmFtZU1hbmFnZXIsXG4gICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgICAgc2hhZG93RG9tTWFuYWdlcixcbiAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcbiAgICAgICAgICBjYW52YXNNYW5hZ2VyLFxuICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gICAgICAgICAgcGx1Z2luczogcGx1Z2lucz8uZmlsdGVyKChwKSA9PiBwLm9ic2VydmVyKT8ubWFwKChwKSA9PiAoe1xuICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXG4gICAgICAgICAgICBvcHRpb25zOiBwLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogKHBheWxvYWQpID0+IHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlBsdWdpbixcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHBsdWdpbjogcC5uYW1lLFxuICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSkgfHwgW11cbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICAgICk7XG4gICAgfTtcbiAgICBpZnJhbWVNYW5hZ2VyLmFkZExvYWRMaXN0ZW5lcigoaWZyYW1lRWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIHRha2VGdWxsU25hcHNob3QyKCk7XG4gICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoZG9jdW1lbnQpKTtcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICBpbml0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goXG4gICAgICAgIG9uKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQsXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJET01Db250ZW50TG9hZGVkXCIpIGluaXQoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgICBvbihcbiAgICAgICAgICBcImxvYWRcIixcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Mb2FkLFxuICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwibG9hZFwiKSBpbml0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aW5kb3dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gICAgICBwcm9jZXNzZWROb2RlTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICBfdGFrZUZ1bGxTbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRha2VGdWxsU25hcHNob3QoaXNDaGVja291dCkge1xuICBpZiAoIV90YWtlRnVsbFNuYXBzaG90KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gIH1cbiAgX3Rha2VGdWxsU25hcHNob3QoaXNDaGVja291dCk7XG59XG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSB0YWtlRnVsbFNuYXBzaG90O1xuZnVuY3Rpb24gX2dldENhbnZhc01hbmFnZXIoZ2V0Q2FudmFzTWFuYWdlckZuLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldENhbnZhc01hbmFnZXJGbiA/IGdldENhbnZhc01hbmFnZXJGbihvcHRpb25zKSA6IG5ldyBDYW52YXNNYW5hZ2VyTm9vcCgpO1xuICB9IGNhdGNoIHtcbiAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBDYW52YXNNYW5hZ2VyXCIpO1xuICAgIHJldHVybiBuZXcgQ2FudmFzTWFuYWdlck5vb3AoKTtcbiAgfVxufVxudmFyIG47XG4hZnVuY3Rpb24odDIpIHtcbiAgdDJbdDIuTm90U3RhcnRlZCA9IDBdID0gXCJOb3RTdGFydGVkXCIsIHQyW3QyLlJ1bm5pbmcgPSAxXSA9IFwiUnVubmluZ1wiLCB0Mlt0Mi5TdG9wcGVkID0gMl0gPSBcIlN0b3BwZWRcIjtcbn0obiB8fCAobiA9IHt9KSk7XG5cbmNvbnN0IFJlcGxheUV2ZW50VHlwZUluY3JlbWVudGFsU25hcHNob3QgPSAzO1xuY29uc3QgUmVwbGF5RXZlbnRUeXBlQ3VzdG9tID0gNTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHRpbWVzdGFtcCB0byBtcywgaWYgaXQgd2FzIGluIHMsIG9yIGtlZXBzIGl0IGFzIG1zLlxuICovXG5mdW5jdGlvbiB0aW1lc3RhbXBUb01zKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wID4gOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgOiB0aW1lc3RhbXAgKiAxMDAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgdGltZXN0YW1wIHRvIHMsIGlmIGl0IHdhcyBpbiBtcywgb3Iga2VlcHMgaXQgYXMgcy5cbiAqL1xuZnVuY3Rpb24gdGltZXN0YW1wVG9TKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wID4gOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgLyAxMDAwIDogdGltZXN0YW1wO1xufVxuXG4vKipcbiAqIEFkZCBhIGJyZWFkY3J1bWIgZXZlbnQgdG8gcmVwbGF5LlxuICovXG5mdW5jdGlvbiBhZGRCcmVhZGNydW1iRXZlbnQocmVwbGF5LCBicmVhZGNydW1iKSB7XG4gIGlmIChicmVhZGNydW1iLmNhdGVnb3J5ID09PSAnc2VudHJ5LnRyYW5zYWN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChbJ3VpLmNsaWNrJywgJ3VpLmlucHV0J10uaW5jbHVkZXMoYnJlYWRjcnVtYi5jYXRlZ29yeSApKSB7XG4gICAgcmVwbGF5LnRyaWdnZXJVc2VyQWN0aXZpdHkoKTtcbiAgfSBlbHNlIHtcbiAgICByZXBsYXkuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpO1xuICB9XG5cbiAgcmVwbGF5LmFkZFVwZGF0ZSgoKSA9PiB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHJlcGxheS50aHJvdHRsZWRBZGRFdmVudCh7XG4gICAgICB0eXBlOiBFdmVudFR5cGUuQ3VzdG9tLFxuICAgICAgLy8gVE9ETzogV2Ugd2VyZSBjb252ZXJ0aW5nIGZyb20gbXMgdG8gc2Vjb25kcyBmb3IgYnJlYWRjcnVtYnMsIHNwYW5zLFxuICAgICAgLy8gYnV0IG1heWJlIHdlIHNob3VsZCBqdXN0IGtlZXAgdGhlbSBhcyBtaWxsaXNlY29uZHNcbiAgICAgIHRpbWVzdGFtcDogKGJyZWFkY3J1bWIudGltZXN0YW1wIHx8IDApICogMTAwMCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFnOiAnYnJlYWRjcnVtYicsXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBtYXguIDEwIGRlcHRoIGFuZCAxXzAwMCBwcm9wZXJ0aWVzIHBlciBvYmplY3RcbiAgICAgICAgcGF5bG9hZDogbm9ybWFsaXplKGJyZWFkY3J1bWIsIDEwLCAxMDAwKSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBEbyBub3QgZmx1c2ggYWZ0ZXIgY29uc29sZSBsb2cgbWVzc2FnZXNcbiAgICByZXR1cm4gYnJlYWRjcnVtYi5jYXRlZ29yeSA9PT0gJ2NvbnNvbGUnO1xuICB9KTtcbn1cblxuY29uc3QgSU5URVJBQ1RJVkVfU0VMRUNUT1IgPSAnYnV0dG9uLGEnO1xuXG4vKiogR2V0IHRoZSBjbG9zZXN0IGludGVyYWN0aXZlIHBhcmVudCBlbGVtZW50LCBvciBlbHNlIHJldHVybiB0aGUgZ2l2ZW4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnRlcmFjdGl2ZShlbGVtZW50KSB7XG4gIGNvbnN0IGNsb3Nlc3RJbnRlcmFjdGl2ZSA9IGVsZW1lbnQuY2xvc2VzdChJTlRFUkFDVElWRV9TRUxFQ1RPUik7XG4gIHJldHVybiBjbG9zZXN0SW50ZXJhY3RpdmUgfHwgZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGb3IgY2xpY2tzLCB3ZSBjaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGluc2lkZSBvZiBhIGJ1dHRvbiBvciBsaW5rXG4gKiBJZiBzbywgd2UgdXNlIHRoaXMgYXMgdGhlIHRhcmdldCBpbnN0ZWFkXG4gKiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGlmIHlvdSBjbGljayBvbiB0aGUgaW1hZ2UgaW4gPGJ1dHRvbj48aW1nPjwvYnV0dG9uPixcbiAqIFRoZSB0YXJnZXQgd2lsbCBiZSB0aGUgaW1hZ2UsIG5vdCB0aGUgYnV0dG9uLCB3aGljaCB3ZSBkb24ndCB3YW50IGhlcmVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpY2tUYXJnZXROb2RlKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldE5vZGUoZXZlbnQpO1xuXG4gIGlmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIGdldENsb3Nlc3RJbnRlcmFjdGl2ZSh0YXJnZXQpO1xufVxuXG4vKiogR2V0IHRoZSBldmVudCB0YXJnZXQgbm9kZS4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldE5vZGUoZXZlbnQpIHtcbiAgaWYgKGlzRXZlbnRXaXRoVGFyZ2V0KGV2ZW50KSkge1xuICAgIHJldHVybiBldmVudC50YXJnZXQgO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBpc0V2ZW50V2l0aFRhcmdldChldmVudCkge1xuICByZXR1cm4gdHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAhIWV2ZW50ICYmICd0YXJnZXQnIGluIGV2ZW50O1xufVxuXG5sZXQgaGFuZGxlcnM7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBoYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIGB3aW5kb3cub3BlbigpYCBpcyBjYWxsZWQuXG4gKiBSZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb25XaW5kb3dPcGVuKGNiKSB7XG4gIC8vIEVuc3VyZSB0byBvbmx5IHJlZ2lzdGVyIHRoaXMgb25jZVxuICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgaGFuZGxlcnMgPSBbXTtcbiAgICBtb25rZXlQYXRjaFdpbmRvd09wZW4oKTtcbiAgfVxuXG4gIGhhbmRsZXJzLnB1c2goY2IpO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgcG9zID0gaGFuZGxlcnMgPyBoYW5kbGVycy5pbmRleE9mKGNiKSA6IC0xO1xuICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgKGhhbmRsZXJzICkuc3BsaWNlKHBvcywgMSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb25rZXlQYXRjaFdpbmRvd09wZW4oKSB7XG4gIGZpbGwoV0lORE9XLCAnb3BlbicsIGZ1bmN0aW9uIChvcmlnaW5hbFdpbmRvd09wZW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKCkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIGhlcmVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luYWxXaW5kb3dPcGVuLmFwcGx5KFdJTkRPVywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKiBBbnkgSW5jcmVtZW50YWxTb3VyY2UgZm9yIHJyd2ViIHRoYXQgd2UgaW50ZXJwcmV0IGFzIGEga2luZCBvZiBtdXRhdGlvbi4gKi9cbmNvbnN0IEluY3JlbWVudGFsTXV0YXRpb25Tb3VyY2VzID0gbmV3IFNldChbXG4gIEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZVNoZWV0UnVsZSxcbiAgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbixcbiAgSW5jcmVtZW50YWxTb3VyY2UuQWRvcHRlZFN0eWxlU2hlZXQsXG4gIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uLFxuICBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG4gIEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG5dKTtcblxuLyoqIEhhbmRsZSBhIGNsaWNrLiAqL1xuZnVuY3Rpb24gaGFuZGxlQ2xpY2soY2xpY2tEZXRlY3RvciwgY2xpY2tCcmVhZGNydW1iLCBub2RlKSB7XG4gIGNsaWNrRGV0ZWN0b3IuaGFuZGxlQ2xpY2soY2xpY2tCcmVhZGNydW1iLCBub2RlKTtcbn1cblxuLyoqIEEgY2xpY2sgZGV0ZWN0b3IgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlY3Qgc2xvdyBvciByYWdlIGNsaWNrcyBvbiBlbGVtZW50cy4gKi9cbmNsYXNzIENsaWNrRGV0ZWN0b3IgIHtcbiAgLy8gcHJvdGVjdGVkIGZvciB0ZXN0aW5nXG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgIHJlcGxheSxcbiAgICBzbG93Q2xpY2tDb25maWcsXG4gICAgLy8gSnVzdCBmb3IgZWFzaWVyIHRlc3RpbmdcbiAgICBfYWRkQnJlYWRjcnVtYkV2ZW50ID0gYWRkQnJlYWRjcnVtYkV2ZW50LFxuICApIHtcbiAgICB0aGlzLl9sYXN0TXV0YXRpb24gPSAwO1xuICAgIHRoaXMuX2xhc3RTY3JvbGwgPSAwO1xuICAgIHRoaXMuX2NsaWNrcyA9IFtdO1xuXG4gICAgLy8gV2Ugd2FudCBldmVyeXRoaW5nIGluIHMsIGJ1dCBvcHRpb25zIGFyZSBpbiBtc1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzbG93Q2xpY2tDb25maWcudGltZW91dCAvIDEwMDA7XG4gICAgdGhpcy5fdGhyZXNob2xkID0gc2xvd0NsaWNrQ29uZmlnLnRocmVzaG9sZCAvIDEwMDA7XG4gICAgdGhpcy5fc2Nyb2xsVGltZW91dCA9IHNsb3dDbGlja0NvbmZpZy5zY3JvbGxUaW1lb3V0IC8gMTAwMDtcbiAgICB0aGlzLl9yZXBsYXkgPSByZXBsYXk7XG4gICAgdGhpcy5faWdub3JlU2VsZWN0b3IgPSBzbG93Q2xpY2tDb25maWcuaWdub3JlU2VsZWN0b3I7XG4gICAgdGhpcy5fYWRkQnJlYWRjcnVtYkV2ZW50ID0gX2FkZEJyZWFkY3J1bWJFdmVudDtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlciBjbGljayBkZXRlY3Rpb24gaGFuZGxlcnMgb24gbXV0YXRpb24gb3Igc2Nyb2xsLiAqL1xuICAgYWRkTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGNsZWFudXBXaW5kb3dPcGVuID0gb25XaW5kb3dPcGVuKCgpID0+IHtcbiAgICAgIC8vIFRyZWF0IHdpbmRvdy5vcGVuIGFzIG11dGF0aW9uXG4gICAgICB0aGlzLl9sYXN0TXV0YXRpb24gPSBub3dJblNlY29uZHMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3RlYXJkb3duID0gKCkgPT4ge1xuICAgICAgY2xlYW51cFdpbmRvd09wZW4oKTtcblxuICAgICAgdGhpcy5fY2xpY2tzID0gW107XG4gICAgICB0aGlzLl9sYXN0TXV0YXRpb24gPSAwO1xuICAgICAgdGhpcy5fbGFzdFNjcm9sbCA9IDA7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBDbGVhbiB1cCBsaXN0ZW5lcnMuICovXG4gICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuX3RlYXJkb3duKSB7XG4gICAgICB0aGlzLl90ZWFyZG93bigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jaGVja0NsaWNrVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrQ2xpY2tUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIGhhbmRsZUNsaWNrKGJyZWFkY3J1bWIsIG5vZGUpIHtcbiAgICBpZiAoaWdub3JlRWxlbWVudChub2RlLCB0aGlzLl9pZ25vcmVTZWxlY3RvcikgfHwgIWlzQ2xpY2tCcmVhZGNydW1iKGJyZWFkY3J1bWIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Q2xpY2sgPSB7XG4gICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFRvUyhicmVhZGNydW1iLnRpbWVzdGFtcCksXG4gICAgICBjbGlja0JyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG4gICAgICAvLyBTZXQgdGhpcyB0byAwIHNvIHdlIGtub3cgaXQgb3JpZ2luYXRlcyBmcm9tIHRoZSBjbGljayBicmVhZGNydW1iXG4gICAgICBjbGlja0NvdW50OiAwLFxuICAgICAgbm9kZSxcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGEgY2xpY2sgaW4gdGhlIGxhc3QgMXMgb24gdGhlIHNhbWUgZWxlbWVudCwgaWdub3JlIGl0IC0gb25seSBrZWVwIGEgc2luZ2xlIHJlZmVyZW5jZSBwZXIgc2Vjb25kXG4gICAgaWYgKFxuICAgICAgdGhpcy5fY2xpY2tzLnNvbWUoY2xpY2sgPT4gY2xpY2subm9kZSA9PT0gbmV3Q2xpY2subm9kZSAmJiBNYXRoLmFicyhjbGljay50aW1lc3RhbXAgLSBuZXdDbGljay50aW1lc3RhbXApIDwgMSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jbGlja3MucHVzaChuZXdDbGljayk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBuZXcgY2xpY2ssIHNldCBhIHRpbWVvdXQgdG8gY2hlY2sgZm9yIG11bHRpIGNsaWNrc1xuICAgIGlmICh0aGlzLl9jbGlja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZUNoZWNrQ2xpY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICByZWdpc3Rlck11dGF0aW9uKHRpbWVzdGFtcCA9IERhdGUubm93KCkpIHtcbiAgICB0aGlzLl9sYXN0TXV0YXRpb24gPSB0aW1lc3RhbXBUb1ModGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgcmVnaXN0ZXJTY3JvbGwodGltZXN0YW1wID0gRGF0ZS5ub3coKSkge1xuICAgIHRoaXMuX2xhc3RTY3JvbGwgPSB0aW1lc3RhbXBUb1ModGltZXN0YW1wKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgcmVnaXN0ZXJDbGljayhlbGVtZW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IGdldENsb3Nlc3RJbnRlcmFjdGl2ZShlbGVtZW50KTtcbiAgICB0aGlzLl9oYW5kbGVNdWx0aUNsaWNrKG5vZGUgKTtcbiAgfVxuXG4gIC8qKiBDb3VudCBtdWx0aXBsZSBjbGlja3Mgb24gZWxlbWVudHMuICovXG4gICBfaGFuZGxlTXVsdGlDbGljayhub2RlKSB7XG4gICAgdGhpcy5fZ2V0Q2xpY2tzKG5vZGUpLmZvckVhY2goY2xpY2sgPT4ge1xuICAgICAgY2xpY2suY2xpY2tDb3VudCsrO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdldCBhbGwgcGVuZGluZyBjbGlja3MgZm9yIGEgZ2l2ZW4gbm9kZS4gKi9cbiAgIF9nZXRDbGlja3Mobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9jbGlja3MuZmlsdGVyKGNsaWNrID0+IGNsaWNrLm5vZGUgPT09IG5vZGUpO1xuICB9XG5cbiAgLyoqIENoZWNrIHRoZSBjbGlja3MgdGhhdCBoYXBwZW5lZC4gKi9cbiAgIF9jaGVja0NsaWNrcygpIHtcbiAgICBjb25zdCB0aW1lZE91dENsaWNrcyA9IFtdO1xuXG4gICAgY29uc3Qgbm93ID0gbm93SW5TZWNvbmRzKCk7XG5cbiAgICB0aGlzLl9jbGlja3MuZm9yRWFjaChjbGljayA9PiB7XG4gICAgICBpZiAoIWNsaWNrLm11dGF0aW9uQWZ0ZXIgJiYgdGhpcy5fbGFzdE11dGF0aW9uKSB7XG4gICAgICAgIGNsaWNrLm11dGF0aW9uQWZ0ZXIgPSBjbGljay50aW1lc3RhbXAgPD0gdGhpcy5fbGFzdE11dGF0aW9uID8gdGhpcy5fbGFzdE11dGF0aW9uIC0gY2xpY2sudGltZXN0YW1wIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjbGljay5zY3JvbGxBZnRlciAmJiB0aGlzLl9sYXN0U2Nyb2xsKSB7XG4gICAgICAgIGNsaWNrLnNjcm9sbEFmdGVyID0gY2xpY2sudGltZXN0YW1wIDw9IHRoaXMuX2xhc3RTY3JvbGwgPyB0aGlzLl9sYXN0U2Nyb2xsIC0gY2xpY2sudGltZXN0YW1wIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgb2YgdGhlc2UgYXJlIGluIHNlY29uZHMhXG4gICAgICBpZiAoY2xpY2sudGltZXN0YW1wICsgdGhpcy5fdGltZW91dCA8PSBub3cpIHtcbiAgICAgICAgdGltZWRPdXRDbGlja3MucHVzaChjbGljayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZW1vdmUgXCJvbGRcIiBjbGlja3NcbiAgICBmb3IgKGNvbnN0IGNsaWNrIG9mIHRpbWVkT3V0Q2xpY2tzKSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9jbGlja3MuaW5kZXhPZihjbGljayk7XG5cbiAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZUJyZWFkY3J1bWJzKGNsaWNrKTtcbiAgICAgICAgdGhpcy5fY2xpY2tzLnNwbGljZShwb3MsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgbmV3IGNoZWNrLCB1bmxlc3Mgbm8gY2xpY2tzIGxlZnRcbiAgICBpZiAodGhpcy5fY2xpY2tzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVDaGVja0NsaWNrcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBHZW5lcmF0ZSBtYXRjaGluZyBicmVhZGNydW1iKHMpIGZvciB0aGUgY2xpY2suICovXG4gICBfZ2VuZXJhdGVCcmVhZGNydW1icyhjbGljaykge1xuICAgIGNvbnN0IHJlcGxheSA9IHRoaXMuX3JlcGxheTtcbiAgICBjb25zdCBoYWRTY3JvbGwgPSBjbGljay5zY3JvbGxBZnRlciAmJiBjbGljay5zY3JvbGxBZnRlciA8PSB0aGlzLl9zY3JvbGxUaW1lb3V0O1xuICAgIGNvbnN0IGhhZE11dGF0aW9uID0gY2xpY2subXV0YXRpb25BZnRlciAmJiBjbGljay5tdXRhdGlvbkFmdGVyIDw9IHRoaXMuX3RocmVzaG9sZDtcblxuICAgIGNvbnN0IGlzU2xvd0NsaWNrID0gIWhhZFNjcm9sbCAmJiAhaGFkTXV0YXRpb247XG4gICAgY29uc3QgeyBjbGlja0NvdW50LCBjbGlja0JyZWFkY3J1bWIgfSA9IGNsaWNrO1xuXG4gICAgLy8gU2xvdyBjbGlja1xuICAgIGlmIChpc1Nsb3dDbGljaykge1xuICAgICAgLy8gSWYgYG11dGF0aW9uQWZ0ZXJgIGlzIHNldCwgaXQgbWVhbnMgYSBtdXRhdGlvbiBoYXBwZW5lZCBhZnRlciB0aGUgdGhyZXNob2xkLCBidXQgYmVmb3JlIHRoZSB0aW1lb3V0XG4gICAgICAvLyBJZiBub3QsIGl0IG1lYW5zIHdlIGp1c3QgdGltZWQgb3V0IHdpdGhvdXQgc2Nyb2xsICYgbXV0YXRpb25cbiAgICAgIGNvbnN0IHRpbWVBZnRlckNsaWNrTXMgPSBNYXRoLm1pbihjbGljay5tdXRhdGlvbkFmdGVyIHx8IHRoaXMuX3RpbWVvdXQsIHRoaXMuX3RpbWVvdXQpICogMTAwMDtcbiAgICAgIGNvbnN0IGVuZFJlYXNvbiA9IHRpbWVBZnRlckNsaWNrTXMgPCB0aGlzLl90aW1lb3V0ICogMTAwMCA/ICdtdXRhdGlvbicgOiAndGltZW91dCc7XG5cbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICAgICAgbWVzc2FnZTogY2xpY2tCcmVhZGNydW1iLm1lc3NhZ2UsXG4gICAgICAgIHRpbWVzdGFtcDogY2xpY2tCcmVhZGNydW1iLnRpbWVzdGFtcCxcbiAgICAgICAgY2F0ZWdvcnk6ICd1aS5zbG93Q2xpY2tEZXRlY3RlZCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5jbGlja0JyZWFkY3J1bWIuZGF0YSxcbiAgICAgICAgICB1cmw6IFdJTkRPVy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHJvdXRlOiByZXBsYXkuZ2V0Q3VycmVudFJvdXRlKCksXG4gICAgICAgICAgdGltZUFmdGVyQ2xpY2tNcyxcbiAgICAgICAgICBlbmRSZWFzb24sXG4gICAgICAgICAgLy8gSWYgY2xpY2tDb3VudCA9PT0gMCwgaXQgbWVhbnMgbXVsdGlDbGljayB3YXMgbm90IGNvcnJlY3RseSBjYXB0dXJlZCBoZXJlXG4gICAgICAgICAgLy8gLSB3ZSBzdGlsbCB3YW50IHRvIHNlbmQgMSBpbiB0aGlzIGNhc2VcbiAgICAgICAgICBjbGlja0NvdW50OiBjbGlja0NvdW50IHx8IDEsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9hZGRCcmVhZGNydW1iRXZlbnQocmVwbGF5LCBicmVhZGNydW1iKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNdWx0aSBjbGlja1xuICAgIGlmIChjbGlja0NvdW50ID4gMSkge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgICAgICBtZXNzYWdlOiBjbGlja0JyZWFkY3J1bWIubWVzc2FnZSxcbiAgICAgICAgdGltZXN0YW1wOiBjbGlja0JyZWFkY3J1bWIudGltZXN0YW1wLFxuICAgICAgICBjYXRlZ29yeTogJ3VpLm11bHRpQ2xpY2snLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uY2xpY2tCcmVhZGNydW1iLmRhdGEsXG4gICAgICAgICAgdXJsOiBXSU5ET1cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICByb3V0ZTogcmVwbGF5LmdldEN1cnJlbnRSb3V0ZSgpLFxuICAgICAgICAgIGNsaWNrQ291bnQsXG4gICAgICAgICAgbWV0cmljOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgdGhpcy5fYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgYnJlYWRjcnVtYik7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNjaGVkdWxlIHRvIGNoZWNrIGN1cnJlbnQgY2xpY2tzLiAqL1xuICAgX3NjaGVkdWxlQ2hlY2tDbGlja3MoKSB7XG4gICAgaWYgKHRoaXMuX2NoZWNrQ2xpY2tUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2hlY2tDbGlja1RpbWVvdXQpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoZWNrQ2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dCQzKCgpID0+IHRoaXMuX2NoZWNrQ2xpY2tzKCksIDEwMDApO1xuICB9XG59XG5cbmNvbnN0IFNMT1dfQ0xJQ0tfVEFHUyA9IFsnQScsICdCVVRUT04nLCAnSU5QVVQnXTtcblxuLyoqIGV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBpZ25vcmVFbGVtZW50KG5vZGUsIGlnbm9yZVNlbGVjdG9yKSB7XG4gIGlmICghU0xPV19DTElDS19UQUdTLmluY2x1ZGVzKG5vZGUudGFnTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElmIDxpbnB1dD4gdGFnLCB3ZSBvbmx5IHdhbnQgdG8gY29uc2lkZXIgaW5wdXRbdHlwZT0nc3VibWl0J10gJiBpbnB1dFt0eXBlPSdidXR0b24nXVxuICBpZiAobm9kZS50YWdOYW1lID09PSAnSU5QVVQnICYmICFbJ3N1Ym1pdCcsICdidXR0b24nXS5pbmNsdWRlcyhub2RlLmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICcnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgPGE+IHRhZywgZGV0ZWN0IHNwZWNpYWwgdmFyaWFudHMgdGhhdCBtYXkgbm90IGxlYWQgdG8gYW4gYWN0aW9uXG4gIC8vIElmIHRhcmdldCAhPT0gX3NlbGYsIHdlIG1heSBvcGVuIHRoZSBsaW5rIHNvbWV3aGVyZSBlbHNlLCB3aGljaCB3b3VsZCBsZWFkIHRvIG5vIGFjdGlvblxuICAvLyBBbHNvLCB3aGVuIGRvd25sb2FkaW5nIGEgZmlsZSwgd2UgbWF5IG5vdCBsZWF2ZSB0aGUgcGFnZSwgYnV0IHN0aWxsIG5vdCB0cmlnZ2VyIGFuIGFjdGlvblxuICBpZiAoXG4gICAgbm9kZS50YWdOYW1lID09PSAnQScgJiZcbiAgICAobm9kZS5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHwgKG5vZGUuaGFzQXR0cmlidXRlKCd0YXJnZXQnKSAmJiBub2RlLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykgIT09ICdfc2VsZicpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpZ25vcmVTZWxlY3RvciAmJiBub2RlLm1hdGNoZXMoaWdub3JlU2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpY2tCcmVhZGNydW1iKGJyZWFkY3J1bWIpIHtcbiAgcmV0dXJuICEhKGJyZWFkY3J1bWIuZGF0YSAmJiB0eXBlb2YgYnJlYWRjcnVtYi5kYXRhLm5vZGVJZCA9PT0gJ251bWJlcicgJiYgYnJlYWRjcnVtYi50aW1lc3RhbXApO1xufVxuXG4vLyBUaGlzIGlzIGdvb2QgZW5vdWdoIGZvciB1cywgYW5kIGlzIGVhc2llciB0byB0ZXN0L21vY2sgdGhhbiBgdGltZXN0YW1wSW5TZWNvbmRzYFxuZnVuY3Rpb24gbm93SW5TZWNvbmRzKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKSAvIDEwMDA7XG59XG5cbi8qKiBVcGRhdGUgdGhlIGNsaWNrIGRldGVjdG9yIGJhc2VkIG9uIGEgcmVjb3JkaW5nIGV2ZW50IG9mIHJyd2ViLiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2xpY2tEZXRlY3RvckZvclJlY29yZGluZ0V2ZW50KGNsaWNrRGV0ZWN0b3IsIGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgLy8gbm90ZTogV2Ugb25seSBjb25zaWRlciBpbmNyZW1lbnRhbCBzbmFwc2hvdHMgaGVyZVxuICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBhbnkgZnVsbCBzbmFwc2hvdCBpcyBpZ25vcmVkIGZvciBtdXRhdGlvbiBkZXRlY3Rpb24gLSB0aGUgcmVhc29uIGlzIHRoYXQgd2Ugc2ltcGx5IGNhbm5vdCBrbm93IGlmIGEgbXV0YXRpb24gaGFwcGVuZWQgaGVyZS5cbiAgICAvLyBFLmcuIHRoaW5rIHRoYXQgd2UgYXJlIGJ1ZmZlcmluZywgYW4gZXJyb3IgaGFwcGVucyBhbmQgd2UgdGFrZSBhIGZ1bGwgc25hcHNob3QgYmVjYXVzZSB3ZSBzd2l0Y2hlZCB0byBzZXNzaW9uIG1vZGUgLVxuICAgIC8vIGluIHRoaXMgc2NlbmFyaW8sIHdlIHdvdWxkIG5vdCBrbm93IGlmIGEgZGVhZCBjbGljayBoYXBwZW5lZCBiZWNhdXNlIG9mIHRoZSBlcnJvciwgd2hpY2ggaXMgYSBrZXkgZGVhZCBjbGljayBzY2VuYXJpby5cbiAgICAvLyBJbnN0ZWFkLCBieSBpZ25vcmluZyBmdWxsIHNuYXBzaG90cywgd2UgaGF2ZSB0aGUgcmlzayB0aGF0IHdlIGdlbmVyYXRlIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAvLyAoaWYgYSBtdXRhdGlvbiBfZGlkXyBoYXBwZW4gYnV0IHdhcyBcInN3YWxsb3dlZFwiIGJ5IHRoZSBmdWxsIHNuYXBzaG90KVxuICAgIC8vIEJ1dCB0aGlzIHNob3VsZCBiZSBtb3JlIHVubGlrZWx5IGFzIHdlJ2QgZ2VuZXJhbGx5IGNhcHR1cmUgdGhlIGluY3JlbWVudGFsIHNuYXBzaG90IHJpZ2h0IGF3YXlcblxuICAgIGlmICghaXNJbmNyZW1lbnRhbEV2ZW50KGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBldmVudC5kYXRhO1xuICAgIGlmIChJbmNyZW1lbnRhbE11dGF0aW9uU291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgY2xpY2tEZXRlY3Rvci5yZWdpc3Rlck11dGF0aW9uKGV2ZW50LnRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsKSB7XG4gICAgICBjbGlja0RldGVjdG9yLnJlZ2lzdGVyU2Nyb2xsKGV2ZW50LnRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSW5jcmVtZW50YWxNb3VzZUludGVyYWN0aW9uKGV2ZW50KSkge1xuICAgICAgY29uc3QgeyB0eXBlLCBpZCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgIGNvbnN0IG5vZGUgPSByZWNvcmQubWlycm9yLmdldE5vZGUoaWQpO1xuXG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHR5cGUgPT09IE1vdXNlSW50ZXJhY3Rpb25zLkNsaWNrKSB7XG4gICAgICAgIGNsaWNrRGV0ZWN0b3IucmVnaXN0ZXJDbGljayhub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBlcnJvcnMgaGVyZSwgZS5nLiBpZiBhY2Nlc3Npbmcgc29tZXRoaW5nIHRoYXQgZG9lcyBub3QgZXhpc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luY3JlbWVudGFsRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFJlcGxheUV2ZW50VHlwZUluY3JlbWVudGFsU25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIGlzSW5jcmVtZW50YWxNb3VzZUludGVyYWN0aW9uKFxuICBldmVudCxcbikge1xuICByZXR1cm4gZXZlbnQuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb247XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYnJlYWRjcnVtYiBmb3IgYSByZXBsYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyZWFkY3J1bWIoXG4gIGJyZWFkY3J1bWIsXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwLFxuICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICAuLi5icmVhZGNydW1iLFxuICB9O1xufVxuXG52YXIgTm9kZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChOb2RlVHlwZTIpID0+IHtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICByZXR1cm4gTm9kZVR5cGUyO1xufSkoTm9kZVR5cGUgfHwge30pO1xuXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXJlIHRoZSBzZXJpYWxpemVkIGF0dHJpYnV0ZXMgYW5kIG5vdCBhdHRyaWJ1dGVzIGRpcmVjdGx5IG9uXG4vLyB0aGUgRE9NIE5vZGUuIEF0dHJpYnV0ZXMgd2UgYXJlIGludGVyZXN0ZWQgaW46XG5jb25zdCBBVFRSSUJVVEVTX1RPX1JFQ09SRCA9IG5ldyBTZXQoW1xuICAnaWQnLFxuICAnY2xhc3MnLFxuICAnYXJpYS1sYWJlbCcsXG4gICdyb2xlJyxcbiAgJ25hbWUnLFxuICAnYWx0JyxcbiAgJ3RpdGxlJyxcbiAgJ2RhdGEtdGVzdC1pZCcsXG4gICdkYXRhLXRlc3RpZCcsXG4gICdkaXNhYmxlZCcsXG4gICdhcmlhLWRpc2FibGVkJyxcbiAgJ2RhdGEtc2VudHJ5LWNvbXBvbmVudCcsXG5dKTtcblxuLyoqXG4gKiBJbmNsdXNpb24gbGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgd2Ugd2FudCB0byByZWNvcmQgZnJvbSB0aGUgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlc1RvUmVjb3JkKGF0dHJpYnV0ZXMpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGlmICghYXR0cmlidXRlc1snZGF0YS1zZW50cnktY29tcG9uZW50J10gJiYgYXR0cmlidXRlc1snZGF0YS1zZW50cnktZWxlbWVudCddKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zZW50cnktY29tcG9uZW50J10gPSBhdHRyaWJ1dGVzWydkYXRhLXNlbnRyeS1lbGVtZW50J107XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIGlmIChBVFRSSUJVVEVTX1RPX1JFQ09SRC5oYXMoa2V5KSkge1xuICAgICAgbGV0IG5vcm1hbGl6ZWRLZXkgPSBrZXk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdkYXRhLXRlc3RpZCcgfHwga2V5ID09PSAnZGF0YS10ZXN0LWlkJykge1xuICAgICAgICBub3JtYWxpemVkS2V5ID0gJ3Rlc3RJZCc7XG4gICAgICB9XG5cbiAgICAgIG9ialtub3JtYWxpemVkS2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBoYW5kbGVEb21MaXN0ZW5lciA9IChcbiAgcmVwbGF5LFxuKSA9PiB7XG4gIHJldHVybiAoaGFuZGxlckRhdGEpID0+IHtcbiAgICBpZiAoIXJlcGxheS5pc0VuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGhhbmRsZURvbShoYW5kbGVyRGF0YSk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQ2xpY2sgPSBoYW5kbGVyRGF0YS5uYW1lID09PSAnY2xpY2snO1xuICAgIGNvbnN0IGV2ZW50ID0gaXNDbGljayA/IChoYW5kbGVyRGF0YS5ldmVudCApIDogdW5kZWZpbmVkO1xuICAgIC8vIElnbm9yZSBjbGlja3MgaWYgY3RybC9hbHQvbWV0YS9zaGlmdCBrZXlzIGFyZSBoZWxkIGRvd24gYXMgdGhleSBhbHRlciBiZWhhdmlvciBvZiBjbGlja3MgKGUuZy4gb3BlbiBpbiBuZXcgdGFiKVxuICAgIGlmIChcbiAgICAgIGlzQ2xpY2sgJiZcbiAgICAgIHJlcGxheS5jbGlja0RldGVjdG9yICYmXG4gICAgICBldmVudD8udGFyZ2V0ICYmXG4gICAgICAhZXZlbnQuYWx0S2V5ICYmXG4gICAgICAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgIWV2ZW50LmN0cmxLZXkgJiZcbiAgICAgICFldmVudC5zaGlmdEtleVxuICAgICkge1xuICAgICAgaGFuZGxlQ2xpY2soXG4gICAgICAgIHJlcGxheS5jbGlja0RldGVjdG9yLFxuICAgICAgICByZXN1bHQgLFxuICAgICAgICBnZXRDbGlja1RhcmdldE5vZGUoaGFuZGxlckRhdGEuZXZlbnQgKSAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGFkZEJyZWFkY3J1bWJFdmVudChyZXBsYXksIHJlc3VsdCk7XG4gIH07XG59O1xuXG4vKiogR2V0IHRoZSBiYXNlIERPTSBicmVhZGNydW1iLiAqL1xuZnVuY3Rpb24gZ2V0QmFzZURvbUJyZWFkY3J1bWIodGFyZ2V0LCBtZXNzYWdlKSB7XG4gIGNvbnN0IG5vZGVJZCA9IHJlY29yZC5taXJyb3IuZ2V0SWQodGFyZ2V0KTtcbiAgY29uc3Qgbm9kZSA9IG5vZGVJZCAmJiByZWNvcmQubWlycm9yLmdldE5vZGUobm9kZUlkKTtcbiAgY29uc3QgbWV0YSA9IG5vZGUgJiYgcmVjb3JkLm1pcnJvci5nZXRNZXRhKG5vZGUpO1xuICBjb25zdCBlbGVtZW50ID0gbWV0YSAmJiBpc0VsZW1lbnQobWV0YSkgPyBtZXRhIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgZGF0YTogZWxlbWVudFxuICAgICAgPyB7XG4gICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICB0YWdOYW1lOiBlbGVtZW50LnRhZ05hbWUsXG4gICAgICAgICAgICB0ZXh0Q29udGVudDogQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpXG4gICAgICAgICAgICAgIC5tYXAoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuVGV4dCAmJiBub2RlLnRleHRDb250ZW50KVxuICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pIC8vIGZpbHRlciBvdXQgZW1wdHkgdmFsdWVzXG4gICAgICAgICAgICAgIC5tYXAodGV4dCA9PiAodGV4dCApLnRyaW0oKSlcbiAgICAgICAgICAgICAgLmpvaW4oJycpLFxuICAgICAgICAgICAgYXR0cmlidXRlczogZ2V0QXR0cmlidXRlc1RvUmVjb3JkKGVsZW1lbnQuYXR0cmlidXRlcyksXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgOiB7fSxcbiAgfTtcbn1cblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRvIHJlYWN0IHRvIERPTSBldmVudHMuXG4gKiBFeHBvcnRlZCBmb3IgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURvbShoYW5kbGVyRGF0YSkge1xuICBjb25zdCB7IHRhcmdldCwgbWVzc2FnZSB9ID0gZ2V0RG9tVGFyZ2V0KGhhbmRsZXJEYXRhKTtcblxuICByZXR1cm4gY3JlYXRlQnJlYWRjcnVtYih7XG4gICAgY2F0ZWdvcnk6IGB1aS4ke2hhbmRsZXJEYXRhLm5hbWV9YCxcbiAgICAuLi5nZXRCYXNlRG9tQnJlYWRjcnVtYih0YXJnZXQsIG1lc3NhZ2UpLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9tVGFyZ2V0KGhhbmRsZXJEYXRhKSB7XG4gIGNvbnN0IGlzQ2xpY2sgPSBoYW5kbGVyRGF0YS5uYW1lID09PSAnY2xpY2snO1xuXG4gIGxldCBtZXNzYWdlO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcblxuICAvLyBBY2Nlc3NpbmcgZXZlbnQudGFyZ2V0IGNhbiB0aHJvdyAoc2VlIGdldHNlbnRyeS9yYXZlbi1qcyM4MzgsICM3NjgpXG4gIHRyeSB7XG4gICAgdGFyZ2V0ID0gaXNDbGljayA/IGdldENsaWNrVGFyZ2V0Tm9kZShoYW5kbGVyRGF0YS5ldmVudCApIDogZ2V0VGFyZ2V0Tm9kZShoYW5kbGVyRGF0YS5ldmVudCApO1xuICAgIG1lc3NhZ2UgPSBodG1sVHJlZUFzU3RyaW5nKHRhcmdldCwgeyBtYXhTdHJpbmdMZW5ndGg6IDIwMCB9KSB8fCAnPHVua25vd24+JztcbiAgfSBjYXRjaCB7XG4gICAgbWVzc2FnZSA9ICc8dW5rbm93bj4nO1xuICB9XG5cbiAgcmV0dXJuIHsgdGFyZ2V0LCBtZXNzYWdlIH07XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQ7XG59XG5cbi8qKiBIYW5kbGUga2V5Ym9hcmQgZXZlbnRzICYgY3JlYXRlIGJyZWFkY3J1bWJzLiAqL1xuZnVuY3Rpb24gaGFuZGxlS2V5Ym9hcmRFdmVudChyZXBsYXksIGV2ZW50KSB7XG4gIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVXBkYXRlIHVzZXIgYWN0aXZpdHksIGJ1dCBkbyBub3QgcmVzdGFydCByZWNvcmRpbmcgYXMgaXQgY2FuIGNyZWF0ZVxuICAvLyBub2lzeS9sb3ctdmFsdWUgcmVwbGF5cyAoZS5nLiB1c2VyIGNvbWVzIGJhY2sgZnJvbSBpZGxlLCBoaXRzIGFsdC10YWIsIG5ld1xuICAvLyBzZXNzaW9uIHdpdGggYSBzaW5nbGUgXCJrZXlkb3duXCIgYnJlYWRjcnVtYiBpcyBjcmVhdGVkKVxuICByZXBsYXkudXBkYXRlVXNlckFjdGl2aXR5KCk7XG5cbiAgY29uc3QgYnJlYWRjcnVtYiA9IGdldEtleWJvYXJkQnJlYWRjcnVtYihldmVudCk7XG5cbiAgaWYgKCFicmVhZGNydW1iKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWRkQnJlYWRjcnVtYkV2ZW50KHJlcGxheSwgYnJlYWRjcnVtYik7XG59XG5cbi8qKiBleHBvcnRlZCBvbmx5IGZvciB0ZXN0cyAqL1xuZnVuY3Rpb24gZ2V0S2V5Ym9hcmRCcmVhZGNydW1iKGV2ZW50KSB7XG4gIGNvbnN0IHsgbWV0YUtleSwgc2hpZnRLZXksIGN0cmxLZXksIGFsdEtleSwga2V5LCB0YXJnZXQgfSA9IGV2ZW50O1xuXG4gIC8vIG5ldmVyIGNhcHR1cmUgZm9yIGlucHV0IGZpZWxkc1xuICBpZiAoIXRhcmdldCB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQgKSB8fCAha2V5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOb3RlOiBXZSBkbyBub3QgY29uc2lkZXIgc2hpZnQgaGVyZSwgYXMgdGhhdCBtZWFucyBcInVwcGVyY2FzZVwiXG4gIGNvbnN0IGhhc01vZGlmaWVyS2V5ID0gbWV0YUtleSB8fCBjdHJsS2V5IHx8IGFsdEtleTtcbiAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSBrZXkubGVuZ3RoID09PSAxOyAvLyBvdGhlciBrZXlzIGxpa2UgRXNjYXBlLCBUYWIsIGV0YyBoYXZlIGEgbG9uZ2VyIGxlbmd0aFxuXG4gIC8vIERvIG5vdCBjYXB0dXJlIGJyZWFkY3J1bWIgaWYgb25seSBhIHdvcmQga2V5IGlzIHByZXNzZWRcbiAgLy8gVGhpcyBjb3VsZCBsZWFrIGUuZy4gdXNlciBpbnB1dFxuICBpZiAoIWhhc01vZGlmaWVyS2V5ICYmIGlzQ2hhcmFjdGVyS2V5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gaHRtbFRyZWVBc1N0cmluZyh0YXJnZXQsIHsgbWF4U3RyaW5nTGVuZ3RoOiAyMDAgfSkgfHwgJzx1bmtub3duPic7XG4gIGNvbnN0IGJhc2VCcmVhZGNydW1iID0gZ2V0QmFzZURvbUJyZWFkY3J1bWIodGFyZ2V0ICwgbWVzc2FnZSk7XG5cbiAgcmV0dXJuIGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgIGNhdGVnb3J5OiAndWkua2V5RG93bicsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhOiB7XG4gICAgICAuLi5iYXNlQnJlYWRjcnVtYi5kYXRhLFxuICAgICAgbWV0YUtleSxcbiAgICAgIHNoaWZ0S2V5LFxuICAgICAgY3RybEtleSxcbiAgICAgIGFsdEtleSxcbiAgICAgIGtleSxcbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGU7XG59XG5cbi8vIE1hcCBlbnRyeVR5cGUgLT4gZnVuY3Rpb24gdG8gbm9ybWFsaXplIGRhdGEgZm9yIGV2ZW50XG5jb25zdCBFTlRSWV9UWVBFU1xuXG4gPSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZW50cnkgdHlwZSBkb2VzIG5vdCBmaXQgdGhlIGNyZWF0ZSogZnVuY3Rpb25zIGVudHJ5IHR5cGVcbiAgcmVzb3VyY2U6IGNyZWF0ZVJlc291cmNlRW50cnksXG4gIHBhaW50OiBjcmVhdGVQYWludEVudHJ5LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGVudHJ5IHR5cGUgZG9lcyBub3QgZml0IHRoZSBjcmVhdGUqIGZ1bmN0aW9ucyBlbnRyeSB0eXBlXG4gIG5hdmlnYXRpb246IGNyZWF0ZU5hdmlnYXRpb25FbnRyeSxcbn07XG5cbi8qKlxuICogSGFuZGxlciBjcmVhdGVyIGZvciB3ZWIgdml0YWxzXG4gKi9cbmZ1bmN0aW9uIHdlYlZpdGFsSGFuZGxlcihcbiAgZ2V0dGVyLFxuICByZXBsYXksXG4pIHtcbiAgcmV0dXJuICh7IG1ldHJpYyB9KSA9PiB2b2lkIHJlcGxheS5yZXBsYXlQZXJmb3JtYW5jZUVudHJpZXMucHVzaChnZXR0ZXIobWV0cmljKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHJlcGxheSBwZXJmb3JtYW5jZSBlbnRyaWVzIGZyb20gdGhlIGJyb3dzZXIgcGVyZm9ybWFuY2UgZW50cmllcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGVyZm9ybWFuY2VFbnRyaWVzKFxuICBlbnRyaWVzLFxuKSB7XG4gIHJldHVybiBlbnRyaWVzLm1hcChjcmVhdGVQZXJmb3JtYW5jZUVudHJ5KS5maWx0ZXIoQm9vbGVhbikgO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZXJmb3JtYW5jZUVudHJ5KGVudHJ5KSB7XG4gIGNvbnN0IGVudHJ5VHlwZSA9IEVOVFJZX1RZUEVTW2VudHJ5LmVudHJ5VHlwZV07XG4gIGlmICghZW50cnlUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZW50cnlUeXBlKGVudHJ5KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVUaW1lKHRpbWUpIHtcbiAgLy8gYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiBjYW4gYmUgdW5kZWZpbmVkIGlmIGBwZXJmb3JtYW5jZWAgb3JcbiAgLy8gYHBlcmZvcm1hbmNlLm5vd2AgZG9lc24ndCBleGlzdCwgYnV0IHRoaXMgaXMgYWxyZWFkeSBjaGVja2VkIGJ5IHRoaXMgaW50ZWdyYXRpb25cbiAgcmV0dXJuICgoYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbigpIHx8IFdJTkRPVy5wZXJmb3JtYW5jZS50aW1lT3JpZ2luKSArIHRpbWUpIC8gMTAwMDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFpbnRFbnRyeShlbnRyeSkge1xuICBjb25zdCB7IGR1cmF0aW9uLCBlbnRyeVR5cGUsIG5hbWUsIHN0YXJ0VGltZSB9ID0gZW50cnk7XG5cbiAgY29uc3Qgc3RhcnQgPSBnZXRBYnNvbHV0ZVRpbWUoc3RhcnRUaW1lKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlbnRyeVR5cGUsXG4gICAgbmFtZSxcbiAgICBzdGFydCxcbiAgICBlbmQ6IHN0YXJ0ICsgZHVyYXRpb24sXG4gICAgZGF0YTogdW5kZWZpbmVkLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOYXZpZ2F0aW9uRW50cnkoZW50cnkpIHtcbiAgY29uc3Qge1xuICAgIGVudHJ5VHlwZSxcbiAgICBuYW1lLFxuICAgIGRlY29kZWRCb2R5U2l6ZSxcbiAgICBkdXJhdGlvbixcbiAgICBkb21Db21wbGV0ZSxcbiAgICBlbmNvZGVkQm9keVNpemUsXG4gICAgZG9tQ29udGVudExvYWRlZEV2ZW50U3RhcnQsXG4gICAgZG9tQ29udGVudExvYWRlZEV2ZW50RW5kLFxuICAgIGRvbUludGVyYWN0aXZlLFxuICAgIGxvYWRFdmVudFN0YXJ0LFxuICAgIGxvYWRFdmVudEVuZCxcbiAgICByZWRpcmVjdENvdW50LFxuICAgIHN0YXJ0VGltZSxcbiAgICB0cmFuc2ZlclNpemUsXG4gICAgdHlwZSxcbiAgfSA9IGVudHJ5O1xuXG4gIC8vIElnbm9yZSBlbnRyaWVzIHdpdGggbm8gZHVyYXRpb24sIHRoZXkgZG8gbm90IHNlZW0gdG8gYmUgdXNlZnVsIGFuZCBjYXVzZSBkdXBlc1xuICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogYCR7ZW50cnlUeXBlfS4ke3R5cGV9YCxcbiAgICBzdGFydDogZ2V0QWJzb2x1dGVUaW1lKHN0YXJ0VGltZSksXG4gICAgZW5kOiBnZXRBYnNvbHV0ZVRpbWUoZG9tQ29tcGxldGUpLFxuICAgIG5hbWUsXG4gICAgZGF0YToge1xuICAgICAgc2l6ZTogdHJhbnNmZXJTaXplLFxuICAgICAgZGVjb2RlZEJvZHlTaXplLFxuICAgICAgZW5jb2RlZEJvZHlTaXplLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBkb21JbnRlcmFjdGl2ZSxcbiAgICAgIGRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0LFxuICAgICAgZG9tQ29udGVudExvYWRlZEV2ZW50RW5kLFxuICAgICAgbG9hZEV2ZW50U3RhcnQsXG4gICAgICBsb2FkRXZlbnRFbmQsXG4gICAgICBkb21Db21wbGV0ZSxcbiAgICAgIHJlZGlyZWN0Q291bnQsXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2VFbnRyeShcbiAgZW50cnksXG4pIHtcbiAgY29uc3Qge1xuICAgIGVudHJ5VHlwZSxcbiAgICBpbml0aWF0b3JUeXBlLFxuICAgIG5hbWUsXG4gICAgcmVzcG9uc2VFbmQsXG4gICAgc3RhcnRUaW1lLFxuICAgIGRlY29kZWRCb2R5U2l6ZSxcbiAgICBlbmNvZGVkQm9keVNpemUsXG4gICAgcmVzcG9uc2VTdGF0dXMsXG4gICAgdHJhbnNmZXJTaXplLFxuICB9ID0gZW50cnk7XG5cbiAgLy8gQ29yZSBTREsgaGFuZGxlcyB0aGVzZVxuICBpZiAoWydmZXRjaCcsICd4bWxodHRwcmVxdWVzdCddLmluY2x1ZGVzKGluaXRpYXRvclR5cGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IGAke2VudHJ5VHlwZX0uJHtpbml0aWF0b3JUeXBlfWAsXG4gICAgc3RhcnQ6IGdldEFic29sdXRlVGltZShzdGFydFRpbWUpLFxuICAgIGVuZDogZ2V0QWJzb2x1dGVUaW1lKHJlc3BvbnNlRW5kKSxcbiAgICBuYW1lLFxuICAgIGRhdGE6IHtcbiAgICAgIHNpemU6IHRyYW5zZmVyU2l6ZSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlU3RhdHVzLFxuICAgICAgZGVjb2RlZEJvZHlTaXplLFxuICAgICAgZW5jb2RlZEJvZHlTaXplLFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogQWRkIGEgTENQIGV2ZW50IHRvIHRoZSByZXBsYXkgYmFzZWQgb24gYSBMQ1AgbWV0cmljLlxuICovXG5mdW5jdGlvbiBnZXRMYXJnZXN0Q29udGVudGZ1bFBhaW50KG1ldHJpYykge1xuICBjb25zdCBsYXN0RW50cnkgPSBtZXRyaWMuZW50cmllc1ttZXRyaWMuZW50cmllcy5sZW5ndGggLSAxXSA7XG4gIGNvbnN0IG5vZGUgPSBsYXN0RW50cnk/LmVsZW1lbnQgPyBbbGFzdEVudHJ5LmVsZW1lbnRdIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZ2V0V2ViVml0YWwobWV0cmljLCAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50Jywgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzTGF5b3V0U2hpZnQoZW50cnkpIHtcbiAgcmV0dXJuIChlbnRyeSApLnNvdXJjZXMgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBZGQgYSBDTFMgZXZlbnQgdG8gdGhlIHJlcGxheSBiYXNlZCBvbiBhIENMUyBtZXRyaWMuXG4gKi9cbmZ1bmN0aW9uIGdldEN1bXVsYXRpdmVMYXlvdXRTaGlmdChtZXRyaWMpIHtcbiAgY29uc3QgbGF5b3V0U2hpZnRzID0gW107XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAoY29uc3QgZW50cnkgb2YgbWV0cmljLmVudHJpZXMpIHtcbiAgICBpZiAoaXNMYXlvdXRTaGlmdChlbnRyeSkpIHtcbiAgICAgIGNvbnN0IG5vZGVJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGVudHJ5LnNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5ub2RlKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChzb3VyY2Uubm9kZSk7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gcmVjb3JkLm1pcnJvci5nZXRJZChzb3VyY2Uubm9kZSk7XG4gICAgICAgICAgaWYgKG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZUlkcy5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXlvdXRTaGlmdHMucHVzaCh7IHZhbHVlOiBlbnRyeS52YWx1ZSwgbm9kZUlkczogbm9kZUlkcy5sZW5ndGggPyBub2RlSWRzIDogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRXZWJWaXRhbChtZXRyaWMsICdjdW11bGF0aXZlLWxheW91dC1zaGlmdCcsIG5vZGVzLCBsYXlvdXRTaGlmdHMpO1xufVxuXG4vKipcbiAqIEFkZCBhbiBJTlAgZXZlbnQgdG8gdGhlIHJlcGxheSBiYXNlZCBvbiBhbiBJTlAgbWV0cmljLlxuICovXG5mdW5jdGlvbiBnZXRJbnRlcmFjdGlvblRvTmV4dFBhaW50KG1ldHJpYykge1xuICBjb25zdCBsYXN0RW50cnkgPSBtZXRyaWMuZW50cmllc1ttZXRyaWMuZW50cmllcy5sZW5ndGggLSAxXSA7XG4gIGNvbnN0IG5vZGUgPSBsYXN0RW50cnk/LnRhcmdldCA/IFtsYXN0RW50cnkudGFyZ2V0XSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGdldFdlYlZpdGFsKG1ldHJpYywgJ2ludGVyYWN0aW9uLXRvLW5leHQtcGFpbnQnLCBub2RlKTtcbn1cblxuLyoqXG4gKiBBZGQgYW4gd2ViIHZpdGFsIGV2ZW50IHRvIHRoZSByZXBsYXkgYmFzZWQgb24gdGhlIHdlYiB2aXRhbCBtZXRyaWMuXG4gKi9cbmZ1bmN0aW9uIGdldFdlYlZpdGFsKFxuICBtZXRyaWMsXG4gIG5hbWUsXG4gIG5vZGVzLFxuICBhdHRyaWJ1dGlvbnMsXG4pIHtcbiAgY29uc3QgdmFsdWUgPSBtZXRyaWMudmFsdWU7XG4gIGNvbnN0IHJhdGluZyA9IG1ldHJpYy5yYXRpbmc7XG5cbiAgY29uc3QgZW5kID0gZ2V0QWJzb2x1dGVUaW1lKHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICd3ZWItdml0YWwnLFxuICAgIG5hbWUsXG4gICAgc3RhcnQ6IGVuZCxcbiAgICBlbmQsXG4gICAgZGF0YToge1xuICAgICAgdmFsdWUsXG4gICAgICBzaXplOiB2YWx1ZSxcbiAgICAgIHJhdGluZyxcbiAgICAgIG5vZGVJZHM6IG5vZGVzID8gbm9kZXMubWFwKG5vZGUgPT4gcmVjb3JkLm1pcnJvci5nZXRJZChub2RlKSkgOiB1bmRlZmluZWQsXG4gICAgICBhdHRyaWJ1dGlvbnMsXG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHVwIGEgUGVyZm9ybWFuY2VPYnNlcnZlciB0byBsaXN0ZW4gdG8gYWxsIHBlcmZvcm1hbmNlIGVudHJ5IHR5cGVzLlxuICogUmV0dXJucyBhIGNhbGxiYWNrIHRvIHN0b3Agb2JzZXJ2aW5nLlxuICovXG5mdW5jdGlvbiBzZXR1cFBlcmZvcm1hbmNlT2JzZXJ2ZXIocmVwbGF5KSB7XG4gIGZ1bmN0aW9uIGFkZFBlcmZvcm1hbmNlRW50cnkoZW50cnkpIHtcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgZW50cmllcyB0byBjb21lIHVwIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKCFyZXBsYXkucGVyZm9ybWFuY2VFbnRyaWVzLmluY2x1ZGVzKGVudHJ5KSkge1xuICAgICAgcmVwbGF5LnBlcmZvcm1hbmNlRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVudHJpZXMoeyBlbnRyaWVzIH0pIHtcbiAgICBlbnRyaWVzLmZvckVhY2goYWRkUGVyZm9ybWFuY2VFbnRyeSk7XG4gIH1cblxuICBjb25zdCBjbGVhckNhbGxiYWNrcyA9IFtdO1xuXG4gIChbJ25hdmlnYXRpb24nLCAncGFpbnQnLCAncmVzb3VyY2UnXSApLmZvckVhY2godHlwZSA9PiB7XG4gICAgY2xlYXJDYWxsYmFja3MucHVzaChhZGRQZXJmb3JtYW5jZUluc3RydW1lbnRhdGlvbkhhbmRsZXIodHlwZSwgb25FbnRyaWVzKSk7XG4gIH0pO1xuXG4gIGNsZWFyQ2FsbGJhY2tzLnB1c2goXG4gICAgYWRkTGNwSW5zdHJ1bWVudGF0aW9uSGFuZGxlcih3ZWJWaXRhbEhhbmRsZXIoZ2V0TGFyZ2VzdENvbnRlbnRmdWxQYWludCwgcmVwbGF5KSksXG4gICAgYWRkQ2xzSW5zdHJ1bWVudGF0aW9uSGFuZGxlcih3ZWJWaXRhbEhhbmRsZXIoZ2V0Q3VtdWxhdGl2ZUxheW91dFNoaWZ0LCByZXBsYXkpKSxcbiAgICBhZGRJbnBJbnN0cnVtZW50YXRpb25IYW5kbGVyKHdlYlZpdGFsSGFuZGxlcihnZXRJbnRlcmFjdGlvblRvTmV4dFBhaW50LCByZXBsYXkpKSxcbiAgKTtcblxuICAvLyBBIGNhbGxiYWNrIHRvIGNsZWFudXAgYWxsIGhhbmRsZXJzXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJDYWxsYmFja3MuZm9yRWFjaChjbGVhckNhbGxiYWNrID0+IGNsZWFyQ2FsbGJhY2soKSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogQVRURU5USU9OOiBUaGlzIGNvbnN0YW50IG11c3QgbmV2ZXIgY3Jvc3MgcGFja2FnZSBib3VuZGFyaWVzIChpLmUuIGJlIGV4cG9ydGVkKSB0byBndWFyYW50ZWUgdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3IgdHJlZSBzaGFraW5nLlxuICovXG5jb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7XG5cbmNvbnN0IHIgPSBgdmFyIHQ9VWludDhBcnJheSxuPVVpbnQxNkFycmF5LHI9SW50MzJBcnJheSxlPW5ldyB0KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxpPW5ldyB0KFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLHM9bmV3IHQoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxhPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPW5ldyBuKDMxKSxzPTA7czwzMTsrK3MpaVtzXT1lKz0xPDx0W3MtMV07dmFyIGE9bmV3IHIoaVszMF0pO2ZvcihzPTE7czwzMDsrK3MpZm9yKHZhciBvPWlbc107bzxpW3MrMV07KytvKWFbb109by1pW3NdPDw1fHM7cmV0dXJue2I6aSxyOmF9fSxvPWEoZSwyKSxoPW8uYixmPW8ucjtoWzI4XT0yNTgsZlsyNThdPTI4O2Zvcih2YXIgbD1hKGksMCkucix1PW5ldyBuKDMyNzY4KSxjPTA7YzwzMjc2ODsrK2Mpe3ZhciB2PSg0MzY5MCZjKT4+MXwoMjE4NDUmYyk8PDE7dj0oNjE2ODAmKHY9KDUyNDI4JnYpPj4yfCgxMzEwNyZ2KTw8MikpPj40fCgzODU1JnYpPDw0LHVbY109KCg2NTI4MCZ2KT4+OHwoMjU1JnYpPDw4KT4+MX12YXIgZD1mdW5jdGlvbih0LHIsZSl7Zm9yKHZhciBpPXQubGVuZ3RoLHM9MCxhPW5ldyBuKHIpO3M8aTsrK3MpdFtzXSYmKythW3Rbc10tMV07dmFyIG8saD1uZXcgbihyKTtmb3Iocz0xO3M8cjsrK3MpaFtzXT1oW3MtMV0rYVtzLTFdPDwxO2lmKGUpe289bmV3IG4oMTw8cik7dmFyIGY9MTUtcjtmb3Iocz0wO3M8aTsrK3MpaWYodFtzXSlmb3IodmFyIGw9czw8NHx0W3NdLGM9ci10W3NdLHY9aFt0W3NdLTFdKys8PGMsZD12fCgxPDxjKS0xO3Y8PWQ7Kyt2KW9bdVt2XT4+Zl09bH1lbHNlIGZvcihvPW5ldyBuKGkpLHM9MDtzPGk7KytzKXRbc10mJihvW3NdPXVbaFt0W3NdLTFdKytdPj4xNS10W3NdKTtyZXR1cm4gb30scD1uZXcgdCgyODgpO2ZvcihjPTA7YzwxNDQ7KytjKXBbY109ODtmb3IoYz0xNDQ7YzwyNTY7KytjKXBbY109OTtmb3IoYz0yNTY7YzwyODA7KytjKXBbY109Nztmb3IoYz0yODA7YzwyODg7KytjKXBbY109ODt2YXIgZz1uZXcgdCgzMik7Zm9yKGM9MDtjPDMyOysrYylnW2NdPTU7dmFyIHc9ZChwLDksMCkseT1kKGcsNSwwKSxtPWZ1bmN0aW9uKHQpe3JldHVybih0KzcpLzh8MH0sYj1mdW5jdGlvbihuLHIsZSl7cmV0dXJuKG51bGw9PWV8fGU+bi5sZW5ndGgpJiYoZT1uLmxlbmd0aCksbmV3IHQobi5zdWJhcnJheShyLGUpKX0sTT1bXCJ1bmV4cGVjdGVkIEVPRlwiLFwiaW52YWxpZCBibG9jayB0eXBlXCIsXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCIsXCJpbnZhbGlkIGRpc3RhbmNlXCIsXCJzdHJlYW0gZmluaXNoZWRcIixcIm5vIHN0cmVhbSBoYW5kbGVyXCIsLFwibm8gY2FsbGJhY2tcIixcImludmFsaWQgVVRGLTggZGF0YVwiLFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIixcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFwiZmlsZW5hbWUgdG9vIGxvbmdcIixcInN0cmVhbSBmaW5pc2hpbmdcIixcImludmFsaWQgemlwIGRhdGFcIl0sRT1mdW5jdGlvbih0LG4scil7dmFyIGU9bmV3IEVycm9yKG58fE1bdF0pO2lmKGUuY29kZT10LEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlLEUpLCFyKXRocm93IGU7cmV0dXJuIGV9LHo9ZnVuY3Rpb24odCxuLHIpe3I8PD03Jm47dmFyIGU9bi84fDA7dFtlXXw9cix0W2UrMV18PXI+Pjh9LF89ZnVuY3Rpb24odCxuLHIpe3I8PD03Jm47dmFyIGU9bi84fDA7dFtlXXw9cix0W2UrMV18PXI+PjgsdFtlKzJdfD1yPj4xNn0seD1mdW5jdGlvbihyLGUpe2Zvcih2YXIgaT1bXSxzPTA7czxyLmxlbmd0aDsrK3MpcltzXSYmaS5wdXNoKHtzOnMsZjpyW3NdfSk7dmFyIGE9aS5sZW5ndGgsbz1pLnNsaWNlKCk7aWYoIWEpcmV0dXJue3Q6RixsOjB9O2lmKDE9PWEpe3ZhciBoPW5ldyB0KGlbMF0ucysxKTtyZXR1cm4gaFtpWzBdLnNdPTEse3Q6aCxsOjF9fWkuc29ydChmdW5jdGlvbih0LG4pe3JldHVybiB0LmYtbi5mfSksaS5wdXNoKHtzOi0xLGY6MjUwMDF9KTt2YXIgZj1pWzBdLGw9aVsxXSx1PTAsYz0xLHY9Mjtmb3IoaVswXT17czotMSxmOmYuZitsLmYsbDpmLHI6bH07YyE9YS0xOylmPWlbaVt1XS5mPGlbdl0uZj91Kys6disrXSxsPWlbdSE9YyYmaVt1XS5mPGlbdl0uZj91Kys6disrXSxpW2MrK109e3M6LTEsZjpmLmYrbC5mLGw6ZixyOmx9O3ZhciBkPW9bMF0ucztmb3Iocz0xO3M8YTsrK3Mpb1tzXS5zPmQmJihkPW9bc10ucyk7dmFyIHA9bmV3IG4oZCsxKSxnPUEoaVtjLTFdLHAsMCk7aWYoZz5lKXtzPTA7dmFyIHc9MCx5PWctZSxtPTE8PHk7Zm9yKG8uc29ydChmdW5jdGlvbih0LG4pe3JldHVybiBwW24uc10tcFt0LnNdfHx0LmYtbi5mfSk7czxhOysrcyl7dmFyIGI9b1tzXS5zO2lmKCEocFtiXT5lKSlicmVhazt3Kz1tLSgxPDxnLXBbYl0pLHBbYl09ZX1mb3Iodz4+PXk7dz4wOyl7dmFyIE09b1tzXS5zO3BbTV08ZT93LT0xPDxlLXBbTV0rKy0xOisrc31mb3IoO3M+PTAmJnc7LS1zKXt2YXIgRT1vW3NdLnM7cFtFXT09ZSYmKC0tcFtFXSwrK3cpfWc9ZX1yZXR1cm57dDpuZXcgdChwKSxsOmd9fSxBPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4tMT09dC5zP01hdGgubWF4KEEodC5sLG4scisxKSxBKHQucixuLHIrMSkpOm5bdC5zXT1yfSxEPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10Lmxlbmd0aDtyJiYhdFstLXJdOyk7Zm9yKHZhciBlPW5ldyBuKCsrciksaT0wLHM9dFswXSxhPTEsbz1mdW5jdGlvbih0KXtlW2krK109dH0saD0xO2g8PXI7KytoKWlmKHRbaF09PXMmJmghPXIpKythO2Vsc2V7aWYoIXMmJmE+Mil7Zm9yKDthPjEzODthLT0xMzgpbygzMjc1NCk7YT4yJiYobyhhPjEwP2EtMTE8PDV8Mjg2OTA6YS0zPDw1fDEyMzA1KSxhPTApfWVsc2UgaWYoYT4zKXtmb3IobyhzKSwtLWE7YT42O2EtPTYpbyg4MzA0KTthPjImJihvKGEtMzw8NXw4MjA4KSxhPTApfWZvcig7YS0tOylvKHMpO2E9MSxzPXRbaF19cmV0dXJue2M6ZS5zdWJhcnJheSgwLGkpLG46cn19LFQ9ZnVuY3Rpb24odCxuKXtmb3IodmFyIHI9MCxlPTA7ZTxuLmxlbmd0aDsrK2Upcis9dFtlXSpuW2VdO3JldHVybiByfSxrPWZ1bmN0aW9uKHQsbixyKXt2YXIgZT1yLmxlbmd0aCxpPW0obisyKTt0W2ldPTI1NSZlLHRbaSsxXT1lPj44LHRbaSsyXT0yNTVedFtpXSx0W2krM109MjU1XnRbaSsxXTtmb3IodmFyIHM9MDtzPGU7KytzKXRbaStzKzRdPXJbc107cmV0dXJuIDgqKGkrNCtlKX0sVT1mdW5jdGlvbih0LHIsYSxvLGgsZixsLHUsYyx2LG0pe3oocixtKyssYSksKytoWzI1Nl07Zm9yKHZhciBiPXgoaCwxNSksTT1iLnQsRT1iLmwsQT14KGYsMTUpLFU9QS50LEM9QS5sLEY9RChNKSxJPUYuYyxTPUYubixMPUQoVSksTz1MLmMsaj1MLm4scT1uZXcgbigxOSksQj0wO0I8SS5sZW5ndGg7KytCKSsrcVszMSZJW0JdXTtmb3IoQj0wO0I8Ty5sZW5ndGg7KytCKSsrcVszMSZPW0JdXTtmb3IodmFyIEc9eChxLDcpLEg9Ry50LEo9Ry5sLEs9MTk7Sz40JiYhSFtzW0stMV1dOy0tSyk7dmFyIE4sUCxRLFIsVj12KzU8PDMsVz1UKGgscCkrVChmLGcpK2wsWD1UKGgsTSkrVChmLFUpK2wrMTQrMypLK1QocSxIKSsyKnFbMTZdKzMqcVsxN10rNypxWzE4XTtpZihjPj0wJiZWPD1XJiZWPD1YKXJldHVybiBrKHIsbSx0LnN1YmFycmF5KGMsYyt2KSk7aWYoeihyLG0sMSsoWDxXKSksbSs9MixYPFcpe049ZChNLEUsMCksUD1NLFE9ZChVLEMsMCksUj1VO3ZhciBZPWQoSCxKLDApO3oocixtLFMtMjU3KSx6KHIsbSs1LGotMSkseihyLG0rMTAsSy00KSxtKz0xNDtmb3IoQj0wO0I8SzsrK0IpeihyLG0rMypCLEhbc1tCXV0pO20rPTMqSztmb3IodmFyIFo9W0ksT10sJD0wOyQ8MjsrKyQpe3ZhciB0dD1aWyRdO2ZvcihCPTA7Qjx0dC5sZW5ndGg7KytCKXt2YXIgbnQ9MzEmdHRbQl07eihyLG0sWVtudF0pLG0rPUhbbnRdLG50PjE1JiYoeihyLG0sdHRbQl0+PjUmMTI3KSxtKz10dFtCXT4+MTIpfX19ZWxzZSBOPXcsUD1wLFE9eSxSPWc7Zm9yKEI9MDtCPHU7KytCKXt2YXIgcnQ9b1tCXTtpZihydD4yNTUpe18ocixtLE5bKG50PXJ0Pj4xOCYzMSkrMjU3XSksbSs9UFtudCsyNTddLG50PjcmJih6KHIsbSxydD4+MjMmMzEpLG0rPWVbbnRdKTt2YXIgZXQ9MzEmcnQ7XyhyLG0sUVtldF0pLG0rPVJbZXRdLGV0PjMmJihfKHIsbSxydD4+NSY4MTkxKSxtKz1pW2V0XSl9ZWxzZSBfKHIsbSxOW3J0XSksbSs9UFtydF19cmV0dXJuIF8ocixtLE5bMjU2XSksbStQWzI1Nl19LEM9bmV3IHIoWzY1NTQwLDEzMTA4MCwxMzEwODgsMTMxMTA0LDI2MjE3NiwxMDQ4NzA0LDEwNDg4MzIsMjExNDU2MCwyMTE3NjMyXSksRj1uZXcgdCgwKSxJPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJbnQzMkFycmF5KDI1Niksbj0wO248MjU2Oysrbil7Zm9yKHZhciByPW4sZT05Oy0tZTspcj0oMSZyJiYtMzA2Njc0OTEyKV5yPj4+MTt0W25dPXJ9cmV0dXJuIHR9KCksUz1mdW5jdGlvbigpe3ZhciB0PTEsbj0wO3JldHVybntwOmZ1bmN0aW9uKHIpe2Zvcih2YXIgZT10LGk9bixzPTB8ci5sZW5ndGgsYT0wO2EhPXM7KXtmb3IodmFyIG89TWF0aC5taW4oYSsyNjU1LHMpO2E8bzsrK2EpaSs9ZSs9clthXTtlPSg2NTUzNSZlKSsxNSooZT4+MTYpLGk9KDY1NTM1JmkpKzE1KihpPj4xNil9dD1lLG49aX0sZDpmdW5jdGlvbigpe3JldHVybigyNTUmKHQlPTY1NTIxKSk8PDI0fCg2NTI4MCZ0KTw8OHwoMjU1JihuJT02NTUyMSkpPDw4fG4+Pjh9fX0sTD1mdW5jdGlvbihzLGEsbyxoLHUpe2lmKCF1JiYodT17bDoxfSxhLmRpY3Rpb25hcnkpKXt2YXIgYz1hLmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KSx2PW5ldyB0KGMubGVuZ3RoK3MubGVuZ3RoKTt2LnNldChjKSx2LnNldChzLGMubGVuZ3RoKSxzPXYsdS53PWMubGVuZ3RofXJldHVybiBmdW5jdGlvbihzLGEsbyxoLHUsYyl7dmFyIHY9Yy56fHxzLmxlbmd0aCxkPW5ldyB0KGgrdis1KigxK01hdGguY2VpbCh2LzdlMykpK3UpLHA9ZC5zdWJhcnJheShoLGQubGVuZ3RoLXUpLGc9Yy5sLHc9NyYoYy5yfHwwKTtpZihhKXt3JiYocFswXT1jLnI+PjMpO2Zvcih2YXIgeT1DW2EtMV0sTT15Pj4xMyxFPTgxOTEmeSx6PSgxPDxvKS0xLF89Yy5wfHxuZXcgbigzMjc2OCkseD1jLmh8fG5ldyBuKHorMSksQT1NYXRoLmNlaWwoby8zKSxEPTIqQSxUPWZ1bmN0aW9uKHQpe3JldHVybihzW3RdXnNbdCsxXTw8QV5zW3QrMl08PEQpJnp9LEY9bmV3IHIoMjVlMyksST1uZXcgbigyODgpLFM9bmV3IG4oMzIpLEw9MCxPPTAsaj1jLml8fDAscT0wLEI9Yy53fHwwLEc9MDtqKzI8djsrK2ope3ZhciBIPVQoaiksSj0zMjc2NyZqLEs9eFtIXTtpZihfW0pdPUsseFtIXT1KLEI8PWope3ZhciBOPXYtajtpZigoTD43ZTN8fHE+MjQ1NzYpJiYoTj40MjN8fCFnKSl7dz1VKHMscCwwLEYsSSxTLE8scSxHLGotRyx3KSxxPUw9Tz0wLEc9ajtmb3IodmFyIFA9MDtQPDI4NjsrK1ApSVtQXT0wO2ZvcihQPTA7UDwzMDsrK1ApU1tQXT0wfXZhciBRPTIsUj0wLFY9RSxXPUotSyYzMjc2NztpZihOPjImJkg9PVQoai1XKSlmb3IodmFyIFg9TWF0aC5taW4oTSxOKS0xLFk9TWF0aC5taW4oMzI3NjcsaiksWj1NYXRoLm1pbigyNTgsTik7Vzw9WSYmLS1WJiZKIT1LOyl7aWYoc1tqK1FdPT1zW2orUS1XXSl7Zm9yKHZhciAkPTA7JDxaJiZzW2orJF09PXNbaiskLVddOysrJCk7aWYoJD5RKXtpZihRPSQsUj1XLCQ+WClicmVhazt2YXIgdHQ9TWF0aC5taW4oVywkLTIpLG50PTA7Zm9yKFA9MDtQPHR0OysrUCl7dmFyIHJ0PWotVytQJjMyNzY3LGV0PXJ0LV9bcnRdJjMyNzY3O2V0Pm50JiYobnQ9ZXQsSz1ydCl9fX1XKz0oSj1LKS0oSz1fW0pdKSYzMjc2N31pZihSKXtGW3ErK109MjY4NDM1NDU2fGZbUV08PDE4fGxbUl07dmFyIGl0PTMxJmZbUV0sc3Q9MzEmbFtSXTtPKz1lW2l0XStpW3N0XSwrK0lbMjU3K2l0XSwrK1Nbc3RdLEI9aitRLCsrTH1lbHNlIEZbcSsrXT1zW2pdLCsrSVtzW2pdXX19Zm9yKGo9TWF0aC5tYXgoaixCKTtqPHY7KytqKUZbcSsrXT1zW2pdLCsrSVtzW2pdXTt3PVUocyxwLGcsRixJLFMsTyxxLEcsai1HLHcpLGd8fChjLnI9NyZ3fHBbdy84fDBdPDwzLHctPTcsYy5oPXgsYy5wPV8sYy5pPWosYy53PUIpfWVsc2V7Zm9yKGo9Yy53fHwwO2o8ditnO2orPTY1NTM1KXt2YXIgYXQ9ais2NTUzNTthdD49diYmKHBbdy84fDBdPWcsYXQ9diksdz1rKHAsdysxLHMuc3ViYXJyYXkoaixhdCkpfWMuaT12fXJldHVybiBiKGQsMCxoK20odykrdSl9KHMsbnVsbD09YS5sZXZlbD82OmEubGV2ZWwsbnVsbD09YS5tZW0/dS5sP01hdGguY2VpbCgxLjUqTWF0aC5tYXgoOCxNYXRoLm1pbigxMyxNYXRoLmxvZyhzLmxlbmd0aCkpKSk6MjA6MTIrYS5tZW0sbyxoLHUpfSxPPWZ1bmN0aW9uKHQsbixyKXtmb3IoO3I7KytuKXRbbl09cixyPj4+PTh9LGo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4scil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKHI9bixuPXt9KSx0aGlzLm9uZGF0YT1yLHRoaXMubz1ufHx7fSx0aGlzLnM9e2w6MCxpOjMyNzY4LHc6MzI3NjgsejozMjc2OH0sdGhpcy5iPW5ldyB0KDk4MzA0KSx0aGlzLm8uZGljdGlvbmFyeSl7dmFyIGU9dGhpcy5vLmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KTt0aGlzLmIuc2V0KGUsMzI3NjgtZS5sZW5ndGgpLHRoaXMucy5pPTMyNzY4LWUubGVuZ3RofX1yZXR1cm4gbi5wcm90b3R5cGUucD1mdW5jdGlvbih0LG4pe3RoaXMub25kYXRhKEwodCx0aGlzLm8sMCwwLHRoaXMucyksbil9LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24obixyKXt0aGlzLm9uZGF0YXx8RSg1KSx0aGlzLnMubCYmRSg0KTt2YXIgZT1uLmxlbmd0aCt0aGlzLnMuejtpZihlPnRoaXMuYi5sZW5ndGgpe2lmKGU+Mip0aGlzLmIubGVuZ3RoLTMyNzY4KXt2YXIgaT1uZXcgdCgtMzI3NjgmZSk7aS5zZXQodGhpcy5iLnN1YmFycmF5KDAsdGhpcy5zLnopKSx0aGlzLmI9aX12YXIgcz10aGlzLmIubGVuZ3RoLXRoaXMucy56O3RoaXMuYi5zZXQobi5zdWJhcnJheSgwLHMpLHRoaXMucy56KSx0aGlzLnMuej10aGlzLmIubGVuZ3RoLHRoaXMucCh0aGlzLmIsITEpLHRoaXMuYi5zZXQodGhpcy5iLnN1YmFycmF5KC0zMjc2OCkpLHRoaXMuYi5zZXQobi5zdWJhcnJheShzKSwzMjc2OCksdGhpcy5zLno9bi5sZW5ndGgtcyszMjc2OCx0aGlzLnMuaT0zMjc2Nix0aGlzLnMudz0zMjc2OH1lbHNlIHRoaXMuYi5zZXQobix0aGlzLnMueiksdGhpcy5zLnorPW4ubGVuZ3RoO3RoaXMucy5sPTEmciwodGhpcy5zLno+dGhpcy5zLncrODE5MXx8cikmJih0aGlzLnAodGhpcy5iLHJ8fCExKSx0aGlzLnMudz10aGlzLnMuaSx0aGlzLnMuaS09Mil9LG4ucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7dGhpcy5vbmRhdGF8fEUoNSksdGhpcy5zLmwmJkUoNCksdGhpcy5wKHRoaXMuYiwhMSksdGhpcy5zLnc9dGhpcy5zLmksdGhpcy5zLmktPTJ9LG59KCk7ZnVuY3Rpb24gcSh0LG4pe258fChuPXt9KTt2YXIgcj1mdW5jdGlvbigpe3ZhciB0PS0xO3JldHVybntwOmZ1bmN0aW9uKG4pe2Zvcih2YXIgcj10LGU9MDtlPG4ubGVuZ3RoOysrZSlyPUlbMjU1JnJebltlXV1ecj4+Pjg7dD1yfSxkOmZ1bmN0aW9uKCl7cmV0dXJufnR9fX0oKSxlPXQubGVuZ3RoO3IucCh0KTt2YXIgaSxzPUwodCxuLDEwKygoaT1uKS5maWxlbmFtZT9pLmZpbGVuYW1lLmxlbmd0aCsxOjApLDgpLGE9cy5sZW5ndGg7cmV0dXJuIGZ1bmN0aW9uKHQsbil7dmFyIHI9bi5maWxlbmFtZTtpZih0WzBdPTMxLHRbMV09MTM5LHRbMl09OCx0WzhdPW4ubGV2ZWw8Mj80Ojk9PW4ubGV2ZWw/MjowLHRbOV09MywwIT1uLm10aW1lJiZPKHQsNCxNYXRoLmZsb29yKG5ldyBEYXRlKG4ubXRpbWV8fERhdGUubm93KCkpLzFlMykpLHIpe3RbM109ODtmb3IodmFyIGU9MDtlPD1yLmxlbmd0aDsrK2UpdFtlKzEwXT1yLmNoYXJDb2RlQXQoZSl9fShzLG4pLE8ocyxhLTgsci5kKCkpLE8ocyxhLTQsZSksc312YXIgQj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuKXt0aGlzLmM9UygpLHRoaXMudj0xLGouY2FsbCh0aGlzLHQsbil9cmV0dXJuIHQucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxuKXt0aGlzLmMucCh0KSxqLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyx0LG4pfSx0LnByb3RvdHlwZS5wPWZ1bmN0aW9uKHQsbil7dmFyIHI9TCh0LHRoaXMubyx0aGlzLnYmJih0aGlzLm8uZGljdGlvbmFyeT82OjIpLG4mJjQsdGhpcy5zKTt0aGlzLnYmJihmdW5jdGlvbih0LG4pe3ZhciByPW4ubGV2ZWwsZT0wPT1yPzA6cjw2PzE6OT09cj8zOjI7aWYodFswXT0xMjAsdFsxXT1lPDw2fChuLmRpY3Rpb25hcnkmJjMyKSx0WzFdfD0zMS0odFswXTw8OHx0WzFdKSUzMSxuLmRpY3Rpb25hcnkpe3ZhciBpPVMoKTtpLnAobi5kaWN0aW9uYXJ5KSxPKHQsMixpLmQoKSl9fShyLHRoaXMubyksdGhpcy52PTApLG4mJk8ocixyLmxlbmd0aC00LHRoaXMuYy5kKCkpLHRoaXMub25kYXRhKHIsbil9LHQucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7ai5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKX0sdH0oKSxHPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RW5jb2RlciYmbmV3IFRleHRFbmNvZGVyLEg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXI7dHJ5e0guZGVjb2RlKEYse3N0cmVhbTohMH0pfWNhdGNoKHQpe312YXIgSj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vbmRhdGE9dH1yZXR1cm4gdC5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LG4pe3RoaXMub25kYXRhfHxFKDUpLHRoaXMuZCYmRSg0KSx0aGlzLm9uZGF0YShLKHQpLHRoaXMuZD1ufHwhMSl9LHR9KCk7ZnVuY3Rpb24gSyhuLHIpe2lmKEcpcmV0dXJuIEcuZW5jb2RlKG4pO2Zvcih2YXIgZT1uLmxlbmd0aCxpPW5ldyB0KG4ubGVuZ3RoKyhuLmxlbmd0aD4+MSkpLHM9MCxhPWZ1bmN0aW9uKHQpe2lbcysrXT10fSxvPTA7bzxlOysrbyl7aWYocys1PmkubGVuZ3RoKXt2YXIgaD1uZXcgdChzKzgrKGUtbzw8MSkpO2guc2V0KGkpLGk9aH12YXIgZj1uLmNoYXJDb2RlQXQobyk7ZjwxMjh8fHI/YShmKTpmPDIwNDg/KGEoMTkyfGY+PjYpLGEoMTI4fDYzJmYpKTpmPjU1Mjk1JiZmPDU3MzQ0PyhhKDI0MHwoZj02NTUzNisoMTA0NzU1MiZmKXwxMDIzJm4uY2hhckNvZGVBdCgrK28pKT4+MTgpLGEoMTI4fGY+PjEyJjYzKSxhKDEyOHxmPj42JjYzKSxhKDEyOHw2MyZmKSk6KGEoMjI0fGY+PjEyKSxhKDEyOHxmPj42JjYzKSxhKDEyOHw2MyZmKSl9cmV0dXJuIGIoaSwwLHMpfWNvbnN0IE49bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5faW5pdCgpfWNsZWFyKCl7dGhpcy5faW5pdCgpfWFkZEV2ZW50KHQpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkFkZGluZyBpbnZhbGlkIGV2ZW50XCIpO2NvbnN0IG49dGhpcy5faGFzRXZlbnRzP1wiLFwiOlwiXCI7dGhpcy5zdHJlYW0ucHVzaChuK3QpLHRoaXMuX2hhc0V2ZW50cz0hMH1maW5pc2goKXt0aGlzLnN0cmVhbS5wdXNoKFwiXVwiLCEwKTtjb25zdCB0PWZ1bmN0aW9uKHQpe2xldCBuPTA7Zm9yKGNvbnN0IHIgb2YgdCluKz1yLmxlbmd0aDtjb25zdCByPW5ldyBVaW50OEFycmF5KG4pO2ZvcihsZXQgbj0wLGU9MCxpPXQubGVuZ3RoO248aTtuKyspe2NvbnN0IGk9dFtuXTtyLnNldChpLGUpLGUrPWkubGVuZ3RofXJldHVybiByfSh0aGlzLl9kZWZsYXRlZERhdGEpO3JldHVybiB0aGlzLl9pbml0KCksdH1faW5pdCgpe3RoaXMuX2hhc0V2ZW50cz0hMSx0aGlzLl9kZWZsYXRlZERhdGE9W10sdGhpcy5kZWZsYXRlPW5ldyBCLHRoaXMuZGVmbGF0ZS5vbmRhdGE9KHQsbik9Pnt0aGlzLl9kZWZsYXRlZERhdGEucHVzaCh0KX0sdGhpcy5zdHJlYW09bmV3IEooKHQsbik9Pnt0aGlzLmRlZmxhdGUucHVzaCh0LG4pfSksdGhpcy5zdHJlYW0ucHVzaChcIltcIil9fSxQPXtjbGVhcjooKT0+e04uY2xlYXIoKX0sYWRkRXZlbnQ6dD0+Ti5hZGRFdmVudCh0KSxmaW5pc2g6KCk9Pk4uZmluaXNoKCksY29tcHJlc3M6dD0+ZnVuY3Rpb24odCl7cmV0dXJuIHEoSyh0KSl9KHQpfTthZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKHQpe2NvbnN0IG49dC5kYXRhLm1ldGhvZCxyPXQuZGF0YS5pZCxlPXQuZGF0YS5hcmc7aWYobiBpbiBQJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBQW25dKXRyeXtjb25zdCB0PVBbbl0oZSk7cG9zdE1lc3NhZ2Uoe2lkOnIsbWV0aG9kOm4sc3VjY2VzczohMCxyZXNwb25zZTp0fSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe2lkOnIsbWV0aG9kOm4sc3VjY2VzczohMSxyZXNwb25zZTp0Lm1lc3NhZ2V9KSxjb25zb2xlLmVycm9yKHQpfX0pLHBvc3RNZXNzYWdlKHtpZDp2b2lkIDAsbWV0aG9kOlwiaW5pdFwiLHN1Y2Nlc3M6ITAscmVzcG9uc2U6dm9pZCAwfSk7YDtcblxuZnVuY3Rpb24gZSgpe2NvbnN0IGU9bmV3IEJsb2IoW3JdKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChlKX1cblxuY29uc3QgQ09OU09MRV9MRVZFTFMgPSBbJ2xvZycsICd3YXJuJywgJ2Vycm9yJ10gO1xuY29uc3QgUFJFRklYID0gJ1tSZXBsYXldICc7XG5cbmZ1bmN0aW9uIF9hZGRCcmVhZGNydW1iKG1lc3NhZ2UsIGxldmVsID0gJ2luZm8nKSB7XG4gIGFkZEJyZWFkY3J1bWIoXG4gICAge1xuICAgICAgY2F0ZWdvcnk6ICdjb25zb2xlJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbG9nZ2VyOiAncmVwbGF5JyxcbiAgICAgIH0sXG4gICAgICBsZXZlbCxcbiAgICAgIG1lc3NhZ2U6IGAke1BSRUZJWH0ke21lc3NhZ2V9YCxcbiAgICB9LFxuICAgIHsgbGV2ZWwgfSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlcGxheURlYnVnTG9nZ2VyKCkge1xuICBsZXQgX2NhcHR1cmUgPSBmYWxzZTtcbiAgbGV0IF90cmFjZSA9IGZhbHNlO1xuXG4gIGNvbnN0IF9kZWJ1ZyA9IHtcbiAgICBleGNlcHRpb246ICgpID0+IHVuZGVmaW5lZCxcbiAgICBpbmZvVGljazogKCkgPT4gdW5kZWZpbmVkLFxuICAgIHNldENvbmZpZzogKG9wdHMpID0+IHtcbiAgICAgIF9jYXB0dXJlID0gISFvcHRzLmNhcHR1cmVFeGNlcHRpb25zO1xuICAgICAgX3RyYWNlID0gISFvcHRzLnRyYWNlSW50ZXJuYWxzO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKERFQlVHX0JVSUxEKSB7XG4gICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIF9kZWJ1Z1tuYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGRlYnVnJDFbbmFtZV0oUFJFRklYLCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKF90cmFjZSkge1xuICAgICAgICAgIF9hZGRCcmVhZGNydW1iKGFyZ3Muam9pbignJyksIHNldmVyaXR5TGV2ZWxGcm9tU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIF9kZWJ1Zy5leGNlcHRpb24gPSAoZXJyb3IsIC4uLm1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCAmJiBfZGVidWcuZXJyb3IpIHtcbiAgICAgICAgX2RlYnVnLmVycm9yKC4uLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyQxLmVycm9yKFBSRUZJWCwgZXJyb3IpO1xuXG4gICAgICBpZiAoX2NhcHR1cmUpIHtcbiAgICAgICAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvciwge1xuICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdhdXRvLmZ1bmN0aW9uLnJlcGxheS5kZWJ1ZycsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF90cmFjZSkge1xuICAgICAgICAvLyBObyBuZWVkIGZvciBhIGJyZWFkY3J1bWIgaWYgYF9jYXB0dXJlYCBpcyBlbmFibGVkIHNpbmNlIGl0IHNob3VsZCBiZVxuICAgICAgICAvLyBjYXB0dXJlZCBhcyBhbiBleGNlcHRpb25cbiAgICAgICAgX2FkZEJyZWFkY3J1bWIoZXJyb3IsICdlcnJvcicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfZGVidWcuaW5mb1RpY2sgPSAoLi4uYXJncykgPT4ge1xuICAgICAgZGVidWckMS5sb2coUFJFRklYLCAuLi5hcmdzKTtcbiAgICAgIGlmIChfdHJhY2UpIHtcbiAgICAgICAgLy8gV2FpdCBhIHRpY2sgaGVyZSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgZm9yIHNvbWUgaW5pdGlhbCBsb2dzXG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBhZGRlZCBiZWZvcmUgcmVwbGF5IGlzIGluaXRpYWxpemVkXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gX2FkZEJyZWFkY3J1bWIoYXJnc1swXSksIDApO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIF9kZWJ1Z1tuYW1lXSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBfZGVidWcgO1xufVxuXG5jb25zdCBkZWJ1ZyA9IG1ha2VSZXBsYXlEZWJ1Z0xvZ2dlcigpO1xuXG4vKiogVGhpcyBlcnJvciBpbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgYnVmZmVyIHNpemUgZXhjZWVkZWQgdGhlIGxpbWl0Li4gKi9cbmNsYXNzIEV2ZW50QnVmZmVyU2l6ZUV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgRXZlbnQgYnVmZmVyIGV4Y2VlZGVkIG1heGltdW0gc2l6ZSBvZiAke1JFUExBWV9NQVhfRVZFTlRfQlVGRkVSX1NJWkV9LmApO1xuICB9XG59XG5cbi8qKlxuICogQSBiYXNpYyBldmVudCBidWZmZXIgdGhhdCBkb2VzIG5vdCBkbyBhbnkgY29tcHJlc3Npb24uXG4gKiBVc2VkIGFzIGZhbGxiYWNrIGlmIHRoZSBjb21wcmVzc2lvbiB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBvciBpcyBkaXNhYmxlZC5cbiAqL1xuY2xhc3MgRXZlbnRCdWZmZXJBcnJheSAge1xuICAvKiogQWxsIHRoZSBldmVudHMgdGhhdCBhcmUgYnVmZmVyZWQgdG8gYmUgc2VudC4gKi9cblxuICAvKiogQGluaGVyaXRkb2MgKi9cblxuICAvKiogQGluaGVyaXRkb2MgKi9cblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLl90b3RhbFNpemUgPSAwO1xuICAgIHRoaXMuaGFzQ2hlY2tvdXQgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRGb3JDaGVja291dCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgaGFzRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N5bmMnO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGFzeW5jIGFkZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRTaXplID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQpLmxlbmd0aDtcbiAgICB0aGlzLl90b3RhbFNpemUgKz0gZXZlbnRTaXplO1xuICAgIGlmICh0aGlzLl90b3RhbFNpemUgPiBSRVBMQVlfTUFYX0VWRU5UX0JVRkZFUl9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXZlbnRCdWZmZXJTaXplRXhjZWVkZWRFcnJvcigpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzLnB1c2goZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBmaW5pc2goKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGV2ZW50cyBhcnJheSByZWZlcmVuY2UgYW5kIGltbWVkaWF0ZWx5IGNsZWFyIHRoZVxuICAgICAgLy8gZXZlbnRzIG1lbWJlciBzbyB0aGF0IHdlIGRvIG5vdCBsb3NlIG5ldyBldmVudHMgd2hpbGUgdXBsb2FkaW5nXG4gICAgICAvLyBhdHRhY2htZW50LlxuICAgICAgY29uc3QgZXZlbnRzUmV0ID0gdGhpcy5ldmVudHM7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXNvbHZlKEpTT04uc3RyaW5naWZ5KGV2ZW50c1JldCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBjbGVhcigpIHtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSA9IDA7XG4gICAgdGhpcy5oYXNDaGVja291dCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXRFYXJsaWVzdFRpbWVzdGFtcCgpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQudGltZXN0YW1wKS5zb3J0KClbMF07XG5cbiAgICBpZiAoIXRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWVzdGFtcFRvTXModGltZXN0YW1wKTtcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50IGJ1ZmZlciB0aGF0IHVzZXMgYSB3ZWIgd29ya2VyIHRvIGNvbXByZXNzIGV2ZW50cy5cbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmNsYXNzIFdvcmtlckhhbmRsZXIge1xuXG4gICBjb25zdHJ1Y3Rvcih3b3JrZXIpIHtcbiAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXI7XG4gICAgdGhpcy5faWQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSB0aGUgd29ya2VyIGlzIHJlYWR5IChvciBub3QpLlxuICAgKiBUaGlzIHdpbGwgZWl0aGVyIHJlc29sdmUgd2hlbiB0aGUgd29ya2VyIGlzIHJlYWR5LCBvciByZWplY3QgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICAgZW5zdXJlUmVhZHkoKSB7XG4gICAgLy8gRW5zdXJlIHdlIG9ubHkgY2hlY2sgb25jZVxuICAgIGlmICh0aGlzLl9lbnN1cmVSZWFkeVByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVSZWFkeVByb21pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fZW5zdXJlUmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdtZXNzYWdlJyxcbiAgICAgICAgKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgaWYgKChkYXRhICkuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9LFxuICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZW5zdXJlUmVhZHlQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHdvcmtlci5cbiAgICovXG4gICBkZXN0cm95KCkge1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnRGVzdHJveWluZyBjb21wcmVzc2lvbiB3b3JrZXInKTtcbiAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUG9zdCBtZXNzYWdlIHRvIHdvcmtlciBhbmQgd2FpdCBmb3IgcmVzcG9uc2UgYmVmb3JlIHJlc29sdmluZyBwcm9taXNlLlxuICAgKi9cbiAgIHBvc3RNZXNzYWdlKG1ldGhvZCwgYXJnKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9nZXRBbmRJbmNyZW1lbnRJZCgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YSA7XG4gICAgICAgIGlmIChyZXNwb25zZS5tZXRob2QgIT09IG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSBsaXN0ZW5lcnMgZm9yIGEgc2luZ2xlIG1ldGhvZCwgdGhlIGlkIGVuc3VyZXNcbiAgICAgICAgLy8gdGhhdCB0aGUgcmVzcG9uc2UgbWF0Y2hlcyB0aGUgY2FsbGVyLlxuICAgICAgICBpZiAocmVzcG9uc2UuaWQgIT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UnbGwgYWx3YXlzIHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVyIHJlZ2FyZGxlc3Mgb2YgcmVzdWx0IHN0YXR1c1xuICAgICAgICB0aGlzLl93b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAvLyBUT0RPOiBEbyBzb21lIGVycm9yIGhhbmRsaW5nLCBub3Qgc3VyZSB3aGF0XG4gICAgICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXJyb3IoJ0Vycm9yIGluIGNvbXByZXNzaW9uIHdvcmtlcjogJywgcmVzcG9uc2UucmVzcG9uc2UpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRXJyb3IgaW4gY29tcHJlc3Npb24gd29ya2VyJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzcG9uc2UgKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE5vdGU6IHdlIGNhbid0IHVzZSBgb25jZWAgb3B0aW9uIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBpdCBuZWVkcyB0b1xuICAgICAgLy8gbGlzdGVuIHRvIG11bHRpcGxlIG1lc3NhZ2VzXG4gICAgICB0aGlzLl93b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZSh7IGlkLCBtZXRob2QsIGFyZyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIGN1cnJlbnQgSUQgYW5kIGluY3JlbWVudCBpdCBmb3IgdGhlIG5leHQgY2FsbC4gKi9cbiAgIF9nZXRBbmRJbmNyZW1lbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxufVxuXG4vKipcbiAqIEV2ZW50IGJ1ZmZlciB0aGF0IHVzZXMgYSB3ZWIgd29ya2VyIHRvIGNvbXByZXNzIGV2ZW50cy5cbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmNsYXNzIEV2ZW50QnVmZmVyQ29tcHJlc3Npb25Xb3JrZXIgIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG5cbiAgIGNvbnN0cnVjdG9yKHdvcmtlcikge1xuICAgIHRoaXMuX3dvcmtlciA9IG5ldyBXb3JrZXJIYW5kbGVyKHdvcmtlcik7XG4gICAgdGhpcy5fZWFybGllc3RUaW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSA9IDA7XG4gICAgdGhpcy5oYXNDaGVja291dCA9IGZhbHNlO1xuICAgIHRoaXMud2FpdEZvckNoZWNrb3V0ID0gZmFsc2U7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldCBoYXNFdmVudHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZWFybGllc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnd29ya2VyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgdGhlIHdvcmtlciBpcyByZWFkeSAob3Igbm90KS5cbiAgICogVGhpcyB3aWxsIGVpdGhlciByZXNvbHZlIHdoZW4gdGhlIHdvcmtlciBpcyByZWFkeSwgb3IgcmVqZWN0IGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgIGVuc3VyZVJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl93b3JrZXIuZW5zdXJlUmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBldmVudCBidWZmZXIuXG4gICAqL1xuICAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl93b3JrZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCB0byB0aGUgZXZlbnQgYnVmZmVyLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkIGJ5IHdvcmtlci5cbiAgICovXG4gICBhZGRFdmVudChldmVudCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcFRvTXMoZXZlbnQudGltZXN0YW1wKTtcbiAgICBpZiAoIXRoaXMuX2VhcmxpZXN0VGltZXN0YW1wIHx8IHRpbWVzdGFtcCA8IHRoaXMuX2VhcmxpZXN0VGltZXN0YW1wKSB7XG4gICAgICB0aGlzLl9lYXJsaWVzdFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSArPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLl90b3RhbFNpemUgPiBSRVBMQVlfTUFYX0VWRU5UX0JVRkZFUl9TSVpFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEV2ZW50QnVmZmVyU2l6ZUV4Y2VlZGVkRXJyb3IoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRFdmVudFRvV29ya2VyKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmlzaCB0aGUgZXZlbnQgYnVmZmVyIGFuZCByZXR1cm4gdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICovXG4gICBmaW5pc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaFJlcXVlc3QoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgY2xlYXIoKSB7XG4gICAgdGhpcy5fZWFybGllc3RUaW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSA9IDA7XG4gICAgdGhpcy5oYXNDaGVja291dCA9IGZhbHNlO1xuXG4gICAgLy8gV2UgZG8gbm90IHdhaXQgb24gdGhpcywgYXMgd2UgYXNzdW1lIHRoZSBvcmRlciBvZiBtZXNzYWdlcyBpcyBjb25zaXN0ZW50IGZvciB0aGUgd29ya2VyXG4gICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKCdjbGVhcicpLnRoZW4obnVsbCwgZSA9PiB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5leGNlcHRpb24oZSwgJ1NlbmRpbmcgXCJjbGVhclwiIG1lc3NhZ2UgdG8gd29ya2VyIGZhaWxlZCcsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXRFYXJsaWVzdFRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWFybGllc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgZXZlbnQgdG8gdGhlIHdvcmtlci5cbiAgICovXG4gICBfc2VuZEV2ZW50VG9Xb3JrZXIoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoJ2FkZEV2ZW50JywgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogRmluaXNoIHRoZSByZXF1ZXN0IGFuZCByZXR1cm4gdGhlIGNvbXByZXNzZWQgZGF0YSBmcm9tIHRoZSB3b3JrZXIuXG4gICAqL1xuICAgYXN5bmMgX2ZpbmlzaFJlcXVlc3QoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoJ2ZpbmlzaCcpO1xuXG4gICAgdGhpcy5fZWFybGllc3RUaW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX3RvdGFsU2l6ZSA9IDA7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHByb3h5IHdpbGwgdHJ5IHRvIHVzZSB0aGUgY29tcHJlc3Npb24gd29ya2VyLCBhbmQgZmFsbCBiYWNrIHRvIHVzZSB0aGUgc2ltcGxlIGJ1ZmZlciBpZiBhbiBlcnJvciBvY2N1cnMgdGhlcmUuXG4gKiBUaGlzIGNhbiBoYXBwZW4gZS5nLiBpZiB0aGUgd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQuXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5jbGFzcyBFdmVudEJ1ZmZlclByb3h5ICB7XG5cbiAgIGNvbnN0cnVjdG9yKHdvcmtlcikge1xuICAgIHRoaXMuX2ZhbGxiYWNrID0gbmV3IEV2ZW50QnVmZmVyQXJyYXkoKTtcbiAgICB0aGlzLl9jb21wcmVzc2lvbiA9IG5ldyBFdmVudEJ1ZmZlckNvbXByZXNzaW9uV29ya2VyKHdvcmtlcik7XG4gICAgdGhpcy5fdXNlZCA9IHRoaXMuX2ZhbGxiYWNrO1xuXG4gICAgdGhpcy5fZW5zdXJlV29ya2VySXNMb2FkZWRQcm9taXNlID0gdGhpcy5fZW5zdXJlV29ya2VySXNMb2FkZWQoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZ2V0IHdhaXRGb3JDaGVja291dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlZC53YWl0Rm9yQ2hlY2tvdXQ7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VkLnR5cGU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIGdldCBoYXNFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZWQuaGFzRXZlbnRzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXQgaGFzQ2hlY2tvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZWQuaGFzQ2hlY2tvdXQ7XG4gIH1cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBzZXQgaGFzQ2hlY2tvdXQodmFsdWUpIHtcbiAgICB0aGlzLl91c2VkLmhhc0NoZWNrb3V0ID0gdmFsdWU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9hZGphY2VudC1vdmVybG9hZC1zaWduYXR1cmVzXG4gICBzZXQgd2FpdEZvckNoZWNrb3V0KHZhbHVlKSB7XG4gICAgdGhpcy5fdXNlZC53YWl0Rm9yQ2hlY2tvdXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9mYWxsYmFjay5kZXN0cm95KCk7XG4gICAgdGhpcy5fY29tcHJlc3Npb24uZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlZC5jbGVhcigpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gICBnZXRFYXJsaWVzdFRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlZC5nZXRFYXJsaWVzdFRpbWVzdGFtcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCB0byB0aGUgZXZlbnQgYnVmZmVyLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBhZGRlZC5cbiAgICovXG4gICBhZGRFdmVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLl91c2VkLmFkZEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgYXN5bmMgZmluaXNoKCkge1xuICAgIC8vIEVuc3VyZSB0aGUgd29ya2VyIGlzIGxvYWRlZCwgc28gdGhlIHNlbnQgZXZlbnQgaXMgY29tcHJlc3NlZFxuICAgIGF3YWl0IHRoaXMuZW5zdXJlV29ya2VySXNMb2FkZWQoKTtcblxuICAgIHJldHVybiB0aGlzLl91c2VkLmZpbmlzaCgpO1xuICB9XG5cbiAgLyoqIEVuc3VyZSB0aGUgd29ya2VyIGhhcyBsb2FkZWQuICovXG4gICBlbnN1cmVXb3JrZXJJc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5zdXJlV29ya2VySXNMb2FkZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqIEFjdHVhbGx5IGNoZWNrIGlmIHRoZSB3b3JrZXIgaGFzIGJlZW4gbG9hZGVkLiAqL1xuICAgYXN5bmMgX2Vuc3VyZVdvcmtlcklzTG9hZGVkKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9jb21wcmVzc2lvbi5lbnN1cmVSZWFkeSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgd29ya2VyIGZhaWxzIHRvIGxvYWQsIHdlIGZhbGwgYmFjayB0byB0aGUgc2ltcGxlIGJ1ZmZlci5cbiAgICAgIC8vIE5vdGhpbmcgbW9yZSB0byBkbyBmcm9tIG91ciBzaWRlIGhlcmVcbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBsb2FkIHRoZSBjb21wcmVzc2lvbiB3b3JrZXIsIGZhbGxpbmcgYmFjayB0byBzaW1wbGUgYnVmZmVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIG5lZWQgdG8gc3dpdGNoIG92ZXIgdGhlIGFycmF5IGJ1ZmZlciB0byB0aGUgY29tcHJlc3Npb24gd29ya2VyXG4gICAgYXdhaXQgdGhpcy5fc3dpdGNoVG9Db21wcmVzc2lvbldvcmtlcigpO1xuICB9XG5cbiAgLyoqIFN3aXRjaCB0aGUgdXNlZCBidWZmZXIgdG8gdGhlIGNvbXByZXNzaW9uIHdvcmtlci4gKi9cbiAgIGFzeW5jIF9zd2l0Y2hUb0NvbXByZXNzaW9uV29ya2VyKCkge1xuICAgIGNvbnN0IHsgZXZlbnRzLCBoYXNDaGVja291dCwgd2FpdEZvckNoZWNrb3V0IH0gPSB0aGlzLl9mYWxsYmFjaztcblxuICAgIGNvbnN0IGFkZEV2ZW50UHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgYWRkRXZlbnRQcm9taXNlcy5wdXNoKHRoaXMuX2NvbXByZXNzaW9uLmFkZEV2ZW50KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29tcHJlc3Npb24uaGFzQ2hlY2tvdXQgPSBoYXNDaGVja291dDtcbiAgICB0aGlzLl9jb21wcmVzc2lvbi53YWl0Rm9yQ2hlY2tvdXQgPSB3YWl0Rm9yQ2hlY2tvdXQ7XG5cbiAgICAvLyBXZSBzd2l0Y2ggb3ZlciB0byB0aGUgbmV3IGJ1ZmZlciBpbW1lZGlhdGVseSAtIGFueSBmdXJ0aGVyIGV2ZW50cyB3aWxsIGJlIGFkZGVkXG4gICAgLy8gYWZ0ZXIgdGhlIHByZXZpb3VzbHkgYnVmZmVyZWQgb25lc1xuICAgIHRoaXMuX3VzZWQgPSB0aGlzLl9jb21wcmVzc2lvbjtcblxuICAgIC8vIFdhaXQgZm9yIG9yaWdpbmFsIGV2ZW50cyB0byBiZSByZS1hZGRlZCBiZWZvcmUgcmVzb2x2aW5nXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFkZEV2ZW50UHJvbWlzZXMpO1xuXG4gICAgICAvLyBDYW4gbm93IGNsZWFyIGZhbGxiYWNrIGJ1ZmZlciBhcyBpdCdzIG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICAgIHRoaXMuX2ZhbGxiYWNrLmNsZWFyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBhZGQgZXZlbnRzIHdoZW4gc3dpdGNoaW5nIGJ1ZmZlcnMuJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGJ1ZmZlciBmb3IgcmVwbGF5cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRCdWZmZXIoe1xuICB1c2VDb21wcmVzc2lvbixcbiAgd29ya2VyVXJsOiBjdXN0b21Xb3JrZXJVcmwsXG59KSB7XG4gIGlmIChcbiAgICB1c2VDb21wcmVzc2lvbiAmJlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICB3aW5kb3cuV29ya2VyXG4gICkge1xuICAgIGNvbnN0IHdvcmtlciA9IF9sb2FkV29ya2VyKGN1c3RvbVdvcmtlclVybCk7XG5cbiAgICBpZiAod29ya2VyKSB7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cbiAgfVxuXG4gIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnVXNpbmcgc2ltcGxlIGJ1ZmZlcicpO1xuICByZXR1cm4gbmV3IEV2ZW50QnVmZmVyQXJyYXkoKTtcbn1cblxuZnVuY3Rpb24gX2xvYWRXb3JrZXIoY3VzdG9tV29ya2VyVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgd29ya2VyVXJsID0gY3VzdG9tV29ya2VyVXJsIHx8IF9nZXRXb3JrZXJVcmwoKTtcblxuICAgIGlmICghd29ya2VyVXJsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKGBVc2luZyBjb21wcmVzc2lvbiB3b3JrZXIke2N1c3RvbVdvcmtlclVybCA/IGAgZnJvbSAke2N1c3RvbVdvcmtlclVybH1gIDogJyd9YCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIHJldHVybiBuZXcgRXZlbnRCdWZmZXJQcm94eSh3b3JrZXIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBjcmVhdGUgY29tcHJlc3Npb24gd29ya2VyJyk7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzZSBzaW1wbGUgZXZlbnQgYnVmZmVyIGFycmF5XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFdvcmtlclVybCgpIHtcbiAgaWYgKHR5cGVvZiBfX1NFTlRSWV9FWENMVURFX1JFUExBWV9XT1JLRVJfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgIV9fU0VOVFJZX0VYQ0xVREVfUkVQTEFZX1dPUktFUl9fKSB7XG4gICAgcmV0dXJuIGUoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqIElmIHNlc3Npb25TdG9yYWdlIGlzIGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGhhc1Nlc3Npb25TdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRoaXMgY2FuIHRocm93LCBlLmcuIHdoZW4gYmVpbmcgYWNjZXNzZWQgaW4gYSBzYW5kYm94ZWQgaWZyYW1lXG4gICAgcmV0dXJuICdzZXNzaW9uU3RvcmFnZScgaW4gV0lORE9XICYmICEhV0lORE9XLnNlc3Npb25TdG9yYWdlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBzZXNzaW9uIGZyb20gU2Vzc2lvbiBTdG9yYWdlIGFuZCB1bnNldHMgc2Vzc2lvbiBpbiByZXBsYXkgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY2xlYXJTZXNzaW9uKHJlcGxheSkge1xuICBkZWxldGVTZXNzaW9uKCk7XG4gIHJlcGxheS5zZXNzaW9uID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgYSBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICovXG5mdW5jdGlvbiBkZWxldGVTZXNzaW9uKCkge1xuICBpZiAoIWhhc1Nlc3Npb25TdG9yYWdlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIFdJTkRPVy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFJFUExBWV9TRVNTSU9OX0tFWSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIElnbm9yZSBwb3RlbnRpYWwgU2VjdXJpdHlFcnJvciBleGNlcHRpb25zXG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIHNhbXBsZSByYXRlLCByZXR1cm5zIHRydWUgaWYgcmVwbGF5IHNob3VsZCBiZSBzYW1wbGVkLlxuICpcbiAqIDEuMCA9IDEwMCUgc2FtcGxpbmdcbiAqIDAuMCA9IDAlIHNhbXBsaW5nXG4gKi9cbmZ1bmN0aW9uIGlzU2FtcGxlZChzYW1wbGVSYXRlKSB7XG4gIGlmIChzYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNYXRoLnJhbmRvbSgpIHJldHVybnMgYSBudW1iZXIgaW4gcmFuZ2Ugb2YgMCB0byAxIChpbmNsdXNpdmUgb2YgMCwgYnV0IG5vdCAxKVxuICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHNhbXBsZVJhdGU7XG59XG5cbi8qKlxuICogU2F2ZSBhIHNlc3Npb24gdG8gc2Vzc2lvbiBzdG9yYWdlLlxuICovXG5mdW5jdGlvbiBzYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gIGlmICghaGFzU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgV0lORE9XLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUkVQTEFZX1NFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIElnbm9yZSBwb3RlbnRpYWwgU2VjdXJpdHlFcnJvciBleGNlcHRpb25zXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzZXNzaW9uIHdpdGggZGVmYXVsdHMgJiBhcHBsaWVkIHNhbXBsaW5nLlxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihzZXNzaW9uKSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IGlkID0gc2Vzc2lvbi5pZCB8fCB1dWlkNCgpO1xuICAvLyBOb3RlIHRoYXQgdGhpcyBtZWFucyB3ZSBjYW5ub3Qgc2V0IGEgc3RhcnRlZC9sYXN0QWN0aXZpdHkgb2YgYDBgLCBidXQgdGhpcyBzaG91bGQgbm90IGJlIHJlbGV2YW50IG91dHNpZGUgb2YgdGVzdHMuXG4gIGNvbnN0IHN0YXJ0ZWQgPSBzZXNzaW9uLnN0YXJ0ZWQgfHwgbm93O1xuICBjb25zdCBsYXN0QWN0aXZpdHkgPSBzZXNzaW9uLmxhc3RBY3Rpdml0eSB8fCBub3c7XG4gIGNvbnN0IHNlZ21lbnRJZCA9IHNlc3Npb24uc2VnbWVudElkIHx8IDA7XG4gIGNvbnN0IHNhbXBsZWQgPSBzZXNzaW9uLnNhbXBsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2Vzc2lvbklkID0gc2Vzc2lvbi5wcmV2aW91c1Nlc3Npb25JZDtcbiAgY29uc3QgZGlydHkgPSBzZXNzaW9uLmRpcnR5IHx8IGZhbHNlO1xuXG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgc3RhcnRlZCxcbiAgICBsYXN0QWN0aXZpdHksXG4gICAgc2VnbWVudElkLFxuICAgIHNhbXBsZWQsXG4gICAgcHJldmlvdXNTZXNzaW9uSWQsXG4gICAgZGlydHksXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzYW1wbGVkIHN0YXR1cyBmb3IgYSBzZXNzaW9uIGJhc2VkIG9uIHNhbXBsZSByYXRlcyAmIGN1cnJlbnQgc2FtcGxlZCBzdGF0dXMuXG4gKi9cbmZ1bmN0aW9uIGdldFNlc3Npb25TYW1wbGVUeXBlKHNlc3Npb25TYW1wbGVSYXRlLCBhbGxvd0J1ZmZlcmluZykge1xuICByZXR1cm4gaXNTYW1wbGVkKHNlc3Npb25TYW1wbGVSYXRlKSA/ICdzZXNzaW9uJyA6IGFsbG93QnVmZmVyaW5nID8gJ2J1ZmZlcicgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2Vzc2lvbiwgd2hpY2ggaW4gaXRzIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgYSBTZW50cnkgZXZlbnRcbiAqIHRoYXQgYWxsIHJlcGxheXMgd2lsbCBiZSBzYXZlZCB0byBhcyBhdHRhY2htZW50cy4gQ3VycmVudGx5LCB3ZSBvbmx5IGV4cGVjdFxuICogb25lIG9mIHRoZXNlIFNlbnRyeSBldmVudHMgcGVyIFwicmVwbGF5IHNlc3Npb25cIi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbihcbiAgeyBzZXNzaW9uU2FtcGxlUmF0ZSwgYWxsb3dCdWZmZXJpbmcsIHN0aWNreVNlc3Npb24gPSBmYWxzZSB9LFxuICB7IHByZXZpb3VzU2Vzc2lvbklkIH0gPSB7fSxcbikge1xuICBjb25zdCBzYW1wbGVkID0gZ2V0U2Vzc2lvblNhbXBsZVR5cGUoc2Vzc2lvblNhbXBsZVJhdGUsIGFsbG93QnVmZmVyaW5nKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKHtcbiAgICBzYW1wbGVkLFxuICAgIHByZXZpb3VzU2Vzc2lvbklkLFxuICB9KTtcblxuICBpZiAoc3RpY2t5U2Vzc2lvbikge1xuICAgIHNhdmVTZXNzaW9uKHNlc3Npb24pO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gKi9cbmZ1bmN0aW9uIGZldGNoU2Vzc2lvbigpIHtcbiAgaWYgKCFoYXNTZXNzaW9uU3RvcmFnZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgY2FuIHRocm93IGlmIGNvb2tpZXMgYXJlIGRpc2FibGVkXG4gICAgY29uc3Qgc2Vzc2lvblN0cmluZ0Zyb21TdG9yYWdlID0gV0lORE9XLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUkVQTEFZX1NFU1NJT05fS0VZKTtcblxuICAgIGlmICghc2Vzc2lvblN0cmluZ0Zyb21TdG9yYWdlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzZXNzaW9uT2JqID0gSlNPTi5wYXJzZShzZXNzaW9uU3RyaW5nRnJvbVN0b3JhZ2UpIDtcblxuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmluZm9UaWNrKCdMb2FkaW5nIGV4aXN0aW5nIHNlc3Npb24nKTtcblxuICAgIHJldHVybiBtYWtlU2Vzc2lvbihzZXNzaW9uT2JqKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHRpbWVzdGFtcCBhbmQgYW4gZXhwaXJ5IGR1cmF0aW9uLCBjaGVja3MgdG8gc2VlIGlmIGN1cnJlbnRcbiAqIHRpbWUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgZXhwaXJlZC5cbiAqL1xuZnVuY3Rpb24gaXNFeHBpcmVkKFxuICBpbml0aWFsVGltZSxcbiAgZXhwaXJ5LFxuICB0YXJnZXRUaW1lID0gK25ldyBEYXRlKCksXG4pIHtcbiAgLy8gQWx3YXlzIGV4cGlyZWQgaWYgPCAwXG4gIGlmIChpbml0aWFsVGltZSA9PT0gbnVsbCB8fCBleHBpcnkgPT09IHVuZGVmaW5lZCB8fCBleHBpcnkgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBOZXZlciBleHBpcmVzIGlmID09IDBcbiAgaWYgKGV4cGlyeSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbml0aWFsVGltZSArIGV4cGlyeSA8PSB0YXJnZXRUaW1lO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgc2Vzc2lvbiBpcyBleHBpcmVkXG4gKi9cbmZ1bmN0aW9uIGlzU2Vzc2lvbkV4cGlyZWQoXG4gIHNlc3Npb24sXG4gIHtcbiAgICBtYXhSZXBsYXlEdXJhdGlvbixcbiAgICBzZXNzaW9uSWRsZUV4cGlyZSxcbiAgICB0YXJnZXRUaW1lID0gRGF0ZS5ub3coKSxcbiAgfSxcbikge1xuICByZXR1cm4gKFxuICAgIC8vIEZpcnN0LCBjaGVjayB0aGF0IG1heGltdW0gc2Vzc2lvbiBsZW5ndGggaGFzIG5vdCBiZWVuIGV4Y2VlZGVkXG4gICAgaXNFeHBpcmVkKHNlc3Npb24uc3RhcnRlZCwgbWF4UmVwbGF5RHVyYXRpb24sIHRhcmdldFRpbWUpIHx8XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgaWRsZSB0aW1lb3V0IGhhcyBub3QgYmVlbiBleGNlZWRlZCAoaS5lLiB1c2VyIGhhc1xuICAgIC8vIHBlcmZvcm1lZCBhbiBhY3Rpb24gd2l0aGluIHRoZSBsYXN0IGBzZXNzaW9uSWRsZUV4cGlyZWAgbXMpXG4gICAgaXNFeHBpcmVkKHNlc3Npb24ubGFzdEFjdGl2aXR5LCBzZXNzaW9uSWRsZUV4cGlyZSwgdGFyZ2V0VGltZSlcbiAgKTtcbn1cblxuLyoqIElmIHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQgb3Igbm90LiAqL1xuZnVuY3Rpb24gc2hvdWxkUmVmcmVzaFNlc3Npb24oXG4gIHNlc3Npb24sXG4gIHsgc2Vzc2lvbklkbGVFeHBpcmUsIG1heFJlcGxheUR1cmF0aW9uIH0sXG4pIHtcbiAgLy8gSWYgbm90IGV4cGlyZWQsIGFsbCBnb29kLCBqdXN0IGtlZXAgdGhlIHNlc3Npb25cbiAgaWYgKCFpc1Nlc3Npb25FeHBpcmVkKHNlc3Npb24sIHsgc2Vzc2lvbklkbGVFeHBpcmUsIG1heFJlcGxheUR1cmF0aW9uIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgd2UgYXJlIGJ1ZmZlcmluZyAmIGhhdmVuJ3QgZXZlciBmbHVzaGVkIHlldCwgYWx3YXlzIGNvbnRpbnVlXG4gIGlmIChzZXNzaW9uLnNhbXBsZWQgPT09ICdidWZmZXInICYmIHNlc3Npb24uc2VnbWVudElkID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBhIHNlc3Npb24sIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSByZXBsYXkuXG4gKiBSZXR1cm5zIGEgc2Vzc2lvbiB0aGF0IG1heSBiZSB1bnNhbXBsZWQuXG4gKi9cbmZ1bmN0aW9uIGxvYWRPckNyZWF0ZVNlc3Npb24oXG4gIHtcbiAgICBzZXNzaW9uSWRsZUV4cGlyZSxcbiAgICBtYXhSZXBsYXlEdXJhdGlvbixcbiAgICBwcmV2aW91c1Nlc3Npb25JZCxcbiAgfVxuXG4sXG4gIHNlc3Npb25PcHRpb25zLFxuKSB7XG4gIGNvbnN0IGV4aXN0aW5nU2Vzc2lvbiA9IHNlc3Npb25PcHRpb25zLnN0aWNreVNlc3Npb24gJiYgZmV0Y2hTZXNzaW9uKCk7XG5cbiAgLy8gTm8gc2Vzc2lvbiBleGlzdHMgeWV0LCBqdXN0IGNyZWF0ZSBhIG5ldyBvbmVcbiAgaWYgKCFleGlzdGluZ1Nlc3Npb24pIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5pbmZvVGljaygnQ3JlYXRpbmcgbmV3IHNlc3Npb24nKTtcbiAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihzZXNzaW9uT3B0aW9ucywgeyBwcmV2aW91c1Nlc3Npb25JZCB9KTtcbiAgfVxuXG4gIGlmICghc2hvdWxkUmVmcmVzaFNlc3Npb24oZXhpc3RpbmdTZXNzaW9uLCB7IHNlc3Npb25JZGxlRXhwaXJlLCBtYXhSZXBsYXlEdXJhdGlvbiB9KSkge1xuICAgIHJldHVybiBleGlzdGluZ1Nlc3Npb247XG4gIH1cblxuICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5pbmZvVGljaygnU2Vzc2lvbiBpbiBzZXNzaW9uU3RvcmFnZSBpcyBleHBpcmVkLCBjcmVhdGluZyBuZXcgb25lLi4uJyk7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uKHNlc3Npb25PcHRpb25zLCB7IHByZXZpb3VzU2Vzc2lvbklkOiBleGlzdGluZ1Nlc3Npb24uaWQgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5DdXN0b207XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IHRvIHRoZSBldmVudCBidWZmZXIuXG4gKiBJbiBjb250cmFzdCB0byBgYWRkRXZlbnRgLCB0aGlzIGRvZXMgbm90IHJldHVybiBhIHByb21pc2UgJiBkb2VzIG5vdCB3YWl0IGZvciB0aGUgYWRkaW5nIG9mIHRoZSBldmVudCB0byBzdWNjZWVkL2ZhaWwuXG4gKiBJbnN0ZWFkIHRoaXMgcmV0dXJucyBgdHJ1ZWAgaWYgd2UgdHJpZWQgdG8gYWRkIHRoZSBldmVudCwgZWxzZSBmYWxzZS5cbiAqIEl0IHJldHVybnMgYGZhbHNlYCBlLmcuIGlmIHdlIGFyZSBwYXVzZWQsIGRpc2FibGVkLCBvciBvdXQgb2YgdGhlIG1heCByZXBsYXkgZHVyYXRpb24uXG4gKlxuICogYGlzQ2hlY2tvdXRgIGlzIHRydWUgaWYgdGhpcyBpcyBlaXRoZXIgdGhlIHZlcnkgZmlyc3QgZXZlbnQsIG9yIGFuIGV2ZW50IHRyaWdnZXJlZCBieSBgY2hlY2tvdXRFdmVyeU5tc2AuXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50U3luYyhyZXBsYXksIGV2ZW50LCBpc0NoZWNrb3V0KSB7XG4gIGlmICghc2hvdWxkQWRkRXZlbnQocmVwbGF5LCBldmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaGlzIHNob3VsZCBuZXZlciByZWplY3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICBfYWRkRXZlbnQocmVwbGF5LCBldmVudCwgaXNDaGVja291dCk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IHRvIHRoZSBldmVudCBidWZmZXIuXG4gKiBSZXNvbHZlcyB0byBgbnVsbGAgaWYgbm8gZXZlbnQgd2FzIGFkZGVkLCBlbHNlIHRvIGB2b2lkYC5cbiAqXG4gKiBgaXNDaGVja291dGAgaXMgdHJ1ZSBpZiB0aGlzIGlzIGVpdGhlciB0aGUgdmVyeSBmaXJzdCBldmVudCwgb3IgYW4gZXZlbnQgdHJpZ2dlcmVkIGJ5IGBjaGVja291dEV2ZXJ5Tm1zYC5cbiAqL1xuZnVuY3Rpb24gYWRkRXZlbnQoXG4gIHJlcGxheSxcbiAgZXZlbnQsXG4gIGlzQ2hlY2tvdXQsXG4pIHtcbiAgaWYgKCFzaG91bGRBZGRFdmVudChyZXBsYXksIGV2ZW50KSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gIH1cblxuICByZXR1cm4gX2FkZEV2ZW50KHJlcGxheSwgZXZlbnQsIGlzQ2hlY2tvdXQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfYWRkRXZlbnQoXG4gIHJlcGxheSxcbiAgZXZlbnQsXG4gIGlzQ2hlY2tvdXQsXG4pIHtcbiAgY29uc3QgeyBldmVudEJ1ZmZlciB9ID0gcmVwbGF5O1xuXG4gIGlmICghZXZlbnRCdWZmZXIgfHwgKGV2ZW50QnVmZmVyLndhaXRGb3JDaGVja291dCAmJiAhaXNDaGVja291dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGlzQnVmZmVyTW9kZSA9IHJlcGxheS5yZWNvcmRpbmdNb2RlID09PSAnYnVmZmVyJztcblxuICB0cnkge1xuICAgIGlmIChpc0NoZWNrb3V0ICYmIGlzQnVmZmVyTW9kZSkge1xuICAgICAgZXZlbnRCdWZmZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDaGVja291dCkge1xuICAgICAgZXZlbnRCdWZmZXIuaGFzQ2hlY2tvdXQgPSB0cnVlO1xuICAgICAgZXZlbnRCdWZmZXIud2FpdEZvckNoZWNrb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGF5T3B0aW9ucyA9IHJlcGxheS5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCBldmVudEFmdGVyUG9zc2libGVDYWxsYmFjayA9IG1heWJlQXBwbHlDYWxsYmFjayhldmVudCwgcmVwbGF5T3B0aW9ucy5iZWZvcmVBZGRSZWNvcmRpbmdFdmVudCk7XG5cbiAgICBpZiAoIWV2ZW50QWZ0ZXJQb3NzaWJsZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGV2ZW50QnVmZmVyLmFkZEV2ZW50KGV2ZW50QWZ0ZXJQb3NzaWJsZUNhbGxiYWNrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpc0V4Y2VlZGVkID0gZXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFdmVudEJ1ZmZlclNpemVFeGNlZWRlZEVycm9yO1xuICAgIGNvbnN0IHJlYXNvbiA9IGlzRXhjZWVkZWQgPyAnYWRkRXZlbnRTaXplRXhjZWVkZWQnIDogJ2FkZEV2ZW50JztcbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcblxuICAgIGlmIChjbGllbnQpIHtcbiAgICAgIC8vIFdlIGFyZSBsaW1pdGVkIGluIHRoZSBkcm9wIHJlYXNvbnM6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NudWJhL2Jsb2IvNmM3M2JlNjA3MTZjMmZiMWMzMGNhNjI3ODgzMjA3ODg3YzczM2NiZC9ydXN0X3NudWJhL3NyYy9wcm9jZXNzb3JzL291dGNvbWVzLnJzI0wzOVxuICAgICAgY29uc3QgZHJvcFJlYXNvbiA9IGlzRXhjZWVkZWQgPyAnYnVmZmVyX292ZXJmbG93JyA6ICdpbnRlcm5hbF9zZGtfZXJyb3InO1xuICAgICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudChkcm9wUmVhc29uLCAncmVwbGF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRXhjZWVkZWQgJiYgaXNCdWZmZXJNb2RlKSB7XG4gICAgICAvLyBDbGVhciBidWZmZXIgYW5kIHdhaXQgZm9yIG5leHQgY2hlY2tvdXRcbiAgICAgIGV2ZW50QnVmZmVyLmNsZWFyKCk7XG4gICAgICBldmVudEJ1ZmZlci53YWl0Rm9yQ2hlY2tvdXQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXBsYXkuaGFuZGxlRXhjZXB0aW9uKGVycm9yKTtcblxuICAgIGF3YWl0IHJlcGxheS5zdG9wKHsgcmVhc29uIH0pO1xuICB9XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIHNob3VsZEFkZEV2ZW50KHJlcGxheSwgZXZlbnQpIHtcbiAgaWYgKCFyZXBsYXkuZXZlbnRCdWZmZXIgfHwgcmVwbGF5LmlzUGF1c2VkKCkgfHwgIXJlcGxheS5pc0VuYWJsZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcEluTXMgPSB0aW1lc3RhbXBUb01zKGV2ZW50LnRpbWVzdGFtcCk7XG5cbiAgLy8gVGhyb3cgb3V0IGV2ZW50cyB0aGF0IGhhcHBlbiBtb3JlIHRoYW4gNSBtaW51dGVzIGFnby4gVGhpcyBjYW4gaGFwcGVuIGlmXG4gIC8vIHBhZ2UgaGFzIGJlZW4gbGVmdCBvcGVuIGFuZCBpZGxlIGZvciBhIGxvbmcgcGVyaW9kIG9mIHRpbWUgYW5kIHVzZXJcbiAgLy8gY29tZXMgYmFjayB0byB0cmlnZ2VyIGEgbmV3IHNlc3Npb24uIFRoZSBwZXJmb3JtYW5jZSBlbnRyaWVzIHJlbHkgb25cbiAgLy8gYHBlcmZvcm1hbmNlLnRpbWVPcmlnaW5gLCB3aGljaCBpcyB3aGVuIHRoZSBwYWdlIGZpcnN0IG9wZW5lZC5cbiAgaWYgKHRpbWVzdGFtcEluTXMgKyByZXBsYXkudGltZW91dHMuc2Vzc2lvbklkbGVQYXVzZSA8IERhdGUubm93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaHJvdyBvdXQgZXZlbnRzIHRoYXQgYXJlICs2MG1pbiBmcm9tIHRoZSBpbml0aWFsIHRpbWVzdGFtcFxuICBpZiAodGltZXN0YW1wSW5NcyA+IHJlcGxheS5nZXRDb250ZXh0KCkuaW5pdGlhbFRpbWVzdGFtcCArIHJlcGxheS5nZXRPcHRpb25zKCkubWF4UmVwbGF5RHVyYXRpb24pIHtcbiAgICBERUJVR19CVUlMRCAmJlxuICAgICAgZGVidWcuaW5mb1RpY2soYFNraXBwaW5nIGV2ZW50IHdpdGggdGltZXN0YW1wICR7dGltZXN0YW1wSW5Nc30gYmVjYXVzZSBpdCBpcyBhZnRlciBtYXhSZXBsYXlEdXJhdGlvbmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXliZUFwcGx5Q2FsbGJhY2soXG4gIGV2ZW50LFxuICBjYWxsYmFjayxcbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgaXNDdXN0b21FdmVudChldmVudCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBkZWJ1Zy5leGNlcHRpb24oZXJyb3IsICdBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgYGJlZm9yZUFkZFJlY29yZGluZ0V2ZW50YCBjYWxsYmFjaywgc2tpcHBpbmcgdGhlIGV2ZW50Li4uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKiBJZiB0aGUgZXZlbnQgaXMgYW4gZXJyb3IgZXZlbnQgKi9cbmZ1bmN0aW9uIGlzRXJyb3JFdmVudChldmVudCkge1xuICByZXR1cm4gIWV2ZW50LnR5cGU7XG59XG5cbi8qKiBJZiB0aGUgZXZlbnQgaXMgYSB0cmFuc2FjdGlvbiBldmVudCAqL1xuZnVuY3Rpb24gaXNUcmFuc2FjdGlvbkV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSAndHJhbnNhY3Rpb24nO1xufVxuXG4vKiogSWYgdGhlIGV2ZW50IGlzIGFuIHJlcGxheSBldmVudCAqL1xuZnVuY3Rpb24gaXNSZXBsYXlFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3JlcGxheV9ldmVudCc7XG59XG5cbi8qKiBJZiB0aGUgZXZlbnQgaXMgYSBmZWVkYmFjayBldmVudCAqL1xuZnVuY3Rpb24gaXNGZWVkYmFja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSAnZmVlZGJhY2snO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0ZW5lciB0byBiZSBhZGRlZCB0byBgY2xpZW50Lm9uKCdhZnRlclNlbmRFcnJvckV2ZW50LCBsaXN0ZW5lcilgLlxuICovXG5mdW5jdGlvbiBoYW5kbGVBZnRlclNlbmRFdmVudChyZXBsYXkpIHtcbiAgcmV0dXJuIChldmVudCwgc2VuZFJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKCFyZXBsYXkuaXNFbmFibGVkKCkgfHwgKCFpc0Vycm9yRXZlbnQoZXZlbnQpICYmICFpc1RyYW5zYWN0aW9uRXZlbnQoZXZlbnQpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBzZW5kUmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgIC8vIFdlIG9ubHkgd2FudCB0byBkbyBzdHVmZiBvbiBzdWNjZXNzZnVsIGVycm9yIHNlbmRpbmcsIG90aGVyd2lzZSB5b3UgZ2V0IGVycm9yIHJlcGxheXMgd2l0aG91dCBlcnJvcnMgYXR0YWNoZWRcbiAgICAvLyBXZSBza2lwIGlmIHdlIGVuY291bnRlcmVkIGFuIG5vbi1PSyBzdGF0dXMgY29kZVxuICAgIGlmICghc3RhdHVzQ29kZSB8fCBzdGF0dXNDb2RlIDwgMjAwIHx8IHN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVHJhbnNhY3Rpb25FdmVudChldmVudCkpIHtcbiAgICAgIGhhbmRsZVRyYW5zYWN0aW9uRXZlbnQocmVwbGF5LCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JFdmVudChyZXBsYXksIGV2ZW50KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVHJhbnNhY3Rpb25FdmVudChyZXBsYXksIGV2ZW50KSB7XG4gIGNvbnN0IHJlcGxheUNvbnRleHQgPSByZXBsYXkuZ2V0Q29udGV4dCgpO1xuXG4gIC8vIENvbGxlY3QgdHJhY2VJZHMgaW4gX2NvbnRleHQgcmVnYXJkbGVzcyBvZiBgcmVjb3JkaW5nTW9kZWBcbiAgLy8gSW4gZXJyb3IgbW9kZSwgX2NvbnRleHQgZ2V0cyBjbGVhcmVkIG9uIGV2ZXJ5IGNoZWNrb3V0XG4gIC8vIFdlIGxpbWl0IHRvIG1heC4gMTAwIHRyYW5zYWN0aW9ucyBsaW5rZWRcbiAgaWYgKGV2ZW50LmNvbnRleHRzPy50cmFjZT8udHJhY2VfaWQgJiYgcmVwbGF5Q29udGV4dC50cmFjZUlkcy5zaXplIDwgMTAwKSB7XG4gICAgcmVwbGF5Q29udGV4dC50cmFjZUlkcy5hZGQoZXZlbnQuY29udGV4dHMudHJhY2UudHJhY2VfaWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yRXZlbnQocmVwbGF5LCBldmVudCkge1xuICBjb25zdCByZXBsYXlDb250ZXh0ID0gcmVwbGF5LmdldENvbnRleHQoKTtcblxuICAvLyBBZGQgZXJyb3IgdG8gbGlzdCBvZiBlcnJvcklkcyBvZiByZXBsYXkuIFRoaXMgaXMgb2sgdG8gZG8gZXZlbiBpZiBub3RcbiAgLy8gc2FtcGxlZCBiZWNhdXNlIGNvbnRleHQgd2lsbCBnZXQgcmVzZXQgYXQgbmV4dCBjaGVja291dC5cbiAgLy8gWFhYOiBUaGVyZSBpcyBhbHNvIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGFuXG4gIC8vIGVycm9yIHRvIFNlbnRyeSBiZWZvcmUgUmVwbGF5IFNESyBoYXMgbG9hZGVkLCBidXQgcmVzcG9uc2UgcmV0dXJucyBhZnRlclxuICAvLyBpdCB3YXMgbG9hZGVkLCBhbmQgdGhpcyBnZXRzIGNhbGxlZC5cbiAgLy8gV2UgbGltaXQgdG8gbWF4LiAxMDAgZXJyb3JzIGxpbmtlZFxuICBpZiAoZXZlbnQuZXZlbnRfaWQgJiYgcmVwbGF5Q29udGV4dC5lcnJvcklkcy5zaXplIDwgMTAwKSB7XG4gICAgcmVwbGF5Q29udGV4dC5lcnJvcklkcy5hZGQoZXZlbnQuZXZlbnRfaWQpO1xuICB9XG5cbiAgLy8gSWYgZXJyb3IgZXZlbnQgaXMgdGFnZ2VkIHdpdGggcmVwbGF5IGlkIGl0IG1lYW5zIGl0IHdhcyBzYW1wbGVkICh3aGVuIGluIGJ1ZmZlciBtb2RlKVxuICAvLyBOZWVkIHRvIGJlIHZlcnkgY2FyZWZ1bCB0aGF0IHRoaXMgZG9lcyBub3QgY2F1c2UgYW4gaW5maW5pdGUgbG9vcFxuICBpZiAocmVwbGF5LnJlY29yZGluZ01vZGUgIT09ICdidWZmZXInIHx8ICFldmVudC50YWdzIHx8ICFldmVudC50YWdzLnJlcGxheUlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBiZWZvcmVFcnJvclNhbXBsaW5nIH0gPSByZXBsYXkuZ2V0T3B0aW9ucygpO1xuICBpZiAodHlwZW9mIGJlZm9yZUVycm9yU2FtcGxpbmcgPT09ICdmdW5jdGlvbicgJiYgIWJlZm9yZUVycm9yU2FtcGxpbmcoZXZlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0VGltZW91dCQzKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2FwdHVyZSBjdXJyZW50IGV2ZW50IGJ1ZmZlciBhcyBuZXcgcmVwbGF5XG4gICAgICBhd2FpdCByZXBsYXkuc2VuZEJ1ZmZlcmVkUmVwbGF5T3JGbHVzaCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVwbGF5LmhhbmRsZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3RlbmVyIHRvIGJlIGFkZGVkIHRvIGBjbGllbnQub24oJ2FmdGVyU2VuZEVycm9yRXZlbnQsIGxpc3RlbmVyKWAuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJlZm9yZVNlbmRFdmVudChyZXBsYXkpIHtcbiAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgIGlmICghcmVwbGF5LmlzRW5hYmxlZCgpIHx8ICFpc0Vycm9yRXZlbnQoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlSHlkcmF0aW9uRXJyb3IocmVwbGF5LCBldmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUh5ZHJhdGlvbkVycm9yKHJlcGxheSwgZXZlbnQpIHtcbiAgY29uc3QgZXhjZXB0aW9uVmFsdWUgPSBldmVudC5leGNlcHRpb24/LnZhbHVlcz8uWzBdPy52YWx1ZTtcbiAgaWYgKHR5cGVvZiBleGNlcHRpb25WYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoXG4gICAgLy8gT25seSBtYXRjaGVzIGVycm9ycyBpbiBwcm9kdWN0aW9uIGJ1aWxkcyBvZiByZWFjdC1kb21cbiAgICAvLyBFeGFtcGxlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PTQyM1xuICAgIC8vIFdpdGggbmV3ZXIgUmVhY3QgdmVyc2lvbnMsIHRoZSBtZXNzYWdlcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IHdlYnNpdGUgaHR0cHM6Ly9yZWFjdC5kZXYvZXJyb3JzLzQxOFxuICAgIGV4Y2VwdGlvblZhbHVlLm1hdGNoKFxuICAgICAgLyhyZWFjdGpzXFwub3JnXFwvZG9jc1xcL2Vycm9yLWRlY29kZXJcXC5odG1sXFw/aW52YXJpYW50PXxyZWFjdFxcLmRldlxcL2Vycm9yc1xcLykoNDE4fDQxOXw0MjJ8NDIzfDQyNSkvLFxuICAgICkgfHxcbiAgICAvLyBEZXZlbG9wbWVudCBidWlsZHMgb2YgcmVhY3QtZG9tXG4gICAgLy8gRXJyb3IgMTogSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgLy8gRXJyb3IgMjogVGV4dCBjb250ZW50IGRvZXMgbm90IG1hdGNoIHNlcnZlci1yZW5kZXJlZCBIVE1MLiBXYXJuaW5nOiBUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC5cbiAgICBleGNlcHRpb25WYWx1ZS5tYXRjaCgvKGRvZXMgbm90IG1hdGNoIHNlcnZlci1yZW5kZXJlZCBIVE1MfEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSkvaSlcbiAgKSB7XG4gICAgY29uc3QgYnJlYWRjcnVtYiA9IGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgICAgY2F0ZWdvcnk6ICdyZXBsYXkuaHlkcmF0ZS1lcnJvcicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVybDogZ2V0TG9jYXRpb25IcmVmKCksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGFkZEJyZWFkY3J1bWJFdmVudChyZXBsYXksIGJyZWFkY3J1bWIpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGJyZWFkY3J1bWJzIHRoYXQgU2VudHJ5IGNhcHR1cmVzLCBhbmQgbWFrZSBzdXJlIHRvIGNhcHR1cmUgcmVsZXZhbnQgYnJlYWRjcnVtYnMgdG8gUmVwbGF5IGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJyZWFkY3J1bWJzKHJlcGxheSkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcblxuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNsaWVudC5vbignYmVmb3JlQWRkQnJlYWRjcnVtYicsIGJyZWFkY3J1bWIgPT4gYmVmb3JlQWRkQnJlYWRjcnVtYihyZXBsYXksIGJyZWFkY3J1bWIpKTtcbn1cblxuZnVuY3Rpb24gYmVmb3JlQWRkQnJlYWRjcnVtYihyZXBsYXksIGJyZWFkY3J1bWIpIHtcbiAgaWYgKCFyZXBsYXkuaXNFbmFibGVkKCkgfHwgIWlzQnJlYWRjcnVtYldpdGhDYXRlZ29yeShicmVhZGNydW1iKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG5vcm1hbGl6ZUJyZWFkY3J1bWIoYnJlYWRjcnVtYik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBhZGRCcmVhZGNydW1iRXZlbnQocmVwbGF5LCByZXN1bHQpO1xuICB9XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJyZWFkY3J1bWIoYnJlYWRjcnVtYikge1xuICBpZiAoXG4gICAgIWlzQnJlYWRjcnVtYldpdGhDYXRlZ29yeShicmVhZGNydW1iKSB8fFxuICAgIFtcbiAgICAgIC8vIGZldGNoICYgeGhyIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHksaW4gaGFuZGxlTmV0d29ya0JyZWFkY3J1bWJzXG4gICAgICAnZmV0Y2gnLFxuICAgICAgJ3hocicsXG4gICAgICAvLyBUaGVzZSB0d28gYXJlIGJyZWFkY3J1bWJzIGZvciBlbWl0dGVkIHNlbnRyeSBldmVudHMsIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlbVxuICAgICAgJ3NlbnRyeS5ldmVudCcsXG4gICAgICAnc2VudHJ5LnRyYW5zYWN0aW9uJyxcbiAgICBdLmluY2x1ZGVzKGJyZWFkY3J1bWIuY2F0ZWdvcnkpIHx8XG4gICAgLy8gV2UgY2FwdHVyZSBVSSBicmVhZGNydW1icyBzZXBhcmF0ZWx5XG4gICAgYnJlYWRjcnVtYi5jYXRlZ29yeS5zdGFydHNXaXRoKCd1aS4nKVxuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChicmVhZGNydW1iLmNhdGVnb3J5ID09PSAnY29uc29sZScpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQ29uc29sZUJyZWFkY3J1bWIoYnJlYWRjcnVtYik7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbn1cblxuLyoqIGV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBub3JtYWxpemVDb25zb2xlQnJlYWRjcnVtYihcbiAgYnJlYWRjcnVtYixcbikge1xuICBjb25zdCBhcmdzID0gYnJlYWRjcnVtYi5kYXRhPy5hcmd1bWVudHM7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJyZWFkY3J1bWIoYnJlYWRjcnVtYik7XG4gIH1cblxuICBsZXQgaXNUcnVuY2F0ZWQgPSBmYWxzZTtcblxuICAvLyBBdm9pZCBnaWFudCBhcmdzIGNhcHR1cmVzXG4gIGNvbnN0IG5vcm1hbGl6ZWRBcmdzID0gYXJncy5tYXAoYXJnID0+IHtcbiAgICBpZiAoIWFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IENPTlNPTEVfQVJHX01BWF9TSVpFKSB7XG4gICAgICAgIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke2FyZy5zbGljZSgwLCBDT05TT0xFX0FSR19NQVhfU0laRSl94oCmYDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQXJnID0gbm9ybWFsaXplKGFyZywgNyk7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZEFyZyk7XG4gICAgICAgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPiBDT05TT0xFX0FSR19NQVhfU0laRSkge1xuICAgICAgICAgIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBXZSB1c2UgdGhlIHByZXR0eSBwcmludGVkIEpTT04gc3RyaW5nIGhlcmUgYXMgYSBiYXNlXG4gICAgICAgICAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRBcmcsIG51bGwsIDIpLnNsaWNlKDAsIENPTlNPTEVfQVJHX01BWF9TSVpFKX3igKZgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkQXJnO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZztcbiAgfSk7XG5cbiAgcmV0dXJuIGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgZGF0YToge1xuICAgICAgLi4uYnJlYWRjcnVtYi5kYXRhLFxuICAgICAgYXJndW1lbnRzOiBub3JtYWxpemVkQXJncyxcbiAgICAgIC4uLihpc1RydW5jYXRlZCA/IHsgX21ldGE6IHsgd2FybmluZ3M6IFsnQ09OU09MRV9BUkdfVFJVTkNBVEVEJ10gfSB9IDoge30pLFxuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0JyZWFkY3J1bWJXaXRoQ2F0ZWdvcnkoYnJlYWRjcnVtYikge1xuICByZXR1cm4gISFicmVhZGNydW1iLmNhdGVnb3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3ZSB0aGluayB0aGUgZ2l2ZW4gZXZlbnQgaXMgYW4gZXJyb3Igb3JpZ2luYXRpbmcgaW5zaWRlIG9mIHJyd2ViLlxuICovXG5mdW5jdGlvbiBpc1Jyd2ViRXJyb3IoZXZlbnQsIGhpbnQpIHtcbiAgaWYgKGV2ZW50LnR5cGUgfHwgIWV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgbWF5IGJlIHNldCBieSBycndlYiB3aGVuIGl0IGZpbmRzIGVycm9yc1xuICBpZiAoaGludC5vcmlnaW5hbEV4Y2VwdGlvbj8uX19ycndlYl9fKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmVzZXQgdGhlIGByZXBsYXlfaWRgIGZpZWxkIG9uIHRoZSBEU0MuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0UmVwbGF5SWRPbkR5bmFtaWNTYW1wbGluZ0NvbnRleHQoKSB7XG4gIC8vIFJlc2V0IERTQyBvbiB0aGUgY3VycmVudCBzY29wZSwgaWYgdGhlcmUgaXMgb25lXG4gIGNvbnN0IGRzYyA9IGdldEN1cnJlbnRTY29wZSgpLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLmRzYztcbiAgaWYgKGRzYykge1xuICAgIGRlbGV0ZSBkc2MucmVwbGF5X2lkO1xuICB9XG5cbiAgLy8gQ2xlYXIgaXQgZnJvbSBmcm96ZW4gRFNDIG9uIHRoZSBhY3RpdmUgc3BhblxuICBjb25zdCBhY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICBpZiAoYWN0aXZlU3Bhbikge1xuICAgIGNvbnN0IGRzYyA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihhY3RpdmVTcGFuKTtcbiAgICBkZWxldGUgKGRzYyApLnJlcGxheV9pZDtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhIGZlZWRiYWNrIGJyZWFkY3J1bWIgZXZlbnQgdG8gcmVwbGF5LlxuICovXG5mdW5jdGlvbiBhZGRGZWVkYmFja0JyZWFkY3J1bWIocmVwbGF5LCBldmVudCkge1xuICByZXBsYXkudHJpZ2dlclVzZXJBY3Rpdml0eSgpO1xuICByZXBsYXkuYWRkVXBkYXRlKCgpID0+IHtcbiAgICBpZiAoIWV2ZW50LnRpbWVzdGFtcCkge1xuICAgICAgLy8gSWdub3JlIGV2ZW50cyB0aGF0IGRvbid0IGhhdmUgdGltZXN0YW1wcyAodGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBtb3JlIG9mIGEgdHlwaW5nIGlzc3VlKVxuICAgICAgLy8gUmV0dXJuIHRydWUgaGVyZSBzbyB0aGF0IHdlIGRvbid0IGZsdXNoXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciByZWplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgcmVwbGF5LnRocm90dGxlZEFkZEV2ZW50KHtcbiAgICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCAqIDEwMDAsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRhZzogJ2JyZWFkY3J1bWInLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgdGltZXN0YW1wOiBldmVudC50aW1lc3RhbXAsXG4gICAgICAgICAgdHlwZTogJ2RlZmF1bHQnLFxuICAgICAgICAgIGNhdGVnb3J5OiAnc2VudHJ5LmZlZWRiYWNrJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmZWVkYmFja0lkOiBldmVudC5ldmVudF9pZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9ICk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBldmVudCBzaG91bGQgYmUgc2FtcGxlZCAob25seSBhcHBsaWVzIGluIGJ1ZmZlciBtb2RlKS5cbiAqIFdoZW4gYW4gZXZlbnQgaXMgY2FwdHVyZWQgYnkgYGhhbmRsZUdsb2JhbEV2ZW50YCwgd2hlbiBpbiBidWZmZXIgbW9kZVxuICogd2UgZGV0ZXJtaW5lIGlmIHdlIHdhbnQgdG8gc2FtcGxlIHRoZSBlcnJvciBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNhbXBsZUZvckJ1ZmZlckV2ZW50KHJlcGxheSwgZXZlbnQpIHtcbiAgaWYgKHJlcGxheS5yZWNvcmRpbmdNb2RlICE9PSAnYnVmZmVyJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIGNvdWxkIGxvb3AgaW5kZWZpbml0ZWx5IHdpdGhcbiAgLy8gdHJ5aW5nIHRvIGNhcHR1cmUgcmVwbGF5IGFuZCBmYWlsaW5nXG4gIGlmIChldmVudC5tZXNzYWdlID09PSBVTkFCTEVfVE9fU0VORF9SRVBMQVkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZXF1aXJlIHRoZSBldmVudCB0byBiZSBhbiBlcnJvciBldmVudCAmIHRvIGhhdmUgYW4gZXhjZXB0aW9uXG4gIGlmICghZXZlbnQuZXhjZXB0aW9uIHx8IGV2ZW50LnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTYW1wbGVkKHJlcGxheS5nZXRPcHRpb25zKCkuZXJyb3JTYW1wbGVSYXRlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdGVuZXIgdG8gYmUgYWRkZWQgdG8gYGFkZEV2ZW50UHJvY2Vzc29yKGxpc3RlbmVyKWAuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUdsb2JhbEV2ZW50TGlzdGVuZXIocmVwbGF5KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIChldmVudCwgaGludCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXBsYXkgaGFzIGJlZW4gZGlzYWJsZWQgb3IgcGF1c2VkXG4gICAgICBpZiAoIXJlcGxheS5pc0VuYWJsZWQoKSB8fCByZXBsYXkuaXNQYXVzZWQoKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1JlcGxheUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAvLyBSZXBsYXlzIGhhdmUgc2VwYXJhdGUgc2V0IG9mIGJyZWFkY3J1bWJzLCBkbyBub3QgaW5jbHVkZSBicmVhZGNydW1ic1xuICAgICAgICAvLyBmcm9tIGNvcmUgU0RLXG4gICAgICAgIGRlbGV0ZSBldmVudC5icmVhZGNydW1icztcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gaGFuZGxlIGVycm9ycywgdHJhbnNhY3Rpb25zLCBhbmQgZmVlZGJhY2tzLCBub3RoaW5nIGVsc2VcbiAgICAgIGlmICghaXNFcnJvckV2ZW50KGV2ZW50KSAmJiAhaXNUcmFuc2FjdGlvbkV2ZW50KGV2ZW50KSAmJiAhaXNGZWVkYmFja0V2ZW50KGV2ZW50KSkge1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBkbyBub3QgYWRkIHJlcGxheV9pZCBpZiB0aGUgc2Vzc2lvbiBpcyBleHBpcmVkXG4gICAgICBjb25zdCBpc1Nlc3Npb25BY3RpdmUgPSByZXBsYXkuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpO1xuICAgICAgaWYgKCFpc1Nlc3Npb25BY3RpdmUpIHtcbiAgICAgICAgLy8gcHJldmVudCBleGNlZWRpbmcgcmVwbGF5IGR1cmF0aW9ucyBieSByZW1vdmluZyB0aGUgZXhwaXJlZCByZXBsYXlJZCBmcm9tIHRoZSBEU0NcbiAgICAgICAgcmVzZXRSZXBsYXlJZE9uRHluYW1pY1NhbXBsaW5nQ29udGV4dCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZlZWRiYWNrRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHJlcGxheS5mbHVzaCgpO1xuICAgICAgICBldmVudC5jb250ZXh0cy5mZWVkYmFjay5yZXBsYXlfaWQgPSByZXBsYXkuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgIC8vIEFkZCBhIHJlcGxheSBicmVhZGNydW1iIGZvciB0aGlzIHBpZWNlIG9mIGZlZWRiYWNrXG4gICAgICAgIGFkZEZlZWRiYWNrQnJlYWRjcnVtYihyZXBsYXksIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBVbmxlc3MgYGNhcHR1cmVFeGNlcHRpb25zYCBpcyBlbmFibGVkLCB3ZSB3YW50IHRvIGlnbm9yZSBlcnJvcnMgY29taW5nIGZyb20gcnJ3ZWJcbiAgICAgIC8vIEFzIHRoZXJlIGNhbiBiZSBhIGJ1bmNoIG9mIHN0dWZmIGdvaW5nIHdyb25nIGluIGludGVybmFscyB0aGVyZSwgdGhhdCB3ZSBkb24ndCB3YW50IHRvIGJ1YmJsZSB1cCB0byB1c2Vyc1xuICAgICAgaWYgKGlzUnJ3ZWJFcnJvcihldmVudCwgaGludCkgJiYgIXJlcGxheS5nZXRPcHRpb25zKCkuX2V4cGVyaW1lbnRzLmNhcHR1cmVFeGNlcHRpb25zKSB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnSWdub3JpbmcgZXJyb3IgZnJvbSBycndlYiBpbnRlcm5hbHMnLCBldmVudCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGluIGJ1ZmZlciBtb2RlLCB3ZSBkZWNpZGUgdG8gc2FtcGxlIGhlcmUuXG4gICAgICAvLyBMYXRlciwgaW4gYGhhbmRsZUFmdGVyU2VuZEV2ZW50YCwgaWYgdGhlIHJlcGxheUlkIGlzIHNldCwgd2Uga25vdyB0aGF0IHdlIHNhbXBsZWRcbiAgICAgIC8vIEFuZCBjb252ZXJ0IHRoZSBidWZmZXIgc2Vzc2lvbiB0byBhIGZ1bGwgc2Vzc2lvblxuICAgICAgY29uc3QgaXNFcnJvckV2ZW50U2FtcGxlZCA9IHNob3VsZFNhbXBsZUZvckJ1ZmZlckV2ZW50KHJlcGxheSwgZXZlbnQpO1xuXG4gICAgICAvLyBUYWcgZXJyb3JzIGlmIGl0IGhhcyBiZWVuIHNhbXBsZWQgaW4gYnVmZmVyIG1vZGUsIG9yIGlmIGl0IGlzIHNlc3Npb24gbW9kZVxuICAgICAgLy8gT25seSB0YWcgdHJhbnNhY3Rpb25zIGlmIGluIHNlc3Npb24gbW9kZVxuICAgICAgY29uc3Qgc2hvdWxkVGFnUmVwbGF5SWQgPSBpc0Vycm9yRXZlbnRTYW1wbGVkIHx8IHJlcGxheS5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbic7XG5cbiAgICAgIGlmIChzaG91bGRUYWdSZXBsYXlJZCkge1xuICAgICAgICBldmVudC50YWdzID0geyAuLi5ldmVudC50YWdzLCByZXBsYXlJZDogcmVwbGF5LmdldFNlc3Npb25JZCgpIH07XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIHNhbXBsZWQgdGhpcyBlcnJvciBpbiBidWZmZXIgbW9kZSwgaW1tZWRpYXRlbHkgbWFyayB0aGUgc2Vzc2lvbiBhcyBcInNhbXBsZWRcIlxuICAgICAgLy8gYnkgY2hhbmdpbmcgdGhlIHNhbXBsZWQgc3RhdGUgZnJvbSAnYnVmZmVyJyB0byAnc2Vzc2lvbicuIE90aGVyd2lzZSwgaWYgdGhlIGFwcGxpY2F0aW9uIGlzIGludGVycnVwdGVcbiAgICAgIC8vIGJlZm9yZSBgYWZ0ZXJTZW5kRXZlbnRgIG9jY3VycywgdGhlbiB0aGUgc2Vzc2lvbiB3b3VsZCByZW1haW4gYXMgXCJidWZmZXJcIiBidXQgd2UgaGF2ZSBhbiBlcnJvciBldmVudFxuICAgICAgLy8gdGhhdCBpcyB0YWdnZWQgd2l0aCBhIHJlcGxheSBpZC4gVGhpcyBjb3VsZCBlbmQgdXAgY3JlYXRpbmcgcmVwbGF5cyB3LyBleGNlc3NpdmUgZHVyYXRpb25zIGJlY2F1c2VcbiAgICAgIC8vIG9mIHRoZSBsaW5rZWQgZXJyb3IuXG4gICAgICBpZiAoaXNFcnJvckV2ZW50U2FtcGxlZCAmJiByZXBsYXkucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicgJiYgcmVwbGF5LnNlc3Npb24/LnNhbXBsZWQgPT09ICdidWZmZXInKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSByZXBsYXkuc2Vzc2lvbjtcbiAgICAgICAgc2Vzc2lvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIC8vIFNhdmUgdGhlIHNlc3Npb24gaWYgc3RpY2t5IHNlc3Npb25zIGFyZSBlbmFibGVkIHRvIHBlcnNpc3QgdGhlIHN0YXRlIGNoYW5nZVxuICAgICAgICBpZiAocmVwbGF5LmdldE9wdGlvbnMoKS5zdGlja3lTZXNzaW9uKSB7XG4gICAgICAgICAgc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG4gICAgeyBpZDogJ1JlcGxheScgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBcInNwYW5cIiBmb3IgZWFjaCBwZXJmb3JtYW5jZSBlbnRyeS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGVyZm9ybWFuY2VTcGFucyhcbiAgcmVwbGF5LFxuICBlbnRyaWVzLFxuKSB7XG4gIHJldHVybiBlbnRyaWVzLm1hcCgoeyB0eXBlLCBzdGFydCwgZW5kLCBuYW1lLCBkYXRhIH0pID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IHJlcGxheS50aHJvdHRsZWRBZGRFdmVudCh7XG4gICAgICB0eXBlOiBFdmVudFR5cGUuQ3VzdG9tLFxuICAgICAgdGltZXN0YW1wOiBzdGFydCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFnOiAncGVyZm9ybWFuY2VTcGFuJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIG9wOiB0eXBlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBuYW1lLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wOiBzdGFydCxcbiAgICAgICAgICBlbmRUaW1lc3RhbXA6IGVuZCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIElmIHJlc3BvbnNlIGlzIGEgc3RyaW5nLCBpdCBtZWFucyBpdHMgZWl0aGVyIFRIUk9UVExFRCBvciBTS0lQUEVEXG4gICAgcmV0dXJuIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiByZXNwb25zZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUhpc3RvcnkoaGFuZGxlckRhdGEpIHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gaGFuZGxlckRhdGE7XG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnbmF2aWdhdGlvbi5wdXNoJyxcbiAgICBzdGFydDogbm93LFxuICAgIGVuZDogbm93LFxuICAgIG5hbWU6IHRvLFxuICAgIGRhdGE6IHtcbiAgICAgIHByZXZpb3VzOiBmcm9tLFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3RlbmVyIHRvIGJlIGFkZGVkIHRvIGBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcihsaXN0ZW5lcilgLlxuICovXG5mdW5jdGlvbiBoYW5kbGVIaXN0b3J5U3Bhbkxpc3RlbmVyKHJlcGxheSkge1xuICByZXR1cm4gKGhhbmRsZXJEYXRhKSA9PiB7XG4gICAgaWYgKCFyZXBsYXkuaXNFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBoYW5kbGVIaXN0b3J5KGhhbmRsZXJEYXRhKTtcblxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOZWVkIHRvIGNvbGxlY3QgdmlzaXRlZCBVUkxzXG4gICAgcmVwbGF5LmdldENvbnRleHQoKS51cmxzLnB1c2gocmVzdWx0Lm5hbWUpO1xuICAgIHJlcGxheS50cmlnZ2VyVXNlckFjdGl2aXR5KCk7XG5cbiAgICByZXBsYXkuYWRkVXBkYXRlKCgpID0+IHtcbiAgICAgIGNyZWF0ZVBlcmZvcm1hbmNlU3BhbnMocmVwbGF5LCBbcmVzdWx0XSk7XG4gICAgICAvLyBSZXR1cm5pbmcgZmFsc2UgdG8gZmx1c2hcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gcmVxdWVzdCBVUkwgc2hvdWxkIGJlIGZpbHRlcmVkIG91dC4gVGhpcyBpcyBzbyB3ZVxuICogZG9uJ3QgbG9nIFNlbnRyeSBpbmdlc3QgcmVxdWVzdHMuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEZpbHRlclJlcXVlc3QocmVwbGF5LCB1cmwpIHtcbiAgLy8gSWYgd2UgZW5hYmxlZCB0aGUgYHRyYWNlSW50ZXJuYWxzYCBleHBlcmltZW50LCB3ZSB3YW50IHRvIHRyYWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKERFQlVHX0JVSUxEICYmIHJlcGxheS5nZXRPcHRpb25zKCkuX2V4cGVyaW1lbnRzLnRyYWNlSW50ZXJuYWxzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2VudHJ5UmVxdWVzdFVybCh1cmwsIGdldENsaWVudCgpKTtcbn1cblxuLyoqIEFkZCBhIHBlcmZvcm1hbmNlIGVudHJ5IGJyZWFkY3J1bWIgKi9cbmZ1bmN0aW9uIGFkZE5ldHdvcmtCcmVhZGNydW1iKFxuICByZXBsYXksXG4gIHJlc3VsdCxcbikge1xuICBpZiAoIXJlcGxheS5pc0VuYWJsZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2hvdWxkRmlsdGVyUmVxdWVzdChyZXBsYXksIHJlc3VsdC5uYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlcGxheS5hZGRVcGRhdGUoKCkgPT4ge1xuICAgIGNyZWF0ZVBlcmZvcm1hbmNlU3BhbnMocmVwbGF5LCBbcmVzdWx0XSk7XG4gICAgLy8gUmV0dXJuaW5nIHRydWUgd2lsbCBjYXVzZSBgYWRkVXBkYXRlYCB0byBub3QgZmx1c2hcbiAgICAvLyBXZSBkbyBub3Qgd2FudCBuZXR3b3JrIHJlcXVlc3RzIHRvIGNhdXNlIGEgZmx1c2guIFRoaXMgd2lsbCBwcmV2ZW50XG4gICAgLy8gcmVjdXJyaW5nL3BvbGxpbmcgcmVxdWVzdHMgZnJvbSBrZWVwaW5nIHRoZSByZXBsYXkgc2Vzc2lvbiBhbGl2ZS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKiBHZXQgdGhlIHNpemUgb2YgYSBib2R5LiAqL1xuZnVuY3Rpb24gZ2V0Qm9keVNpemUoYm9keSkge1xuICBpZiAoIWJvZHkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoYm9keSkubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGJvZHkudG9TdHJpbmcoKSkubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhU3RyID0gc2VyaWFsaXplRm9ybURhdGEoYm9keSk7XG4gICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1EYXRhU3RyKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICByZXR1cm4gYm9keS5zaXplO1xuICAgIH1cblxuICAgIGlmIChib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudGx5IHVuaGFuZGxlZCB0eXBlczogQXJyYXlCdWZmZXJWaWV3LCBSZWFkYWJsZVN0cmVhbVxuICB9IGNhdGNoIHtcbiAgICAvLyBqdXN0IHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKiBDb252ZXJ0IGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHRvIG51bWJlci91bmRlZmluZWQuICAqL1xuZnVuY3Rpb24gcGFyc2VDb250ZW50TGVuZ3RoSGVhZGVyKGhlYWRlcikge1xuICBpZiAoIWhlYWRlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzaXplID0gcGFyc2VJbnQoaGVhZGVyLCAxMCk7XG4gIHJldHVybiBpc05hTihzaXplKSA/IHVuZGVmaW5lZCA6IHNpemU7XG59XG5cbi8qKiBNZXJnZSBhIHdhcm5pbmcgaW50byBhbiBleGlzdGluZyBuZXR3b3JrIHJlcXVlc3QvcmVzcG9uc2UuICovXG5mdW5jdGlvbiBtZXJnZVdhcm5pbmcoXG4gIGluZm8sXG4gIHdhcm5pbmcsXG4pIHtcbiAgaWYgKCFpbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgX21ldGE6IHtcbiAgICAgICAgd2FybmluZ3M6IFt3YXJuaW5nXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG5ld01ldGEgPSB7IC4uLmluZm8uX21ldGEgfTtcbiAgY29uc3QgZXhpc3RpbmdXYXJuaW5ncyA9IG5ld01ldGEud2FybmluZ3MgfHwgW107XG4gIG5ld01ldGEud2FybmluZ3MgPSBbLi4uZXhpc3RpbmdXYXJuaW5ncywgd2FybmluZ107XG5cbiAgaW5mby5fbWV0YSA9IG5ld01ldGE7XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKiogQ29udmVydCBSZXBsYXlOZXR3b3JrUmVxdWVzdERhdGEgdG8gYSBQZXJmb3JtYW5jZUVudHJ5LiAqL1xuZnVuY3Rpb24gbWFrZU5ldHdvcmtSZXBsYXlCcmVhZGNydW1iKFxuICB0eXBlLFxuICBkYXRhLFxuKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgeyBzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wLCB1cmwsIG1ldGhvZCwgc3RhdHVzQ29kZSwgcmVxdWVzdCwgcmVzcG9uc2UgfSA9IGRhdGE7XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHR5cGUsXG4gICAgc3RhcnQ6IHN0YXJ0VGltZXN0YW1wIC8gMTAwMCxcbiAgICBlbmQ6IGVuZFRpbWVzdGFtcCAvIDEwMDAsXG4gICAgbmFtZTogdXJsLFxuICAgIGRhdGE6IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVzcG9uc2UsXG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQnVpbGQgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2UgcGFydCBvZiBhIHJlcGxheSBuZXR3b3JrIGJyZWFkY3J1bWIgdGhhdCB3YXMgc2tpcHBlZC4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2tpcHBlZE5ldHdvcmtSZXF1ZXN0T3JSZXNwb25zZShib2R5U2l6ZSkge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcnM6IHt9LFxuICAgIHNpemU6IGJvZHlTaXplLFxuICAgIF9tZXRhOiB7XG4gICAgICB3YXJuaW5nczogWydVUkxfU0tJUFBFRCddLFxuICAgIH0sXG4gIH07XG59XG5cbi8qKiBCdWlsZCB0aGUgcmVxdWVzdCBvciByZXNwb25zZSBwYXJ0IG9mIGEgcmVwbGF5IG5ldHdvcmsgYnJlYWRjcnVtYi4gKi9cbmZ1bmN0aW9uIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKFxuICBoZWFkZXJzLFxuICBib2R5U2l6ZSxcbiAgYm9keSxcbikge1xuICBpZiAoIWJvZHlTaXplICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWJvZHlTaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmICghYm9keSkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgc2l6ZTogYm9keVNpemUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGluZm8gPSB7XG4gICAgaGVhZGVycyxcbiAgICBzaXplOiBib2R5U2l6ZSxcbiAgfTtcblxuICBjb25zdCB7IGJvZHk6IG5vcm1hbGl6ZWRCb2R5LCB3YXJuaW5ncyB9ID0gbm9ybWFsaXplTmV0d29ya0JvZHkoYm9keSk7XG4gIGluZm8uYm9keSA9IG5vcm1hbGl6ZWRCb2R5O1xuICBpZiAod2FybmluZ3M/Lmxlbmd0aCkge1xuICAgIGluZm8uX21ldGEgPSB7XG4gICAgICB3YXJuaW5ncyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKiBGaWx0ZXIgYSBzZXQgb2YgaGVhZGVycyAqL1xuZnVuY3Rpb24gZ2V0QWxsb3dlZEhlYWRlcnMoaGVhZGVycywgYWxsb3dlZEhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpLnJlZHVjZSgoZmlsdGVyZWRIZWFkZXJzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQXZvaWQgcHV0dGluZyBlbXB0eSBzdHJpbmdzIGludG8gdGhlIGhlYWRlcnNcbiAgICBpZiAoYWxsb3dlZEhlYWRlcnMuaW5jbHVkZXMobm9ybWFsaXplZEtleSkgJiYgaGVhZGVyc1trZXldKSB7XG4gICAgICBmaWx0ZXJlZEhlYWRlcnNbbm9ybWFsaXplZEtleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkSGVhZGVycztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOZXR3b3JrQm9keShib2R5KVxuXG4ge1xuICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGV4Y2VlZHNTaXplTGltaXQgPSBib2R5Lmxlbmd0aCA+IE5FVFdPUktfQk9EWV9NQVhfU0laRTtcbiAgY29uc3QgaXNQcm9iYWJseUpzb24gPSBfc3RySXNQcm9iYWJseUpzb24oYm9keSk7XG5cbiAgaWYgKGV4Y2VlZHNTaXplTGltaXQpIHtcbiAgICBjb25zdCB0cnVuY2F0ZWRCb2R5ID0gYm9keS5zbGljZSgwLCBORVRXT1JLX0JPRFlfTUFYX1NJWkUpO1xuXG4gICAgaWYgKGlzUHJvYmFibHlKc29uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiB0cnVuY2F0ZWRCb2R5LFxuICAgICAgICB3YXJuaW5nczogWydNQVlCRV9KU09OX1RSVU5DQVRFRCddLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogYCR7dHJ1bmNhdGVkQm9keX3igKZgLFxuICAgICAgd2FybmluZ3M6IFsnVEVYVF9UUlVOQ0FURUQnXSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzUHJvYmFibHlKc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpzb25Cb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvZHk6IGpzb25Cb2R5LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGZhbGwgYmFjayB0byBqdXN0IHNlbmQgdGhlIGJvZHkgYXMgc3RyaW5nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib2R5LFxuICB9O1xufVxuXG5mdW5jdGlvbiBfc3RySXNQcm9iYWJseUpzb24oc3RyKSB7XG4gIGNvbnN0IGZpcnN0ID0gc3RyWzBdO1xuICBjb25zdCBsYXN0ID0gc3RyW3N0ci5sZW5ndGggLSAxXTtcblxuICAvLyBTaW1wbGUgY2hlY2s6IElmIHRoaXMgZG9lcyBub3Qgc3RhcnQgJiBlbmQgd2l0aCB7fSBvciBbXSwgaXQncyBub3QgSlNPTlxuICByZXR1cm4gKGZpcnN0ID09PSAnWycgJiYgbGFzdCA9PT0gJ10nKSB8fCAoZmlyc3QgPT09ICd7JyAmJiBsYXN0ID09PSAnfScpO1xufVxuXG4vKiogTWF0Y2ggYW4gVVJMIGFnYWluc3QgYSBsaXN0IG9mIHN0cmluZ3MvUmVnZXguICovXG5mdW5jdGlvbiB1cmxNYXRjaGVzKHVybCwgdXJscykge1xuICBjb25zdCBmdWxsVXJsID0gZ2V0RnVsbFVybCh1cmwpO1xuXG4gIHJldHVybiBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4oZnVsbFVybCwgdXJscyk7XG59XG5cbi8qKiBleHBvcnRlZCBmb3IgdGVzdHMgKi9cbmZ1bmN0aW9uIGdldEZ1bGxVcmwodXJsLCBiYXNlVVJJID0gV0lORE9XLmRvY3VtZW50LmJhc2VVUkkpIHtcbiAgLy8gU2hvcnQgY2lyY3VpdCBmb3IgY29tbW9uIGNhc2VzOlxuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aChXSU5ET1cubG9jYXRpb24ub3JpZ2luKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgY29uc3QgZml4ZWRVcmwgPSBuZXcgVVJMKHVybCwgYmFzZVVSSSk7XG5cbiAgLy8gSWYgdGhlc2UgZG8gbm90IG1hdGNoLCB3ZSBhcmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlbGF0aXZlIFVSTCwgc28ganVzdCByZXR1cm4gaXRcbiAgaWYgKGZpeGVkVXJsLm9yaWdpbiAhPT0gbmV3IFVSTChiYXNlVVJJKS5vcmlnaW4pIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgY29uc3QgZnVsbFVybCA9IGZpeGVkVXJsLmhyZWY7XG5cbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMsIGlmIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlIG9yaWdpbmFsIFVSTFxuICBpZiAoIXVybC5lbmRzV2l0aCgnLycpICYmIGZ1bGxVcmwuZW5kc1dpdGgoJy8nKSkge1xuICAgIHJldHVybiBmdWxsVXJsLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIHJldHVybiBmdWxsVXJsO1xufVxuXG4vKipcbiAqIENhcHR1cmUgYSBmZXRjaCBicmVhZGNydW1iIHRvIGEgcmVwbGF5LlxuICogVGhpcyBhZGRzIGFkZGl0aW9uYWwgZGF0YSAod2hlcmUgYXBwcm9wcmlhdGUpLlxuICovXG5hc3luYyBmdW5jdGlvbiBjYXB0dXJlRmV0Y2hCcmVhZGNydW1iVG9SZXBsYXkoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4gIG9wdGlvbnNcblxuLFxuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IF9wcmVwYXJlRmV0Y2hEYXRhKGJyZWFkY3J1bWIsIGhpbnQsIG9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcmVwbGF5IHBlcmZvcm1hbmNlIGVudHJ5IGZyb20gdGhpcyBicmVhZGNydW1iXG4gICAgY29uc3QgcmVzdWx0ID0gbWFrZU5ldHdvcmtSZXBsYXlCcmVhZGNydW1iKCdyZXNvdXJjZS5mZXRjaCcsIGRhdGEpO1xuICAgIGFkZE5ldHdvcmtCcmVhZGNydW1iKG9wdGlvbnMucmVwbGF5LCByZXN1bHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBjYXB0dXJlIGZldGNoIGJyZWFkY3J1bWInKTtcbiAgfVxufVxuXG4vKipcbiAqIEVucmljaCBhIGJyZWFkY3J1bWIgd2l0aCBhZGRpdGlvbmFsIGRhdGEuXG4gKiBUaGlzIGhhcyB0byBiZSBzeW5jICYgbXV0YXRlIHRoZSBnaXZlbiBicmVhZGNydW1iLFxuICogYXMgdGhlIGJyZWFkY3J1bWIgaXMgYWZ0ZXJ3YXJkcyBjb25zdW1lZCBieSBvdGhlciBoYW5kbGVycy5cbiAqL1xuZnVuY3Rpb24gZW5yaWNoRmV0Y2hCcmVhZGNydW1iKFxuICBicmVhZGNydW1iLFxuICBoaW50LFxuKSB7XG4gIGNvbnN0IHsgaW5wdXQsIHJlc3BvbnNlIH0gPSBoaW50O1xuXG4gIGNvbnN0IGJvZHkgPSBpbnB1dCA/IGdldEZldGNoUmVxdWVzdEFyZ0JvZHkoaW5wdXQpIDogdW5kZWZpbmVkO1xuICBjb25zdCByZXFTaXplID0gZ2V0Qm9keVNpemUoYm9keSk7XG5cbiAgY29uc3QgcmVzU2l6ZSA9IHJlc3BvbnNlID8gcGFyc2VDb250ZW50TGVuZ3RoSGVhZGVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpKSA6IHVuZGVmaW5lZDtcblxuICBpZiAocmVxU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYnJlYWRjcnVtYi5kYXRhLnJlcXVlc3RfYm9keV9zaXplID0gcmVxU2l6ZTtcbiAgfVxuICBpZiAocmVzU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYnJlYWRjcnVtYi5kYXRhLnJlc3BvbnNlX2JvZHlfc2l6ZSA9IHJlc1NpemU7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3ByZXBhcmVGZXRjaERhdGEoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4gIG9wdGlvbnMsXG4pIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgeyBzdGFydFRpbWVzdGFtcCA9IG5vdywgZW5kVGltZXN0YW1wID0gbm93IH0gPSBoaW50O1xuXG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIHN0YXR1c19jb2RlOiBzdGF0dXNDb2RlID0gMCxcbiAgICByZXF1ZXN0X2JvZHlfc2l6ZTogcmVxdWVzdEJvZHlTaXplLFxuICAgIHJlc3BvbnNlX2JvZHlfc2l6ZTogcmVzcG9uc2VCb2R5U2l6ZSxcbiAgfSA9IGJyZWFkY3J1bWIuZGF0YTtcblxuICBjb25zdCBjYXB0dXJlRGV0YWlscyA9XG4gICAgdXJsTWF0Y2hlcyh1cmwsIG9wdGlvbnMubmV0d29ya0RldGFpbEFsbG93VXJscykgJiYgIXVybE1hdGNoZXModXJsLCBvcHRpb25zLm5ldHdvcmtEZXRhaWxEZW55VXJscyk7XG5cbiAgY29uc3QgcmVxdWVzdCA9IGNhcHR1cmVEZXRhaWxzXG4gICAgPyBfZ2V0UmVxdWVzdEluZm8ob3B0aW9ucywgaGludC5pbnB1dCwgcmVxdWVzdEJvZHlTaXplKVxuICAgIDogYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHJlcXVlc3RCb2R5U2l6ZSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2dldFJlc3BvbnNlSW5mbyhjYXB0dXJlRGV0YWlscywgb3B0aW9ucywgaGludC5yZXNwb25zZSwgcmVzcG9uc2VCb2R5U2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWVzdGFtcCxcbiAgICBlbmRUaW1lc3RhbXAsXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlcXVlc3QsXG4gICAgcmVzcG9uc2UsXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXF1ZXN0SW5mbyhcbiAgeyBuZXR3b3JrQ2FwdHVyZUJvZGllcywgbmV0d29ya1JlcXVlc3RIZWFkZXJzIH0sXG4gIGlucHV0LFxuICByZXF1ZXN0Qm9keVNpemUsXG4pIHtcbiAgY29uc3QgaGVhZGVycyA9IGlucHV0ID8gZ2V0UmVxdWVzdEhlYWRlcnMoaW5wdXQsIG5ldHdvcmtSZXF1ZXN0SGVhZGVycykgOiB7fTtcblxuICBpZiAoIW5ldHdvcmtDYXB0dXJlQm9kaWVzKSB7XG4gICAgcmV0dXJuIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHJlcXVlc3RCb2R5U2l6ZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIFdlIG9ubHkgd2FudCB0byB0cmFuc21pdCBzdHJpbmcgb3Igc3RyaW5nLWxpa2UgYm9kaWVzXG4gIGNvbnN0IHJlcXVlc3RCb2R5ID0gZ2V0RmV0Y2hSZXF1ZXN0QXJnQm9keShpbnB1dCk7XG4gIGNvbnN0IFtib2R5U3RyLCB3YXJuaW5nXSA9IGdldEJvZHlTdHJpbmcocmVxdWVzdEJvZHksIGRlYnVnKTtcbiAgY29uc3QgZGF0YSA9IGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHJlcXVlc3RCb2R5U2l6ZSwgYm9keVN0cik7XG5cbiAgaWYgKHdhcm5pbmcpIHtcbiAgICByZXR1cm4gbWVyZ2VXYXJuaW5nKGRhdGEsIHdhcm5pbmcpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRSZXNwb25zZUluZm8oXG4gIGNhcHR1cmVEZXRhaWxzLFxuICB7XG4gICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgbmV0d29ya1Jlc3BvbnNlSGVhZGVycyxcbiAgfSxcbiAgcmVzcG9uc2UsXG4gIHJlc3BvbnNlQm9keVNpemUsXG4pIHtcbiAgaWYgKCFjYXB0dXJlRGV0YWlscyAmJiByZXNwb25zZUJvZHlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHJlc3BvbnNlQm9keVNpemUpO1xuICB9XG5cbiAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlID8gZ2V0QWxsSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzLCBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSA6IHt9O1xuXG4gIGlmICghcmVzcG9uc2UgfHwgKCFuZXR3b3JrQ2FwdHVyZUJvZGllcyAmJiByZXNwb25zZUJvZHlTaXplICE9PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHJlc3BvbnNlQm9keVNpemUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICBjb25zdCBbYm9keVRleHQsIHdhcm5pbmddID0gYXdhaXQgX3BhcnNlRmV0Y2hSZXNwb25zZUJvZHkocmVzcG9uc2UpO1xuICBjb25zdCByZXN1bHQgPSBnZXRSZXNwb25zZURhdGEoYm9keVRleHQsIHtcbiAgICBuZXR3b3JrQ2FwdHVyZUJvZGllcyxcblxuICAgIHJlc3BvbnNlQm9keVNpemUsXG4gICAgY2FwdHVyZURldGFpbHMsXG4gICAgaGVhZGVycyxcbiAgfSk7XG5cbiAgaWYgKHdhcm5pbmcpIHtcbiAgICByZXR1cm4gbWVyZ2VXYXJuaW5nKHJlc3VsdCwgd2FybmluZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEoXG4gIGJvZHlUZXh0LFxuICB7XG4gICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgcmVzcG9uc2VCb2R5U2l6ZSxcbiAgICBjYXB0dXJlRGV0YWlscyxcbiAgICBoZWFkZXJzLFxuICB9XG5cbixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHNpemUgPSBib2R5VGV4dD8ubGVuZ3RoICYmIHJlc3BvbnNlQm9keVNpemUgPT09IHVuZGVmaW5lZCA/IGdldEJvZHlTaXplKGJvZHlUZXh0KSA6IHJlc3BvbnNlQm9keVNpemU7XG5cbiAgICBpZiAoIWNhcHR1cmVEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHNpemUpO1xuICAgIH1cblxuICAgIGlmIChuZXR3b3JrQ2FwdHVyZUJvZGllcykge1xuICAgICAgcmV0dXJuIGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKGhlYWRlcnMsIHNpemUsIGJvZHlUZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbGROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UoaGVhZGVycywgc2l6ZSwgdW5kZWZpbmVkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5leGNlcHRpb24oZXJyb3IsICdGYWlsZWQgdG8gc2VyaWFsaXplIHJlc3BvbnNlIGJvZHknKTtcbiAgICAvLyBmYWxsYmFja1xuICAgIHJldHVybiBidWlsZE5ldHdvcmtSZXF1ZXN0T3JSZXNwb25zZShoZWFkZXJzLCByZXNwb25zZUJvZHlTaXplLCB1bmRlZmluZWQpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9wYXJzZUZldGNoUmVzcG9uc2VCb2R5KHJlc3BvbnNlKSB7XG4gIGNvbnN0IHJlcyA9IF90cnlDbG9uZVJlc3BvbnNlKHJlc3BvbnNlKTtcblxuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCAnQk9EWV9QQVJTRV9FUlJPUiddO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgX3RyeUdldFJlc3BvbnNlVGV4dChyZXMpO1xuICAgIHJldHVybiBbdGV4dF07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmRleE9mKCdUaW1lb3V0JykgPiAtMSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcud2FybignUGFyc2luZyB0ZXh0IGJvZHkgZnJvbSByZXNwb25zZSB0aW1lZCBvdXQnKTtcbiAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAnQk9EWV9QQVJTRV9USU1FT1VUJ107XG4gICAgfVxuXG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXhjZXB0aW9uKGVycm9yLCAnRmFpbGVkIHRvIGdldCB0ZXh0IGJvZHkgZnJvbSByZXNwb25zZScpO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCAnQk9EWV9QQVJTRV9FUlJPUiddO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbEhlYWRlcnMoaGVhZGVycywgYWxsb3dlZEhlYWRlcnMpIHtcbiAgY29uc3QgYWxsSGVhZGVycyA9IHt9O1xuXG4gIGFsbG93ZWRIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICBpZiAoaGVhZGVycy5nZXQoaGVhZGVyKSkge1xuICAgICAgYWxsSGVhZGVyc1toZWFkZXJdID0gaGVhZGVycy5nZXQoaGVhZGVyKSA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWxsSGVhZGVycztcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdEhlYWRlcnMoZmV0Y2hBcmdzLCBhbGxvd2VkSGVhZGVycykge1xuICBpZiAoZmV0Y2hBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZmV0Y2hBcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXRIZWFkZXJzRnJvbU9wdGlvbnMoZmV0Y2hBcmdzWzBdICwgYWxsb3dlZEhlYWRlcnMpO1xuICB9XG5cbiAgaWYgKGZldGNoQXJncy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0SGVhZGVyc0Zyb21PcHRpb25zKGZldGNoQXJnc1sxXSAsIGFsbG93ZWRIZWFkZXJzKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc0Zyb21PcHRpb25zKFxuICBpbnB1dCxcbiAgYWxsb3dlZEhlYWRlcnMsXG4pIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSBpbnB1dC5oZWFkZXJzO1xuXG4gIGlmICghaGVhZGVycykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIHJldHVybiBnZXRBbGxIZWFkZXJzKGhlYWRlcnMsIGFsbG93ZWRIZWFkZXJzKTtcbiAgfVxuXG4gIC8vIFdlIGRvIG5vdCBzdXBwb3J0IHRoaXMsIGFzIGl0IGlzIG5vdCByZWFsbHkgZG9jdW1lbnRlZCAoYW55bW9yZT8pXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGdldEFsbG93ZWRIZWFkZXJzKGhlYWRlcnMsIGFsbG93ZWRIZWFkZXJzKTtcbn1cblxuZnVuY3Rpb24gX3RyeUNsb25lUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBXZSBoYXZlIHRvIGNsb25lIHRoaXMsIGFzIHRoZSBib2R5IGNhbiBvbmx5IGJlIHJlYWQgb25jZVxuICAgIHJldHVybiByZXNwb25zZS5jbG9uZSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIHRoaXMgY2FuIHRocm93IGlmIHRoZSByZXNwb25zZSB3YXMgYWxyZWFkeSBjb25zdW1lZCBiZWZvcmVcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5leGNlcHRpb24oZXJyb3IsICdGYWlsZWQgdG8gY2xvbmUgcmVzcG9uc2UgYm9keScpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSByZXNwb25zZSBib2R5IG9mIGEgZmV0Y2ggcmVxdWVzdCwgb3IgdGltZW91dCBhZnRlciA1MDBtcy5cbiAqIEZldGNoIGNhbiByZXR1cm4gYSBzdHJlYW1pbmcgYm9keSwgdGhhdCBtYXkgbm90IHJlc29sdmUgKG9yIG5vdCBmb3IgYSBsb25nIHRpbWUpLlxuICogSWYgdGhhdCBoYXBwZW5zLCB3ZSByYXRoZXIgYWJvcnQgYWZ0ZXIgYSBzaG9ydCB0aW1lIHRoYW4ga2VlcCB3YWl0aW5nIGZvciB0aGlzLlxuICovXG5mdW5jdGlvbiBfdHJ5R2V0UmVzcG9uc2VUZXh0KHJlc3BvbnNlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQkMygoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0IHdoaWxlIHRyeWluZyB0byByZWFkIHJlc3BvbnNlIGJvZHknKSksIDUwMCk7XG5cbiAgICBfZ2V0UmVzcG9uc2VUZXh0KHJlc3BvbnNlKVxuICAgICAgLnRoZW4oXG4gICAgICAgIHR4dCA9PiByZXNvbHZlKHR4dCksXG4gICAgICAgIHJlYXNvbiA9PiByZWplY3QocmVhc29uKSxcbiAgICAgIClcbiAgICAgIC5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfZ2V0UmVzcG9uc2VUZXh0KHJlc3BvbnNlKSB7XG4gIC8vIEZvcmNlIHRoaXMgdG8gYmUgYSBwcm9taXNlLCBqdXN0IHRvIGJlIHNhZmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hd2FpdFxuICByZXR1cm4gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xufVxuXG4vKipcbiAqIENhcHR1cmUgYW4gWEhSIGJyZWFkY3J1bWIgdG8gYSByZXBsYXkuXG4gKiBUaGlzIGFkZHMgYWRkaXRpb25hbCBkYXRhICh3aGVyZSBhcHByb3ByaWF0ZSkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhcHR1cmVYaHJCcmVhZGNydW1iVG9SZXBsYXkoXG4gIGJyZWFkY3J1bWIsXG4gIGhpbnQsXG4gIG9wdGlvbnMsXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gX3ByZXBhcmVYaHJEYXRhKGJyZWFkY3J1bWIsIGhpbnQsIG9wdGlvbnMpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcmVwbGF5IHBlcmZvcm1hbmNlIGVudHJ5IGZyb20gdGhpcyBicmVhZGNydW1iXG4gICAgY29uc3QgcmVzdWx0ID0gbWFrZU5ldHdvcmtSZXBsYXlCcmVhZGNydW1iKCdyZXNvdXJjZS54aHInLCBkYXRhKTtcbiAgICBhZGROZXR3b3JrQnJlYWRjcnVtYihvcHRpb25zLnJlcGxheSwgcmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5leGNlcHRpb24oZXJyb3IsICdGYWlsZWQgdG8gY2FwdHVyZSB4aHIgYnJlYWRjcnVtYicpO1xuICB9XG59XG5cbi8qKlxuICogRW5yaWNoIGEgYnJlYWRjcnVtYiB3aXRoIGFkZGl0aW9uYWwgZGF0YS5cbiAqIFRoaXMgaGFzIHRvIGJlIHN5bmMgJiBtdXRhdGUgdGhlIGdpdmVuIGJyZWFkY3J1bWIsXG4gKiBhcyB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIGNvbnN1bWVkIGJ5IG90aGVyIGhhbmRsZXJzLlxuICovXG5mdW5jdGlvbiBlbnJpY2hYaHJCcmVhZGNydW1iKFxuICBicmVhZGNydW1iLFxuICBoaW50LFxuKSB7XG4gIGNvbnN0IHsgeGhyLCBpbnB1dCB9ID0gaGludDtcblxuICBpZiAoIXhocikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlcVNpemUgPSBnZXRCb2R5U2l6ZShpbnB1dCk7XG4gIGNvbnN0IHJlc1NpemUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJylcbiAgICA/IHBhcnNlQ29udGVudExlbmd0aEhlYWRlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpXG4gICAgOiBfZ2V0Qm9keVNpemUoeGhyLnJlc3BvbnNlLCB4aHIucmVzcG9uc2VUeXBlKTtcblxuICBpZiAocmVxU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYnJlYWRjcnVtYi5kYXRhLnJlcXVlc3RfYm9keV9zaXplID0gcmVxU2l6ZTtcbiAgfVxuICBpZiAocmVzU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYnJlYWRjcnVtYi5kYXRhLnJlc3BvbnNlX2JvZHlfc2l6ZSA9IHJlc1NpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3ByZXBhcmVYaHJEYXRhKFxuICBicmVhZGNydW1iLFxuICBoaW50LFxuICBvcHRpb25zLFxuKSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHsgc3RhcnRUaW1lc3RhbXAgPSBub3csIGVuZFRpbWVzdGFtcCA9IG5vdywgaW5wdXQsIHhociB9ID0gaGludDtcblxuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBzdGF0dXNfY29kZTogc3RhdHVzQ29kZSA9IDAsXG4gICAgcmVxdWVzdF9ib2R5X3NpemU6IHJlcXVlc3RCb2R5U2l6ZSxcbiAgICByZXNwb25zZV9ib2R5X3NpemU6IHJlc3BvbnNlQm9keVNpemUsXG4gIH0gPSBicmVhZGNydW1iLmRhdGE7XG5cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICgheGhyIHx8ICF1cmxNYXRjaGVzKHVybCwgb3B0aW9ucy5uZXR3b3JrRGV0YWlsQWxsb3dVcmxzKSB8fCB1cmxNYXRjaGVzKHVybCwgb3B0aW9ucy5uZXR3b3JrRGV0YWlsRGVueVVybHMpKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGJ1aWxkU2tpcHBlZE5ldHdvcmtSZXF1ZXN0T3JSZXNwb25zZShyZXF1ZXN0Qm9keVNpemUpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYnVpbGRTa2lwcGVkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKHJlc3BvbnNlQm9keVNpemUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgIGVuZFRpbWVzdGFtcCxcbiAgICAgIHVybCxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVzcG9uc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8vIC0tLS0gVGhpcyBhZGRpdGlvbmFsIG5ldHdvcmsgZGF0YSBiZWxvdyBpcyBvbmx5IGNhcHR1cmVkIGZvciBVUkxzIGRlZmluZWQgaW4gYG5ldHdvcmtEZXRhaWxBbGxvd1VybHNgIC0tLS1cblxuICBjb25zdCB4aHJJbmZvID0geGhyW1NFTlRSWV9YSFJfREFUQV9LRVldO1xuICBjb25zdCBuZXR3b3JrUmVxdWVzdEhlYWRlcnMgPSB4aHJJbmZvXG4gICAgPyBnZXRBbGxvd2VkSGVhZGVycyh4aHJJbmZvLnJlcXVlc3RfaGVhZGVycywgb3B0aW9ucy5uZXR3b3JrUmVxdWVzdEhlYWRlcnMpXG4gICAgOiB7fTtcbiAgY29uc3QgbmV0d29ya1Jlc3BvbnNlSGVhZGVycyA9IGdldEFsbG93ZWRIZWFkZXJzKHBhcnNlWGhyUmVzcG9uc2VIZWFkZXJzKHhociksIG9wdGlvbnMubmV0d29ya1Jlc3BvbnNlSGVhZGVycyk7XG5cbiAgY29uc3QgW3JlcXVlc3RCb2R5LCByZXF1ZXN0V2FybmluZ10gPSBvcHRpb25zLm5ldHdvcmtDYXB0dXJlQm9kaWVzID8gZ2V0Qm9keVN0cmluZyhpbnB1dCwgZGVidWcpIDogW3VuZGVmaW5lZF07XG4gIGNvbnN0IFtyZXNwb25zZUJvZHksIHJlc3BvbnNlV2FybmluZ10gPSBvcHRpb25zLm5ldHdvcmtDYXB0dXJlQm9kaWVzID8gX2dldFhoclJlc3BvbnNlQm9keSh4aHIpIDogW3VuZGVmaW5lZF07XG5cbiAgY29uc3QgcmVxdWVzdCA9IGJ1aWxkTmV0d29ya1JlcXVlc3RPclJlc3BvbnNlKG5ldHdvcmtSZXF1ZXN0SGVhZGVycywgcmVxdWVzdEJvZHlTaXplLCByZXF1ZXN0Qm9keSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYnVpbGROZXR3b3JrUmVxdWVzdE9yUmVzcG9uc2UobmV0d29ya1Jlc3BvbnNlSGVhZGVycywgcmVzcG9uc2VCb2R5U2l6ZSwgcmVzcG9uc2VCb2R5KTtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgIGVuZFRpbWVzdGFtcCxcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVxdWVzdDogcmVxdWVzdFdhcm5pbmcgPyBtZXJnZVdhcm5pbmcocmVxdWVzdCwgcmVxdWVzdFdhcm5pbmcpIDogcmVxdWVzdCxcbiAgICByZXNwb25zZTogcmVzcG9uc2VXYXJuaW5nID8gbWVyZ2VXYXJuaW5nKHJlc3BvbnNlLCByZXNwb25zZVdhcm5pbmcpIDogcmVzcG9uc2UsXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9nZXRYaHJSZXNwb25zZUJvZHkoeGhyKSB7XG4gIC8vIFdlIGNvbGxlY3QgZXJyb3JzIHRoYXQgaGFwcGVuLCBidXQgb25seSBsb2cgdGhlbSBpZiB3ZSBjYW4ndCBnZXQgYW55IHJlc3BvbnNlIGJvZHlcbiAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gW3hoci5yZXNwb25zZVRleHRdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JzLnB1c2goZSk7XG4gIH1cblxuICAvLyBUcnkgdG8gbWFudWFsbHkgcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHksIGlmIHJlc3BvbnNlVGV4dCBmYWlsc1xuICB0cnkge1xuICAgIHJldHVybiBfcGFyc2VYaHJSZXNwb25zZSh4aHIucmVzcG9uc2UsIHhoci5yZXNwb25zZVR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JzLnB1c2goZSk7XG4gIH1cblxuICBERUJVR19CVUlMRCAmJiBkZWJ1Zy53YXJuKCdGYWlsZWQgdG8gZ2V0IHhociByZXNwb25zZSBib2R5JywgLi4uZXJyb3JzKTtcblxuICByZXR1cm4gW3VuZGVmaW5lZF07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFhIUiByZXNwb25zZS5cbiAqIEJhc2VkIG9uIE1ETiwgdGhlc2UgYXJlIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB0aGUgcmVzcG9uc2U6XG4gKiBzdHJpbmdcbiAqIEFycmF5QnVmZmVyXG4gKiBCbG9iXG4gKiBEb2N1bWVudFxuICogUE9KT1xuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RzLlxuICovXG5mdW5jdGlvbiBfcGFyc2VYaHJSZXNwb25zZShcbiAgYm9keSxcbiAgcmVzcG9uc2VUeXBlLFxuKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtib2R5XTtcbiAgICB9XG5cbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICByZXR1cm4gW2JvZHkuYm9keS5vdXRlckhUTUxdO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFtKU09OLnN0cmluZ2lmeShib2R5KV07XG4gICAgfVxuXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmV4Y2VwdGlvbihlcnJvciwgJ0ZhaWxlZCB0byBzZXJpYWxpemUgYm9keScsIGJvZHkpO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCAnQk9EWV9QQVJTRV9FUlJPUiddO1xuICB9XG5cbiAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdTa2lwcGluZyBuZXR3b3JrIGJvZHkgYmVjYXVzZSBvZiBib2R5IHR5cGUnLCBib2R5KTtcblxuICByZXR1cm4gW3VuZGVmaW5lZCwgJ1VOUEFSU0VBQkxFX0JPRFlfVFlQRSddO1xufVxuXG5mdW5jdGlvbiBfZ2V0Qm9keVNpemUoXG4gIGJvZHksXG4gIHJlc3BvbnNlVHlwZSxcbikge1xuICB0cnkge1xuICAgIGNvbnN0IGJvZHlTdHIgPSByZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBib2R5ICYmIHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gZ2V0Qm9keVNpemUoYm9keVN0cik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIHR3byB0aGluZ3M6XG4gKiAtIEl0IGVucmljaGVzIHRoZSByZWd1bGFyIFhIUi9mZXRjaCBicmVhZGNydW1icyB3aXRoIHJlcXVlc3QvcmVzcG9uc2Ugc2l6ZSBkYXRhXG4gKiAtIEl0IGNhcHR1cmVzIHRoZSBYSFIvZmV0Y2ggYnJlYWRjcnVtYnMgdG8gdGhlIHJlcGxheVxuICogICAoZW5yaWNoaW5nIGl0IHdpdGggZnVydGhlciBkYXRhIHRoYXQgaXMgX25vdF8gYWRkZWQgdG8gdGhlIHJlZ3VsYXIgYnJlYWRjcnVtYnMpXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5ldHdvcmtCcmVhZGNydW1icyhyZXBsYXkpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBuZXR3b3JrRGV0YWlsQWxsb3dVcmxzLFxuICAgICAgbmV0d29ya0RldGFpbERlbnlVcmxzLFxuICAgICAgbmV0d29ya0NhcHR1cmVCb2RpZXMsXG4gICAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnMsXG4gICAgICBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzLFxuICAgIH0gPSByZXBsYXkuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJlcGxheSxcbiAgICAgIG5ldHdvcmtEZXRhaWxBbGxvd1VybHMsXG4gICAgICBuZXR3b3JrRGV0YWlsRGVueVVybHMsXG4gICAgICBuZXR3b3JrQ2FwdHVyZUJvZGllcyxcbiAgICAgIG5ldHdvcmtSZXF1ZXN0SGVhZGVycyxcbiAgICAgIG5ldHdvcmtSZXNwb25zZUhlYWRlcnMsXG4gICAgfTtcblxuICAgIGlmIChjbGllbnQpIHtcbiAgICAgIGNsaWVudC5vbignYmVmb3JlQWRkQnJlYWRjcnVtYicsIChicmVhZGNydW1iLCBoaW50KSA9PiBiZWZvcmVBZGROZXR3b3JrQnJlYWRjcnVtYihvcHRpb25zLCBicmVhZGNydW1iLCBoaW50KSk7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBEbyBub3RoaW5nXG4gIH1cbn1cblxuLyoqIGp1c3QgZXhwb3J0ZWQgZm9yIHRlc3RzICovXG5mdW5jdGlvbiBiZWZvcmVBZGROZXR3b3JrQnJlYWRjcnVtYihcbiAgb3B0aW9ucyxcbiAgYnJlYWRjcnVtYixcbiAgaGludCxcbikge1xuICBpZiAoIWJyZWFkY3J1bWIuZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKF9pc1hockJyZWFkY3J1bWIoYnJlYWRjcnVtYikgJiYgX2lzWGhySGludChoaW50KSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgc3luYywgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIGJyZWFkY3J1bWIgaXMgZW5yaWNoZWQgaW4gdGhlIHNhbWUgdGlja1xuICAgICAgLy8gQmVjYXVzZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHksIGFuZCB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIHBhc3NlZCBvblxuICAgICAgLy8gU28gYW55IGFzeW5jIG11dGF0aW9ucyB0byBpdCB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGZpbmFsIGJyZWFkY3J1bWJcbiAgICAgIGVucmljaFhockJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgaGludCk7XG5cbiAgICAgIC8vIFRoaXMgY2FsbCBzaG91bGQgbm90IHJlamVjdFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgY2FwdHVyZVhockJyZWFkY3J1bWJUb1JlcGxheShicmVhZGNydW1iLCBoaW50LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRmV0Y2hCcmVhZGNydW1iKGJyZWFkY3J1bWIpICYmIF9pc0ZldGNoSGludChoaW50KSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgc3luYywgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIGJyZWFkY3J1bWIgaXMgZW5yaWNoZWQgaW4gdGhlIHNhbWUgdGlja1xuICAgICAgLy8gQmVjYXVzZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHksIGFuZCB0aGUgYnJlYWRjcnVtYiBpcyBhZnRlcndhcmRzIHBhc3NlZCBvblxuICAgICAgLy8gU28gYW55IGFzeW5jIG11dGF0aW9ucyB0byBpdCB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGZpbmFsIGJyZWFkY3J1bWJcbiAgICAgIGVucmljaEZldGNoQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KTtcblxuICAgICAgLy8gVGhpcyBjYWxsIHNob3VsZCBub3QgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICBjYXB0dXJlRmV0Y2hCcmVhZGNydW1iVG9SZXBsYXkoYnJlYWRjcnVtYiwgaGludCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXhjZXB0aW9uKGUsICdFcnJvciB3aGVuIGVucmljaGluZyBuZXR3b3JrIGJyZWFkY3J1bWInKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNYaHJCcmVhZGNydW1iKGJyZWFkY3J1bWIpIHtcbiAgcmV0dXJuIGJyZWFkY3J1bWIuY2F0ZWdvcnkgPT09ICd4aHInO1xufVxuXG5mdW5jdGlvbiBfaXNGZXRjaEJyZWFkY3J1bWIoYnJlYWRjcnVtYikge1xuICByZXR1cm4gYnJlYWRjcnVtYi5jYXRlZ29yeSA9PT0gJ2ZldGNoJztcbn1cblxuZnVuY3Rpb24gX2lzWGhySGludChoaW50KSB7XG4gIHJldHVybiBoaW50Py54aHI7XG59XG5cbmZ1bmN0aW9uIF9pc0ZldGNoSGludChoaW50KSB7XG4gIHJldHVybiBoaW50Py5yZXNwb25zZTtcbn1cblxuLyoqXG4gKiBBZGQgZ2xvYmFsIGxpc3RlbmVycyB0aGF0IGNhbm5vdCBiZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBhZGRHbG9iYWxMaXN0ZW5lcnMocmVwbGF5KSB7XG4gIC8vIExpc3RlbmVycyBmcm9tIGNvcmUgU0RLIC8vXG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuXG4gIGFkZENsaWNrS2V5cHJlc3NJbnN0cnVtZW50YXRpb25IYW5kbGVyKGhhbmRsZURvbUxpc3RlbmVyKHJlcGxheSkpO1xuICBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVIaXN0b3J5U3Bhbkxpc3RlbmVyKHJlcGxheSkpO1xuICBoYW5kbGVCcmVhZGNydW1icyhyZXBsYXkpO1xuICBoYW5kbGVOZXR3b3JrQnJlYWRjcnVtYnMocmVwbGF5KTtcblxuICAvLyBUYWcgYWxsIChub24gcmVwbGF5KSBldmVudHMgdGhhdCBnZXQgc2VudCB0byBTZW50cnkgd2l0aCB0aGUgY3VycmVudFxuICAvLyByZXBsYXkgSUQgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIHRoZW0gbGF0ZXIgaW4gdGhlIFVJXG4gIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gaGFuZGxlR2xvYmFsRXZlbnRMaXN0ZW5lcihyZXBsYXkpO1xuICBhZGRFdmVudFByb2Nlc3NvcihldmVudFByb2Nlc3Nvcik7XG5cbiAgLy8gSWYgYSBjdXN0b20gY2xpZW50IGhhcyBubyBob29rcyB5ZXQsIHdlIGNvbnRpbnVlIHRvIHVzZSB0aGUgXCJvbGRcIiBpbXBsZW1lbnRhdGlvblxuICBpZiAoY2xpZW50KSB7XG4gICAgY2xpZW50Lm9uKCdiZWZvcmVTZW5kRXZlbnQnLCBoYW5kbGVCZWZvcmVTZW5kRXZlbnQocmVwbGF5KSk7XG4gICAgY2xpZW50Lm9uKCdhZnRlclNlbmRFdmVudCcsIGhhbmRsZUFmdGVyU2VuZEV2ZW50KHJlcGxheSkpO1xuICAgIGNsaWVudC5vbignY3JlYXRlRHNjJywgKGRzYykgPT4ge1xuICAgICAgY29uc3QgcmVwbGF5SWQgPSByZXBsYXkuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBzZXQgdGhlIERTQyB3aGVuIGluIGJ1ZmZlciBtb2RlLCBhcyB0aGF0IG1lYW5zIHRoZSByZXBsYXkgaGFzIG5vdCBiZWVuIHNlbnQgKHlldClcbiAgICAgIGlmIChyZXBsYXlJZCAmJiByZXBsYXkuaXNFbmFibGVkKCkgJiYgcmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJykge1xuICAgICAgICAvLyBFbnN1cmUgdG8gY2hlY2sgdGhhdCB0aGUgc2Vzc2lvbiBpcyBzdGlsbCBhY3RpdmUgLSBpdCBjb3VsZCBoYXZlIGV4cGlyZWQgaW4gdGhlIG1lYW53aGlsZVxuICAgICAgICBjb25zdCBpc1Nlc3Npb25BY3RpdmUgPSByZXBsYXkuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpO1xuICAgICAgICBpZiAoaXNTZXNzaW9uQWN0aXZlKSB7XG4gICAgICAgICAgZHNjLnJlcGxheV9pZCA9IHJlcGxheUlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjbGllbnQub24oJ3NwYW5TdGFydCcsIHNwYW4gPT4ge1xuICAgICAgcmVwbGF5Lmxhc3RBY3RpdmVTcGFuID0gc3BhbjtcbiAgICB9KTtcblxuICAgIC8vIFdlIG1heSBiZSBtaXNzaW5nIHRoZSBpbml0aWFsIHNwYW5TdGFydCBkdWUgdG8gdGltaW5nIGlzc3VlcyxcbiAgICAvLyBzbyB3ZSBjYXB0dXJlIGl0IG9uIGZpbmlzaCBhZ2Fpbi5cbiAgICBjbGllbnQub24oJ3NwYW5FbmQnLCBzcGFuID0+IHtcbiAgICAgIHJlcGxheS5sYXN0QWN0aXZlU3BhbiA9IHNwYW47XG4gICAgfSk7XG5cbiAgICAvLyBXZSB3YW50IHRvIGF0dGFjaCB0aGUgcmVwbGF5IGlkIHRvIHRoZSBmZWVkYmFjayBldmVudFxuICAgIGNsaWVudC5vbignYmVmb3JlU2VuZEZlZWRiYWNrJywgYXN5bmMgKGZlZWRiYWNrRXZlbnQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlcGxheUlkID0gcmVwbGF5LmdldFNlc3Npb25JZCgpO1xuICAgICAgaWYgKG9wdGlvbnM/LmluY2x1ZGVSZXBsYXkgJiYgcmVwbGF5LmlzRW5hYmxlZCgpICYmIHJlcGxheUlkICYmIGZlZWRiYWNrRXZlbnQuY29udGV4dHM/LmZlZWRiYWNrKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIGZlZWRiYWNrIGlzIHNlbnQgdmlhIEFQSSBhbmQgbm90IHRocm91Z2ggb3VyIHdpZGdldCwgd2Ugd2FudCB0byBmbHVzaCByZXBsYXlcbiAgICAgICAgaWYgKGZlZWRiYWNrRXZlbnQuY29udGV4dHMuZmVlZGJhY2suc291cmNlID09PSAnYXBpJykge1xuICAgICAgICAgIGF3YWl0IHJlcGxheS5zZW5kQnVmZmVyZWRSZXBsYXlPckZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmVlZGJhY2tFdmVudC5jb250ZXh0cy5mZWVkYmFjay5yZXBsYXlfaWQgPSByZXBsYXlJZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNsaWVudC5vbignb3BlbkZlZWRiYWNrV2lkZ2V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVwbGF5LnNlbmRCdWZmZXJlZFJlcGxheU9yRmx1c2goKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIFwic3BhblwiIGZvciB0aGUgdG90YWwgYW1vdW50IG9mIG1lbW9yeSBiZWluZyB1c2VkIGJ5IEpTIG9iamVjdHNcbiAqIChpbmNsdWRpbmcgdjggaW50ZXJuYWwgb2JqZWN0cykuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFkZE1lbW9yeUVudHJ5KHJlcGxheSkge1xuICAvLyB3aW5kb3cucGVyZm9ybWFuY2UubWVtb3J5IGlzIGEgbm9uLXN0YW5kYXJkIEFQSSBhbmQgZG9lc24ndCB3b3JrIG9uIGFsbCBicm93c2Vycywgc28gd2UgdHJ5LWNhdGNoIHRoaXNcbiAgdHJ5IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBjcmVhdGVQZXJmb3JtYW5jZVNwYW5zKHJlcGxheSwgW1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1lbW9yeSBkb2Vzbid0IGV4aXN0IG9uIHR5cGUgUGVyZm9ybWFuY2UgYXMgdGhlIEFQSSBpcyBub24tc3RhbmRhcmQgKHdlIGNoZWNrIHRoYXQgaXQgZXhpc3RzIGFib3ZlKVxuICAgICAgICBjcmVhdGVNZW1vcnlFbnRyeShXSU5ET1cucGVyZm9ybWFuY2UubWVtb3J5KSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIERvIG5vdGhpbmdcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5RW50cnkobWVtb3J5RW50cnkpIHtcbiAgY29uc3QgeyBqc0hlYXBTaXplTGltaXQsIHRvdGFsSlNIZWFwU2l6ZSwgdXNlZEpTSGVhcFNpemUgfSA9IG1lbW9yeUVudHJ5O1xuICAvLyB3ZSBkb24ndCB3YW50IHRvIHVzZSBgZ2V0QWJzb2x1dGVUaW1lYCBiZWNhdXNlIGl0IGFkZHMgdGhlIGV2ZW50IHRpbWUgdG8gdGhlXG4gIC8vIHRpbWUgb3JpZ2luLCBzbyB3ZSBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluc3RlYWRcbiAgY29uc3QgdGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdtZW1vcnknLFxuICAgIG5hbWU6ICdtZW1vcnknLFxuICAgIHN0YXJ0OiB0aW1lLFxuICAgIGVuZDogdGltZSxcbiAgICBkYXRhOiB7XG4gICAgICBtZW1vcnk6IHtcbiAgICAgICAganNIZWFwU2l6ZUxpbWl0LFxuICAgICAgICB0b3RhbEpTSGVhcFNpemUsXG4gICAgICAgIHVzZWRKU0hlYXBTaXplLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEhlYXZpbHkgc2ltcGxpZmllZCBkZWJvdW5jZSBmdW5jdGlvbiBiYXNlZCBvbiBsb2Rhc2guZGVib3VuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIChAcGFyYW0gZnVuKSBhbmQgZGVsYXlzIGl0cyBpbnZvY2F0aW9uXG4gKiBieSBAcGFyYW0gd2FpdCBtaWxsaXNlY29uZHMuIE9wdGlvbmFsbHksIGEgbWF4V2FpdCBjYW4gYmUgc3BlY2lmaWVkIGluIEBwYXJhbSBvcHRpb25zLFxuICogd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBjYWxsYmFjayBpcyBpbnZva2VkIGF0IGxlYXN0IG9uY2UgYWZ0ZXIgdGhlIHNwZWNpZmllZCBtYXguIHdhaXQgdGltZS5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gd2hvc2UgaW52b2NhdGlvbiBpcyB0byBiZSBkZWJvdW5jZWRcbiAqIEBwYXJhbSB3YWl0IHRoZSBtaW5pbXVtIHRpbWUgdW50aWwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgYWZ0ZXIgaXQgd2FzIGNhbGxlZCBvbmNlXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBjb250YWluIHRoZSBgbWF4V2FpdGAgcHJvcGVydHlcbiAqXG4gKiBAcmV0dXJucyB0aGUgZGVib3VuY2VkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uLCB3aGljaCBuZWVkcyB0byBiZSBjYWxsZWQgYXQgbGVhc3Qgb25jZSB0byBzdGFydCB0aGVcbiAqICAgICAgICAgIGRlYm91bmNpbmcgcHJvY2Vzcy4gU3Vic2VxdWVudCBjYWxscyB3aWxsIHJlc2V0IHRoZSBkZWJvdW5jaW5nIHRpbWVyIGFuZCwgaW4gY2FzZSBAcGFyYW1mdW5jXG4gKiAgICAgICAgICB3YXMgYWxyZWFkeSBpbnZva2VkIGluIHRoZSBtZWFudGltZSwgcmV0dXJuIEBwYXJhbSBmdW5jJ3MgcmV0dXJuIHZhbHVlLlxuICogICAgICAgICAgVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBoYXMgdHdvIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqICAgICAgICAgIC0gYGZsdXNoYDogSW52b2tlcyB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFuZCByZXR1cm5zIGl0cyByZXR1cm4gdmFsdWVcbiAqICAgICAgICAgIC0gYGNhbmNlbGA6IENhbmNlbHMgdGhlIGRlYm91bmNpbmcgcHJvY2VzcyBhbmQgcmVzZXRzIHRoZSBkZWJvdW5jaW5nIHRpbWVyXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlYm91bmNlJDEoZnVuYywgd2FpdCwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIE5vdCBxdWl0ZSBzdXJlIHdoeSB0aGVzZSB0eXBlcyBkbyBub3QgbWF0Y2gsIGJ1dCB0aGlzIGlzIGZpbmVcbiAgICBzZXRUaW1lb3V0SW1wbDogc2V0VGltZW91dCQzLFxuICB9KTtcbn1cblxuY29uc3QgTkFWSUdBVE9SID0gR0xPQkFMX09CSi5uYXZpZ2F0b3I7XG5cbi8qKlxuICogIERpc2FibGUgc2FtcGxpbmcgbW91c2Vtb3ZlIGV2ZW50cyBvbiBpT1MgYnJvd3NlcnMgYXMgdGhpcyBjYW4gY2F1c2UgYmxvY2tpbmcgdGhlIG1haW4gdGhyZWFkXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMTQ1MzRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb3JkaW5nU2FtcGxpbmdPcHRpb25zKCkge1xuICBpZiAoXG4gICAgL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KE5BVklHQVRPUj8udXNlckFnZW50ID8/ICcnKSB8fFxuICAgICgvTWFjaW50b3NoL2kudGVzdChOQVZJR0FUT1I/LnVzZXJBZ2VudCA/PyAnJykgJiYgTkFWSUdBVE9SPy5tYXhUb3VjaFBvaW50cyAmJiBOQVZJR0FUT1I/Lm1heFRvdWNoUG9pbnRzID4gMSlcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsaW5nOiB7XG4gICAgICAgIG1vdXNlbW92ZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgcmVjb3JkaW5nIGV2ZW50cy5cbiAqXG4gKiBBZGRzIHRvIGV2ZW50IGJ1ZmZlciwgYW5kIGhhcyB2YXJ5aW5nIGZsdXNoaW5nIGJlaGF2aW9ycyBpZiB0aGUgZXZlbnQgd2FzIGEgY2hlY2tvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldEhhbmRsZVJlY29yZGluZ0VtaXQocmVwbGF5KSB7XG4gIGxldCBoYWRGaXJzdEV2ZW50ID0gZmFsc2U7XG5cbiAgcmV0dXJuIChldmVudCwgX2lzQ2hlY2tvdXQpID0+IHtcbiAgICAvLyBJZiB0aGlzIGlzIGZhbHNlLCBpdCBtZWFucyBzZXNzaW9uIGlzIGV4cGlyZWQsIGNyZWF0ZSBhbmQgYSBuZXcgc2Vzc2lvbiBhbmQgd2FpdCBmb3IgY2hlY2tvdXRcbiAgICBpZiAoIXJlcGxheS5jaGVja0FuZEhhbmRsZUV4cGlyZWRTZXNzaW9uKCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLndhcm4oJ1JlY2VpdmVkIHJlcGxheSBldmVudCBhZnRlciBzZXNzaW9uIGV4cGlyZWQuJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgX2lzQ2hlY2tvdXRgIGlzIG9ubHkgc2V0IHdoZW4gdGhlIGNoZWNrb3V0IGlzIGR1ZSB0byBgY2hlY2tvdXRFdmVyeU5tc2BcbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gdHJlYXQgdGhlIGZpcnN0IGV2ZW50IGFzIGEgY2hlY2tvdXQsIHNvIHdlIGhhbmRsZSB0aGlzIHNwZWNpZmljYWxseSBoZXJlXG4gICAgY29uc3QgaXNDaGVja291dCA9IF9pc0NoZWNrb3V0IHx8ICFoYWRGaXJzdEV2ZW50O1xuICAgIGhhZEZpcnN0RXZlbnQgPSB0cnVlO1xuXG4gICAgaWYgKHJlcGxheS5jbGlja0RldGVjdG9yKSB7XG4gICAgICB1cGRhdGVDbGlja0RldGVjdG9yRm9yUmVjb3JkaW5nRXZlbnQocmVwbGF5LmNsaWNrRGV0ZWN0b3IsIGV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaGFuZGxlciByZXR1cm5zIGB0cnVlYCBpZiB3ZSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIGRlYm91bmNlZCBmbHVzaCwgYGZhbHNlYCBpZiB3ZSB3YW50IHRvIGRlYm91bmNlIGZsdXNoLlxuICAgIHJlcGxheS5hZGRVcGRhdGUoKCkgPT4ge1xuICAgICAgLy8gVGhlIHNlc3Npb24gaXMgYWx3YXlzIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgb24gcGFnZWxvYWQvaW5pdCwgYnV0IGZvclxuICAgICAgLy8gZXJyb3Itb25seSByZXBsYXlzLCBpdCBzaG91bGQgcmVmbGVjdCB0aGUgbW9zdCByZWNlbnQgY2hlY2tvdXRcbiAgICAgIC8vIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiBDbGVhciBhbnkgc3RhdGUgdGhhdCBoYXBwZW5zIGJlZm9yZSB0aGlzIGN1cnJlbnRcbiAgICAgIC8vIGNoZWNrb3V0LiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgYGFkZEV2ZW50KClgIHdoaWNoIHVwZGF0ZXMgc3RhdGVcbiAgICAgIC8vIGRlcGVuZGVudCBvbiB0aGlzIHJlc2V0LlxuICAgICAgaWYgKHJlcGxheS5yZWNvcmRpbmdNb2RlID09PSAnYnVmZmVyJyAmJiBpc0NoZWNrb3V0KSB7XG4gICAgICAgIHJlcGxheS5zZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIG5vdCBhZGRlZCAoZS5nLiBkdWUgdG8gYmVpbmcgcGF1c2VkLCBkaXNhYmxlZCwgb3Igb3V0IG9mIHRoZSBtYXggcmVwbGF5IGR1cmF0aW9uKSxcbiAgICAgIC8vIFNraXAgYWxsIGZ1cnRoZXIgc3RlcHNcbiAgICAgIGlmICghYWRkRXZlbnRTeW5jKHJlcGxheSwgZXZlbnQsIGlzQ2hlY2tvdXQpKSB7XG4gICAgICAgIC8vIFJldHVybiB0cnVlIHRvIHNraXAgc2NoZWR1bGluZyBhIGRlYm91bmNlZCBmbHVzaFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlmZmVyZW50IGJlaGF2aW9yIGZvciBmdWxsIHNuYXBzaG90cyAodHlwZT0yKSwgaWdub3JlIG90aGVyIGV2ZW50IHR5cGVzXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Jyd2ViLWlvL3Jyd2ViL2Jsb2IvZDhmOTI5MGNhNDk2NzEyYWExZTdkNDcyNTQ5NDgwYzRlNzg3NjU5NC9wYWNrYWdlcy9ycndlYi9zcmMvdHlwZXMudHMjTDE2XG4gICAgICBpZiAoIWlzQ2hlY2tvdXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gcmVwbGF5LnNlc3Npb247XG5cbiAgICAgIC8vIEFkZGl0aW9uYWxseSwgY3JlYXRlIGEgbWV0YSBldmVudCB0aGF0IHdpbGwgY2FwdHVyZSBjZXJ0YWluIFNESyBzZXR0aW5ncy5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGhhbmRsZSBidWZmZXIgbW9kZSwgdGhpcyBuZWVkcyB0byBlaXRoZXIgYmUgZG9uZSB3aGVuIHdlXG4gICAgICAvLyByZWNlaXZlIGNoZWNrb3V0IGV2ZW50cyBvciBhdCBmbHVzaCB0aW1lLiBXZSBoYXZlIGFuIGV4cGVyaW1lbnRhbCBtb2RlXG4gICAgICAvLyB0byBwZXJmb3JtIG11bHRpcGxlIGNoZWNrb3V0cyBhIHNlc3Npb24gKHRoZSBpZGVhIGlzIHRvIGltcHJvdmVcbiAgICAgIC8vIHNlZWtpbmcgZHVyaW5nIHBsYXliYWNrKSwgc28gYWxzbyBvbmx5IGluY2x1ZGUgaWYgc2VnbWVudElkIGlzIDBcbiAgICAgIC8vIChoYW5kbGVkIGluIGBhZGRTZXR0aW5nc0V2ZW50YCkuXG4gICAgICAvL1xuICAgICAgLy8gYGlzQ2hlY2tvdXRgIGlzIGFsd2F5cyB0cnVlLCBidXQgd2FudCB0byBiZSBleHBsaWNpdCB0aGF0IGl0IHNob3VsZFxuICAgICAgLy8gb25seSBiZSBhZGRlZCBmb3IgY2hlY2tvdXRzXG4gICAgICBhZGRTZXR0aW5nc0V2ZW50KHJlcGxheSwgaXNDaGVja291dCk7XG5cbiAgICAgIC8vIFdoZW4gaW4gYnVmZmVyIG1vZGUsIG1ha2Ugc3VyZSB3ZSBhZGp1c3QgdGhlIHNlc3Npb24gc3RhcnRlZCBkYXRlIHRvIHRoZSBjdXJyZW50IGVhcmxpZXN0IGV2ZW50IG9mIHRoZSBidWZmZXJcbiAgICAgIC8vIHRoaXMgc2hvdWxkIHVzdWFsbHkgYmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgY2hlY2tvdXQgZXZlbnQsIGJ1dCB0byBiZSBzYWZlLi4uXG4gICAgICBpZiAocmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdidWZmZXInICYmIHNlc3Npb24gJiYgcmVwbGF5LmV2ZW50QnVmZmVyICYmICFzZXNzaW9uLmRpcnR5KSB7XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0RXZlbnQgPSByZXBsYXkuZXZlbnRCdWZmZXIuZ2V0RWFybGllc3RUaW1lc3RhbXAoKTtcbiAgICAgICAgaWYgKGVhcmxpZXN0RXZlbnQpIHtcbiAgICAgICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICAgICAgZGVidWcubG9nKGBVcGRhdGluZyBzZXNzaW9uIHN0YXJ0IHRpbWUgdG8gZWFybGllc3QgZXZlbnQgaW4gYnVmZmVyIHRvICR7bmV3IERhdGUoZWFybGllc3RFdmVudCl9YCk7XG5cbiAgICAgICAgICBzZXNzaW9uLnN0YXJ0ZWQgPSBlYXJsaWVzdEV2ZW50O1xuXG4gICAgICAgICAgaWYgKHJlcGxheS5nZXRPcHRpb25zKCkuc3RpY2t5U2Vzc2lvbikge1xuICAgICAgICAgICAgc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgcHJldmlvdXNTZXNzaW9uSWQgYWZ0ZXIgYSBmdWxsIHNuYXBzaG90IG9jY3VycywgdGhlblxuICAgICAgLy8gdGhlIHJlcGxheSBzZXNzaW9uIHdhcyBzdGFydGVkIGR1ZSB0byBzZXNzaW9uIGV4cGlyYXRpb24uIFRoZSBuZXcgc2Vzc2lvblxuICAgICAgLy8gaXMgc3RhcnRlZCBiZWZvcmUgdHJpZ2dlcmluZyBhIG5ldyBjaGVja291dCBhbmQgY29udGFpbnMgdGhlIGlkXG4gICAgICAvLyBvZiB0aGUgcHJldmlvdXMgc2Vzc2lvbi4gRG8gbm90IGltbWVkaWF0ZWx5IGZsdXNoIGluIHRoaXMgY2FzZVxuICAgICAgLy8gdG8gYXZvaWQgY2FwdHVyaW5nIG9ubHkgdGhlIGNoZWNrb3V0IGFuZCBpbnN0ZWFkIHRoZSByZXBsYXkgd2lsbFxuICAgICAgLy8gYmUgY2FwdHVyZWQgaWYgdGhleSBwZXJmb3JtIGFueSBmb2xsb3ctdXAgYWN0aW9ucy5cbiAgICAgIGlmIChzZXNzaW9uPy5wcmV2aW91c1Nlc3Npb25JZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcGxheS5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbicpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZ1bGwgc25hcHNob3QgaXMgZHVlIHRvIGFuIGluaXRpYWwgbG9hZCwgd2Ugd2lsbCBub3QgaGF2ZVxuICAgICAgICAvLyBhIHByZXZpb3VzIHNlc3Npb24gSUQuIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byBidWZmZXIgZXZlbnRzXG4gICAgICAgIC8vIGZvciBhIHNldCBhbW91bnQgb2YgdGltZSBiZWZvcmUgZmx1c2hpbmcuIFRoaXMgY2FuIGhlbHAgYXZvaWRcbiAgICAgICAgLy8gY2FwdHVyaW5nIHJlcGxheXMgb2YgdXNlcnMgdGhhdCBpbW1lZGlhdGVseSBjbG9zZSB0aGUgd2luZG93LlxuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHZvaWQgcmVwbGF5LmZsdXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0c1xuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zRXZlbnQocmVwbGF5KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXBsYXkuZ2V0T3B0aW9ucygpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIGRhdGE6IHtcbiAgICAgIHRhZzogJ29wdGlvbnMnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBzaG91bGRSZWNvcmRDYW52YXM6IHJlcGxheS5pc1JlY29yZGluZ0NhbnZhcygpLFxuICAgICAgICBzZXNzaW9uU2FtcGxlUmF0ZTogb3B0aW9ucy5zZXNzaW9uU2FtcGxlUmF0ZSxcbiAgICAgICAgZXJyb3JTYW1wbGVSYXRlOiBvcHRpb25zLmVycm9yU2FtcGxlUmF0ZSxcbiAgICAgICAgdXNlQ29tcHJlc3Npb25PcHRpb246IG9wdGlvbnMudXNlQ29tcHJlc3Npb24sXG4gICAgICAgIGJsb2NrQWxsTWVkaWE6IG9wdGlvbnMuYmxvY2tBbGxNZWRpYSxcbiAgICAgICAgbWFza0FsbFRleHQ6IG9wdGlvbnMubWFza0FsbFRleHQsXG4gICAgICAgIG1hc2tBbGxJbnB1dHM6IG9wdGlvbnMubWFza0FsbElucHV0cyxcbiAgICAgICAgdXNlQ29tcHJlc3Npb246IHJlcGxheS5ldmVudEJ1ZmZlciA/IHJlcGxheS5ldmVudEJ1ZmZlci50eXBlID09PSAnd29ya2VyJyA6IGZhbHNlLFxuICAgICAgICBuZXR3b3JrRGV0YWlsSGFzVXJsczogb3B0aW9ucy5uZXR3b3JrRGV0YWlsQWxsb3dVcmxzLmxlbmd0aCA+IDAsXG4gICAgICAgIG5ldHdvcmtDYXB0dXJlQm9kaWVzOiBvcHRpb25zLm5ldHdvcmtDYXB0dXJlQm9kaWVzLFxuICAgICAgICBuZXR3b3JrUmVxdWVzdEhhc0hlYWRlcnM6IG9wdGlvbnMubmV0d29ya1JlcXVlc3RIZWFkZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgIG5ldHdvcmtSZXNwb25zZUhhc0hlYWRlcnM6IG9wdGlvbnMubmV0d29ya1Jlc3BvbnNlSGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEFkZCBhIFwibWV0YVwiIGV2ZW50IHRoYXQgY29udGFpbnMgYSBzaW1wbGlmaWVkIHZpZXcgb24gY3VycmVudCBjb25maWd1cmF0aW9uXG4gKiBvcHRpb25zLiBUaGlzIHNob3VsZCBvbmx5IGJlIGluY2x1ZGVkIG9uIHRoZSBmaXJzdCBzZWdtZW50IG9mIGEgcmVjb3JkaW5nLlxuICovXG5mdW5jdGlvbiBhZGRTZXR0aW5nc0V2ZW50KHJlcGxheSwgaXNDaGVja291dCkge1xuICAvLyBPbmx5IG5lZWQgdG8gYWRkIHRoaXMgZXZlbnQgd2hlbiBzZW5kaW5nIHRoZSBmaXJzdCBzZWdtZW50XG4gIGlmICghaXNDaGVja291dCB8fCAhcmVwbGF5LnNlc3Npb24gfHwgcmVwbGF5LnNlc3Npb24uc2VnbWVudElkICE9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWRkRXZlbnRTeW5jKHJlcGxheSwgY3JlYXRlT3B0aW9uc0V2ZW50KHJlcGxheSksIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBWZW5kb3JlZCBpbiBmcm9tIEBzZW50cnktaW50ZXJuYWwvcnJ3ZWIuXG4gKlxuICogVGhpcyBpcyBhIGNvcHkgb2YgdGhlIGZ1bmN0aW9uIGZyb20gcnJ3ZWIsIGl0IGlzIG5vdCBuaWNlbHkgZXhwb3J0ZWQgdGhlcmUuXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDYXRjaCBhY2Nlc3MgdG8gbm9kZSBwcm9wZXJ0aWVzIHRvIGF2b2lkIEZpcmVmb3ggXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yc1xuICB0cnkge1xuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUgPyAobm9kZSApIDogbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBlbDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXBsYXkgZW52ZWxvcGUgcmVhZHkgdG8gYmUgc2VudC5cbiAqIFRoaXMgaW5jbHVkZXMgYm90aCB0aGUgcmVwbGF5IGV2ZW50LCBhcyB3ZWxsIGFzIHRoZSByZWNvcmRpbmcgZGF0YS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVwbGF5RW52ZWxvcGUoXG4gIHJlcGxheUV2ZW50LFxuICByZWNvcmRpbmdEYXRhLFxuICBkc24sXG4gIHR1bm5lbCxcbikge1xuICByZXR1cm4gY3JlYXRlRW52ZWxvcGUoXG4gICAgY3JlYXRlRXZlbnRFbnZlbG9wZUhlYWRlcnMocmVwbGF5RXZlbnQsIGdldFNka01ldGFkYXRhRm9yRW52ZWxvcGVIZWFkZXIocmVwbGF5RXZlbnQpLCB0dW5uZWwsIGRzbiksXG4gICAgW1xuICAgICAgW3sgdHlwZTogJ3JlcGxheV9ldmVudCcgfSwgcmVwbGF5RXZlbnRdLFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3JlcGxheV9yZWNvcmRpbmcnLFxuICAgICAgICAgIC8vIElmIHN0cmluZyB0aGVuIHdlIG5lZWQgdG8gZW5jb2RlIHRvIFVURjgsIG90aGVyd2lzZSB3aWxsIGhhdmVcbiAgICAgICAgICAvLyB3cm9uZyBzaXplLiBUZXh0RW5jb2RlciBoYXMgc2ltaWxhciBicm93c2VyIHN1cHBvcnQgdG9cbiAgICAgICAgICAvLyBNdXRhdGlvbk9ic2VydmVyLCBhbHRob3VnaCBpdCBkb2VzIG5vdCBhY2NlcHQgSUUxMS5cbiAgICAgICAgICBsZW5ndGg6XG4gICAgICAgICAgICB0eXBlb2YgcmVjb3JkaW5nRGF0YSA9PT0gJ3N0cmluZycgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVjb3JkaW5nRGF0YSkubGVuZ3RoIDogcmVjb3JkaW5nRGF0YS5sZW5ndGgsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY29yZGluZ0RhdGEsXG4gICAgICBdLFxuICAgIF0sXG4gICk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgcmVjb3JkaW5nIGRhdGEgcmVhZHkgdG8gYmUgc2VudC5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVJlY29yZGluZ0RhdGEoe1xuICByZWNvcmRpbmdEYXRhLFxuICBoZWFkZXJzLFxufVxuXG4pIHtcbiAgbGV0IHBheWxvYWRXaXRoU2VxdWVuY2U7XG5cbiAgLy8gWFhYOiBuZXdsaW5lIGlzIG5lZWRlZCB0byBzZXBhcmF0ZSBzZXF1ZW5jZSBpZCBmcm9tIGV2ZW50c1xuICBjb25zdCByZXBsYXlIZWFkZXJzID0gYCR7SlNPTi5zdHJpbmdpZnkoaGVhZGVycyl9XG5gO1xuXG4gIGlmICh0eXBlb2YgcmVjb3JkaW5nRGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXlsb2FkV2l0aFNlcXVlbmNlID0gYCR7cmVwbGF5SGVhZGVyc30ke3JlY29yZGluZ0RhdGF9YDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAvLyBYWFg6IG5ld2xpbmUgaXMgbmVlZGVkIHRvIHNlcGFyYXRlIHNlcXVlbmNlIGlkIGZyb20gZXZlbnRzXG4gICAgY29uc3Qgc2VxdWVuY2UgPSBlbmMuZW5jb2RlKHJlcGxheUhlYWRlcnMpO1xuICAgIC8vIE1lcmdlIHRoZSB0d28gVWludDhBcnJheXNcbiAgICBwYXlsb2FkV2l0aFNlcXVlbmNlID0gbmV3IFVpbnQ4QXJyYXkoc2VxdWVuY2UubGVuZ3RoICsgcmVjb3JkaW5nRGF0YS5sZW5ndGgpO1xuICAgIHBheWxvYWRXaXRoU2VxdWVuY2Uuc2V0KHNlcXVlbmNlKTtcbiAgICBwYXlsb2FkV2l0aFNlcXVlbmNlLnNldChyZWNvcmRpbmdEYXRhLCBzZXF1ZW5jZS5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHBheWxvYWRXaXRoU2VxdWVuY2U7XG59XG5cbi8qKlxuICogUHJlcGFyZSBhIHJlcGxheSBldmVudCAmIGVucmljaCBpdCB3aXRoIHRoZSBTREsgbWV0YWRhdGEuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVSZXBsYXlFdmVudCh7XG4gIGNsaWVudCxcbiAgc2NvcGUsXG4gIHJlcGxheUlkOiBldmVudF9pZCxcbiAgZXZlbnQsXG59XG5cbikge1xuICBjb25zdCBpbnRlZ3JhdGlvbnMgPVxuICAgIHR5cGVvZiBjbGllbnRbJ19pbnRlZ3JhdGlvbnMnXSA9PT0gJ29iamVjdCcgJiZcbiAgICBjbGllbnRbJ19pbnRlZ3JhdGlvbnMnXSAhPT0gbnVsbCAmJlxuICAgICFBcnJheS5pc0FycmF5KGNsaWVudFsnX2ludGVncmF0aW9ucyddKVxuICAgICAgPyBPYmplY3Qua2V5cyhjbGllbnRbJ19pbnRlZ3JhdGlvbnMnXSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGV2ZW50SGludCA9IHsgZXZlbnRfaWQsIGludGVncmF0aW9ucyB9O1xuXG4gIGNsaWVudC5lbWl0KCdwcmVwcm9jZXNzRXZlbnQnLCBldmVudCwgZXZlbnRIaW50KTtcblxuICBjb25zdCBwcmVwYXJlZEV2ZW50ID0gKGF3YWl0IHByZXBhcmVFdmVudChcbiAgICBjbGllbnQuZ2V0T3B0aW9ucygpLFxuICAgIGV2ZW50LFxuICAgIGV2ZW50SGludCxcbiAgICBzY29wZSxcbiAgICBjbGllbnQsXG4gICAgZ2V0SXNvbGF0aW9uU2NvcGUoKSxcbiAgKSkgO1xuXG4gIC8vIElmIGUuZy4gYSBnbG9iYWwgZXZlbnQgcHJvY2Vzc29yIHJldHVybmVkIG51bGxcbiAgaWYgKCFwcmVwYXJlZEV2ZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjbGllbnQuZW1pdCgncG9zdHByb2Nlc3NFdmVudCcsIHByZXBhcmVkRXZlbnQsIGV2ZW50SGludCk7XG5cbiAgLy8gVGhpcyBub3JtYWxseSBoYXBwZW5zIGluIGJyb3dzZXIgY2xpZW50IFwiX3ByZXBhcmVFdmVudFwiXG4gIC8vIGJ1dCBzaW5jZSB3ZSBkbyBub3QgdXNlIHRoaXMgcHJpdmF0ZSBtZXRob2QgZnJvbSB0aGUgY2xpZW50LCBidXQgcmF0aGVyIHRoZSBwbGFpbiBpbXBvcnRcbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5LlxuICBwcmVwYXJlZEV2ZW50LnBsYXRmb3JtID0gcHJlcGFyZWRFdmVudC5wbGF0Zm9ybSB8fCAnamF2YXNjcmlwdCc7XG5cbiAgLy8gZXh0cmFjdCB0aGUgU0RLIG5hbWUgYmVjYXVzZSBgY2xpZW50Ll9wcmVwYXJlRXZlbnRgIGRvZXNuJ3QgYWRkIGl0IHRvIHRoZSBldmVudFxuICBjb25zdCBtZXRhZGF0YSA9IGNsaWVudC5nZXRTZGtNZXRhZGF0YSgpO1xuICBjb25zdCB7IG5hbWUsIHZlcnNpb24sIHNldHRpbmdzIH0gPSBtZXRhZGF0YT8uc2RrIHx8IHt9O1xuXG4gIHByZXBhcmVkRXZlbnQuc2RrID0ge1xuICAgIC4uLnByZXBhcmVkRXZlbnQuc2RrLFxuICAgIG5hbWU6IG5hbWUgfHwgJ3NlbnRyeS5qYXZhc2NyaXB0LnVua25vd24nLFxuICAgIHZlcnNpb246IHZlcnNpb24gfHwgJzAuMC4wJyxcbiAgICBzZXR0aW5ncyxcbiAgfTtcblxuICByZXR1cm4gcHJlcGFyZWRFdmVudDtcbn1cblxuLyoqXG4gKiBTZW5kIHJlcGxheSBhdHRhY2htZW50IHVzaW5nIGBmZXRjaCgpYFxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kUmVwbGF5UmVxdWVzdCh7XG4gIHJlY29yZGluZ0RhdGEsXG4gIHJlcGxheUlkLFxuICBzZWdtZW50SWQ6IHNlZ21lbnRfaWQsXG4gIGV2ZW50Q29udGV4dCxcbiAgdGltZXN0YW1wLFxuICBzZXNzaW9uLFxufSkge1xuICBjb25zdCBwcmVwYXJlZFJlY29yZGluZ0RhdGEgPSBwcmVwYXJlUmVjb3JkaW5nRGF0YSh7XG4gICAgcmVjb3JkaW5nRGF0YSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBzZWdtZW50X2lkLFxuICAgIH0sXG4gIH0pO1xuXG4gIGNvbnN0IHsgdXJscywgZXJyb3JJZHMsIHRyYWNlSWRzLCBpbml0aWFsVGltZXN0YW1wIH0gPSBldmVudENvbnRleHQ7XG5cbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHRyYW5zcG9ydCA9IGNsaWVudD8uZ2V0VHJhbnNwb3J0KCk7XG4gIGNvbnN0IGRzbiA9IGNsaWVudD8uZ2V0RHNuKCk7XG5cbiAgaWYgKCFjbGllbnQgfHwgIXRyYW5zcG9ydCB8fCAhZHNuIHx8ICFzZXNzaW9uLnNhbXBsZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgfVxuXG4gIGNvbnN0IGJhc2VFdmVudCA9IHtcbiAgICB0eXBlOiBSRVBMQVlfRVZFTlRfTkFNRSxcbiAgICByZXBsYXlfc3RhcnRfdGltZXN0YW1wOiBpbml0aWFsVGltZXN0YW1wIC8gMTAwMCxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCAvIDEwMDAsXG4gICAgZXJyb3JfaWRzOiBlcnJvcklkcyxcbiAgICB0cmFjZV9pZHM6IHRyYWNlSWRzLFxuICAgIHVybHMsXG4gICAgcmVwbGF5X2lkOiByZXBsYXlJZCxcbiAgICBzZWdtZW50X2lkLFxuICAgIHJlcGxheV90eXBlOiBzZXNzaW9uLnNhbXBsZWQsXG4gIH07XG5cbiAgY29uc3QgcmVwbGF5RXZlbnQgPSBhd2FpdCBwcmVwYXJlUmVwbGF5RXZlbnQoeyBzY29wZSwgY2xpZW50LCByZXBsYXlJZCwgZXZlbnQ6IGJhc2VFdmVudCB9KTtcblxuICBpZiAoIXJlcGxheUV2ZW50KSB7XG4gICAgLy8gVGFrZW4gZnJvbSBiYXNlY2xpZW50J3MgYF9wcm9jZXNzRXZlbnRgIG1ldGhvZCwgd2hlcmUgdGhpcyBpcyBoYW5kbGVkIGZvciBlcnJvcnMvdHJhbnNhY3Rpb25zXG4gICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudCgnZXZlbnRfcHJvY2Vzc29yJywgJ3JlcGxheScpO1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnQW4gZXZlbnQgcHJvY2Vzc29yIHJldHVybmVkIGBudWxsYCwgd2lsbCBub3Qgc2VuZCBldmVudC4nKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgfVxuXG4gIC8qXG4gIEZvciByZWZlcmVuY2UsIHRoZSBmdWxseSBidWlsdCBldmVudCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICB7XG4gICAgICBcInR5cGVcIjogXCJyZXBsYXlfZXZlbnRcIixcbiAgICAgIFwidGltZXN0YW1wXCI6IDE2NzA4MzcwMDguNjM0LFxuICAgICAgXCJlcnJvcl9pZHNcIjogW1xuICAgICAgICAgIFwiZXJyb3JJZFwiXG4gICAgICBdLFxuICAgICAgXCJ0cmFjZV9pZHNcIjogW1xuICAgICAgICAgIFwidHJhY2VJZFwiXG4gICAgICBdLFxuICAgICAgXCJ1cmxzXCI6IFtcbiAgICAgICAgICBcImh0dHBzOi8vZXhhbXBsZS5jb21cIlxuICAgICAgXSxcbiAgICAgIFwicmVwbGF5X2lkXCI6IFwiZXZlbnRJZFwiLFxuICAgICAgXCJzZWdtZW50X2lkXCI6IDMsXG4gICAgICBcInJlcGxheV90eXBlXCI6IFwiZXJyb3JcIixcbiAgICAgIFwicGxhdGZvcm1cIjogXCJqYXZhc2NyaXB0XCIsXG4gICAgICBcImV2ZW50X2lkXCI6IFwiZXZlbnRJZFwiLFxuICAgICAgXCJlbnZpcm9ubWVudFwiOiBcInByb2R1Y3Rpb25cIixcbiAgICAgIFwic2RrXCI6IHtcbiAgICAgICAgICBcImludGVncmF0aW9uc1wiOiBbXG4gICAgICAgICAgICAgIFwiQnJvd3NlclRyYWNpbmdcIixcbiAgICAgICAgICAgICAgXCJSZXBsYXlcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwic2VudHJ5LmphdmFzY3JpcHQuYnJvd3NlclwiLFxuICAgICAgICAgIFwidmVyc2lvblwiOiBcIjcuMjUuMFwiXG4gICAgICB9LFxuICAgICAgXCJzZGtQcm9jZXNzaW5nTWV0YWRhdGFcIjoge30sXG4gICAgICBcImNvbnRleHRzXCI6IHtcbiAgICAgIH0sXG4gIH1cbiAgKi9cblxuICAvLyBQcmV2ZW50IHRoaXMgZGF0YSAod2hpY2gsIGlmIGl0IGV4aXN0cywgd2FzIHVzZWQgaW4gZWFybGllciBzdGVwcyBpbiB0aGUgcHJvY2Vzc2luZyBwaXBlbGluZSkgZnJvbSBiZWluZyBzZW50IHRvXG4gIC8vIHNlbnRyeS4gKE5vdGU6IE91ciB1c2Ugb2YgdGhpcyBwcm9wZXJ0eSBjb21lcyBhbmQgZ29lcyB3aXRoIHdoYXRldmVyIHdlIG1pZ2h0IGJlIGRlYnVnZ2luZywgd2hhdGV2ZXIgaGFja3Mgd2UgbWF5XG4gIC8vIGhhdmUgdGVtcG9yYXJpbHkgYWRkZWQsIGV0Yy4gRXZlbiBpZiB3ZSBkb24ndCBoYXBwZW4gdG8gYmUgdXNpbmcgaXQgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCBsZXQncyBub3QgZ2V0IHJpZFxuICAvLyBvZiB0aGlzIGBkZWxldGVgLCBsZXN0IHdlIG1pc3MgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBuZXh0IHRpbWUgdGhlIHByb3BlcnR5IGlzIGluIHVzZS4pXG4gIGRlbGV0ZSByZXBsYXlFdmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE7XG5cbiAgY29uc3QgZW52ZWxvcGUgPSBjcmVhdGVSZXBsYXlFbnZlbG9wZShyZXBsYXlFdmVudCwgcHJlcGFyZWRSZWNvcmRpbmdEYXRhLCBkc24sIGNsaWVudC5nZXRPcHRpb25zKCkudHVubmVsKTtcblxuICBsZXQgcmVzcG9uc2U7XG5cbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydC5zZW5kKGVudmVsb3BlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoVU5BQkxFX1RPX1NFTkRfUkVQTEFZKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBJbiBjYXNlIGJyb3dzZXJzIGRvbid0IGFsbG93IHRoaXMgcHJvcGVydHkgdG8gYmUgd3JpdGFibGVcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBuZWVkcyBsaWIgZXMyMDIyIGFuZCBuZXdlclxuICAgICAgZXJyb3IuY2F1c2UgPSBlcnI7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gSWYgdGhlIHN0YXR1cyBjb2RlIGlzIGludmFsaWQsIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgc3RvcCAmIG5vdCByZXRyeVxuICBpZiAodHlwZW9mIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09ICdudW1iZXInICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkge1xuICAgIHRocm93IG5ldyBUcmFuc3BvcnRTdGF0dXNDb2RlRXJyb3IocmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gIH1cblxuICBjb25zdCByYXRlTGltaXRzID0gdXBkYXRlUmF0ZUxpbWl0cyh7fSwgcmVzcG9uc2UpO1xuICBpZiAoaXNSYXRlTGltaXRlZChyYXRlTGltaXRzLCAncmVwbGF5JykpIHtcbiAgICB0aHJvdyBuZXcgUmF0ZUxpbWl0RXJyb3IocmF0ZUxpbWl0cyk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgdGhhdCB0aGUgdHJhbnNwb3J0IHJldHVybmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUuXG4gKi9cbmNsYXNzIFRyYW5zcG9ydFN0YXR1c0NvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUpIHtcbiAgICBzdXBlcihgVHJhbnNwb3J0IHJldHVybmVkIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXJyb3IgaW5kaWNhdGVzIHRoYXQgd2UgaGl0IGEgcmF0ZSBsaW1pdCBBUEkgZXJyb3IuXG4gKi9cbmNsYXNzIFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICBjb25zdHJ1Y3RvcihyYXRlTGltaXRzKSB7XG4gICAgc3VwZXIoJ1JhdGUgbGltaXQgaGl0Jyk7XG4gICAgdGhpcy5yYXRlTGltaXRzID0gcmF0ZUxpbWl0cztcbiAgfVxufVxuXG4vKipcbiAqIEZpbmFsaXplIGFuZCBzZW5kIHRoZSBjdXJyZW50IHJlcGxheSBldmVudCB0byBTZW50cnlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZFJlcGxheShcbiAgcmVwbGF5RGF0YSxcbiAgcmV0cnlDb25maWcgPSB7XG4gICAgY291bnQ6IDAsXG4gICAgaW50ZXJ2YWw6IFJFVFJZX0JBU0VfSU5URVJWQUwsXG4gIH0sXG4pIHtcbiAgY29uc3QgeyByZWNvcmRpbmdEYXRhLCBvbkVycm9yIH0gPSByZXBsYXlEYXRhO1xuXG4gIC8vIHNob3J0IGNpcmN1aXQgaWYgdGhlcmUncyBubyBldmVudHMgdG8gdXBsb2FkICh0aGlzIHNob3VsZG4ndCBoYXBwZW4gYXMgX3J1bkZsdXNoIG1ha2VzIHRoaXMgY2hlY2spXG4gIGlmICghcmVjb3JkaW5nRGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHNlbmRSZXBsYXlSZXF1ZXN0KHJlcGxheURhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHJhbnNwb3J0U3RhdHVzQ29kZUVycm9yIHx8IGVyciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgLy8gQ2FwdHVyZSBlcnJvciBmb3IgZXZlcnkgZmFpbGVkIHJlcGxheVxuICAgIHNldENvbnRleHQoJ1JlcGxheXMnLCB7XG4gICAgICBfcmV0cnlDb3VudDogcmV0cnlDb25maWcuY291bnQsXG4gICAgfSk7XG5cbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcihlcnIpO1xuICAgIH1cblxuICAgIC8vIElmIGFuIGVycm9yIGhhcHBlbmVkIGhlcmUsIGl0J3MgbGlrZWx5IHRoYXQgdXBsb2FkaW5nIHRoZSBhdHRhY2htZW50XG4gICAgLy8gZmFpbGVkLCB3ZSdsbCBjYW4gcmV0cnkgd2l0aCB0aGUgc2FtZSBldmVudHMgcGF5bG9hZFxuICAgIGlmIChyZXRyeUNvbmZpZy5jb3VudCA+PSBSRVRSWV9NQVhfQ09VTlQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke1VOQUJMRV9UT19TRU5EX1JFUExBWX0gLSBtYXggcmV0cmllcyBleGNlZWRlZGApO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbiBjYXNlIGJyb3dzZXJzIGRvbid0IGFsbG93IHRoaXMgcHJvcGVydHkgdG8gYmUgd3JpdGFibGVcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIG5lZWRzIGxpYiBlczIwMjIgYW5kIG5ld2VyXG4gICAgICAgIGVycm9yLmNhdXNlID0gZXJyO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gd2lsbCByZXRyeSBpbiBpbnRlcnZhbHMgb2YgNSwgMTAsIDMwXG4gICAgcmV0cnlDb25maWcuaW50ZXJ2YWwgKj0gKytyZXRyeUNvbmZpZy5jb3VudDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0JDMoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHNlbmRSZXBsYXkocmVwbGF5RGF0YSwgcmV0cnlDb25maWcpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCByZXRyeUNvbmZpZy5pbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgVEhST1RUTEVEID0gJ19fVEhST1RUTEVEJztcbmNvbnN0IFNLSVBQRUQgPSAnX19TS0lQUEVEJztcblxuLyoqXG4gKiBDcmVhdGUgYSB0aHJvdHRsZWQgZnVuY3Rpb24gb2ZmIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gKiBXaGVuIGNhbGxpbmcgdGhlIHRocm90dGxlZCBmdW5jdGlvbiwgaXQgd2lsbCBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbmx5XG4gKiBpZiBpdCBoYXNuJ3QgYmVlbiBjYWxsZWQgbW9yZSB0aGFuIGBtYXhDb3VudGAgdGltZXMgaW4gdGhlIGxhc3QgYGR1cmF0aW9uU2Vjb25kc2AuXG4gKlxuICogUmV0dXJucyBgVEhST1RUTEVEYCBpZiB0aHJvdHRsZWQgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZnRlciB0aGF0IGBTS0lQUEVEYCxcbiAqIG9yIGVsc2UgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB0aHJvdHRsZShcbiAgZm4sXG4gIG1heENvdW50LFxuICBkdXJhdGlvblNlY29uZHMsXG4pIHtcbiAgY29uc3QgY291bnRlciA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBfY2xlYW51cCA9IChub3cpID0+IHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBub3cgLSBkdXJhdGlvblNlY29uZHM7XG4gICAgY291bnRlci5mb3JFYWNoKChfdmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSA8IHRocmVzaG9sZCkge1xuICAgICAgICBjb3VudGVyLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IF9nZXRUb3RhbENvdW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBbLi4uY291bnRlci52YWx1ZXMoKV0ucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gIH07XG5cbiAgbGV0IGlzVGhyb3R0bGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuICguLi5yZXN0KSA9PiB7XG4gICAgLy8gRGF0ZSBpbiBzZWNvbmQtcHJlY2lzaW9uLCB3aGljaCB3ZSB1c2UgYXMgYmFzaXMgZm9yIHRoZSB0aHJvdHRsaW5nXG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSBzdXJlIHRvIGRlbGV0ZSBhbnkgb2xkIGVudHJpZXNcbiAgICBfY2xlYW51cChub3cpO1xuXG4gICAgLy8gSWYgYWxyZWFkeSBvdmVyIGxpbWl0LCBkbyBub3RoaW5nXG4gICAgaWYgKF9nZXRUb3RhbENvdW50KCkgPj0gbWF4Q291bnQpIHtcbiAgICAgIGNvbnN0IHdhc1Rocm90dGxlZCA9IGlzVGhyb3R0bGVkO1xuICAgICAgaXNUaHJvdHRsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHdhc1Rocm90dGxlZCA/IFNLSVBQRUQgOiBUSFJPVFRMRUQ7XG4gICAgfVxuXG4gICAgaXNUaHJvdHRsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjb3VudCA9IGNvdW50ZXIuZ2V0KG5vdykgfHwgMDtcbiAgICBjb3VudGVyLnNldChub3csIGNvdW50ICsgMSk7XG5cbiAgICByZXR1cm4gZm4oLi4ucmVzdCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIG1haW4gcmVwbGF5IGNvbnRhaW5lciBjbGFzcywgd2hpY2ggaG9sZHMgYWxsIHRoZSBzdGF0ZSBhbmQgbWV0aG9kcyBmb3IgcmVjb3JkaW5nIGFuZCBzZW5kaW5nIHJlcGxheXMuXG4gKi9cbmNsYXNzIFJlcGxheUNvbnRhaW5lciAge1xuXG4gIC8qKlxuICAgKiBSZWNvcmRpbmcgY2FuIGhhcHBlbiBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuICAgKiAgIC0gc2Vzc2lvbjogUmVjb3JkIHRoZSB3aG9sZSBzZXNzaW9uLCBzZW5kaW5nIGl0IGNvbnRpbnVvdXNseVxuICAgKiAgIC0gYnVmZmVyOiBBbHdheXMga2VlcCB0aGUgbGFzdCA2MHMgb2YgcmVjb3JkaW5nLCByZXF1aXJlczpcbiAgICogICAgIC0gaGF2aW5nIHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZSA+IDAgdG8gY2FwdHVyZSByZXBsYXkgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAgICogICAgIC0gb3IgY2FsbGluZyBgZmx1c2goKWAgdG8gc2VuZCB0aGUgcmVwbGF5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBvciBsYXN0IGFjdGl2ZSBzcGFuLlxuICAgKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gcGVyZm9ybWFuY2UgaXMgZW5hYmxlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBoZXJlIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBpbiB0ZXN0cyBldGMuXG4gICAqIEBoaWRkZW5cbiAgICovXG5cbiAgLyoqIFRoZSByZXBsYXkgaGFzIHRvIGJlIG1hbnVhbGx5IHN0YXJ0ZWQsIGJlY2F1c2Ugbm8gc2FtcGxlIHJhdGUgKG5laXRoZXIgc2Vzc2lvbiBvciBlcnJvcikgd2FzIHByb3ZpZGVkLiAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIHBhc3MgdG8gYHJyd2ViLnJlY29yZCgpYFxuICAgKi9cblxuICAvKipcbiAgICogVGltZXN0YW1wIG9mIHRoZSBsYXN0IHVzZXIgYWN0aXZpdHkuIFRoaXMgbGl2ZXMgYWNyb3NzIHNlc3Npb25zLlxuICAgKi9cblxuICAvKipcbiAgICogSXMgdGhlIGludGVncmF0aW9uIGN1cnJlbnRseSBhY3RpdmU/XG4gICAqL1xuXG4gIC8qKlxuICAgKiBQYXVzZWQgaXMgYSBzdGF0ZSB3aGVyZTpcbiAgICogLSBET00gUmVjb3JkaW5nIGlzIG5vdCBsaXN0ZW5pbmcgYXQgYWxsXG4gICAqIC0gTm90aGluZyB3aWxsIGJlIGFkZGVkIHRvIGV2ZW50IGJ1ZmZlciAoZS5nLiBjb3JlIFNESyBldmVudHMpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYXZlIHdlIGF0dGFjaGVkIGxpc3RlbmVycyB0byB0aGUgY29yZSBTREs/XG4gICAqIE5vdGUgd2UgaGF2ZSB0byB0cmFjayB0aGlzIGFzIHRoZXJlIGlzIG5vIHdheSB0byByZW1vdmUgaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXJzLlxuICAgKi9cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gc3RvcCByZWNvcmRpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIEludGVybmFsIHVzZSBmb3IgY2FudmFzIHJlY29yZGluZyBvcHRpb25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2hlbiB2aXNpYmlsaXR5IG9mIHRoZSBwYWdlIGNvbnRlbnQgY2hhbmdlcy4gT3BlbmluZyBhIG5ldyB0YWIgd2lsbFxuICAgKiBjYXVzZSB0aGUgc3RhdGUgdG8gY2hhbmdlIHRvIGhpZGRlbiBiZWNhdXNlIG9mIGNvbnRlbnQgb2YgY3VycmVudCBwYWdlIHdpbGxcbiAgICogYmUgaGlkZGVuLiBMaWtld2lzZSwgbW92aW5nIGEgZGlmZmVyZW50IHdpbmRvdyB0byBjb3ZlciB0aGUgY29udGVudHMgb2YgdGhlXG4gICAqIHBhZ2Ugd2lsbCBhbHNvIHRyaWdnZXIgYSBjaGFuZ2UgdG8gYSBoaWRkZW4gc3RhdGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2hlbiBwYWdlIGlzIGJsdXJyZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSB3aGVuIHBhZ2UgaXMgZm9jdXNlZFxuICAgKi9cblxuICAvKiogRW5zdXJlIHBhZ2UgcmVtYWlucyBhY3RpdmUgd2hlbiBhIGtleSBpcyBwcmVzc2VkLiAqL1xuXG4gICBjb25zdHJ1Y3Rvcih7XG4gICAgb3B0aW9ucyxcbiAgICByZWNvcmRpbmdPcHRpb25zLFxuICB9XG5cbikge1xuICAgIHRoaXMuZXZlbnRCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMucGVyZm9ybWFuY2VFbnRyaWVzID0gW107XG4gICAgdGhpcy5yZXBsYXlQZXJmb3JtYW5jZUVudHJpZXMgPSBbXTtcbiAgICB0aGlzLnJlY29yZGluZ01vZGUgPSAnc2Vzc2lvbic7XG4gICAgdGhpcy50aW1lb3V0cyA9IHtcbiAgICAgIHNlc3Npb25JZGxlUGF1c2U6IFNFU1NJT05fSURMRV9QQVVTRV9EVVJBVElPTixcbiAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiBTRVNTSU9OX0lETEVfRVhQSVJFX0RVUkFUSU9OLFxuICAgIH0gO1xuICAgIHRoaXMuX2xhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1aXJlc01hbnVhbFN0YXJ0ID0gZmFsc2U7XG4gICAgdGhpcy5faGFzSW5pdGlhbGl6ZWRDb3JlTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgdGhpcy5fY29udGV4dCA9IHtcbiAgICAgIGVycm9ySWRzOiBuZXcgU2V0KCksXG4gICAgICB0cmFjZUlkczogbmV3IFNldCgpLFxuICAgICAgdXJsczogW10sXG4gICAgICBpbml0aWFsVGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgaW5pdGlhbFVybDogJycsXG4gICAgfTtcblxuICAgIHRoaXMuX3JlY29yZGluZ09wdGlvbnMgPSByZWNvcmRpbmdPcHRpb25zO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2ggPSBkZWJvdW5jZSgoKSA9PiB0aGlzLl9mbHVzaCgpLCB0aGlzLl9vcHRpb25zLmZsdXNoTWluRGVsYXksIHtcbiAgICAgIG1heFdhaXQ6IHRoaXMuX29wdGlvbnMuZmx1c2hNYXhEZWxheSxcbiAgICB9KTtcblxuICAgIHRoaXMuX3Rocm90dGxlZEFkZEV2ZW50ID0gdGhyb3R0bGUoXG4gICAgICAoZXZlbnQsIGlzQ2hlY2tvdXQpID0+IGFkZEV2ZW50KHRoaXMsIGV2ZW50LCBpc0NoZWNrb3V0KSxcbiAgICAgIC8vIE1heCAzMDAgZXZlbnRzLi4uXG4gICAgICAzMDAsXG4gICAgICAvLyAuLi4gcGVyIDVzXG4gICAgICA1LFxuICAgICk7XG5cbiAgICBjb25zdCB7IHNsb3dDbGlja1RpbWVvdXQsIHNsb3dDbGlja0lnbm9yZVNlbGVjdG9ycyB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCBzbG93Q2xpY2tDb25maWcgPSBzbG93Q2xpY2tUaW1lb3V0XG4gICAgICA/IHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IE1hdGgubWluKFNMT1dfQ0xJQ0tfVEhSRVNIT0xELCBzbG93Q2xpY2tUaW1lb3V0KSxcbiAgICAgICAgICB0aW1lb3V0OiBzbG93Q2xpY2tUaW1lb3V0LFxuICAgICAgICAgIHNjcm9sbFRpbWVvdXQ6IFNMT1dfQ0xJQ0tfU0NST0xMX1RJTUVPVVQsXG4gICAgICAgICAgaWdub3JlU2VsZWN0b3I6IHNsb3dDbGlja0lnbm9yZVNlbGVjdG9ycyA/IHNsb3dDbGlja0lnbm9yZVNlbGVjdG9ycy5qb2luKCcsJykgOiAnJyxcbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2xvd0NsaWNrQ29uZmlnKSB7XG4gICAgICB0aGlzLmNsaWNrRGV0ZWN0b3IgPSBuZXcgQ2xpY2tEZXRlY3Rvcih0aGlzLCBzbG93Q2xpY2tDb25maWcpO1xuICAgIH1cblxuICAgIC8vIENvbmZpZ3VyZSByZXBsYXkgZGVidWcgbG9nZ2VyIHcvIGV4cGVyaW1lbnRhbCBvcHRpb25zXG4gICAgaWYgKERFQlVHX0JVSUxEKSB7XG4gICAgICBjb25zdCBleHBlcmltZW50cyA9IG9wdGlvbnMuX2V4cGVyaW1lbnRzO1xuICAgICAgZGVidWcuc2V0Q29uZmlnKHtcbiAgICAgICAgY2FwdHVyZUV4Y2VwdGlvbnM6ICEhZXhwZXJpbWVudHMuY2FwdHVyZUV4Y2VwdGlvbnMsXG4gICAgICAgIHRyYWNlSW50ZXJuYWxzOiAhIWV4cGVyaW1lbnRzLnRyYWNlSW50ZXJuYWxzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc2V0IHRoZXNlIGhhbmRsZXIgcHJvcGVydGllcyBhcyBjbGFzcyBwcm9wZXJ0aWVzLCB0byBtYWtlIGJpbmRpbmcvdW5iaW5kaW5nIHRoZW0gZWFzaWVyXG4gICAgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChXSU5ET1cuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgdGhpcy5fZG9DaGFuZ2VUb0ZvcmVncm91bmRUYXNrcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZG9DaGFuZ2VUb0JhY2tncm91bmRUYXNrcygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiBwYWdlIGlzIGJsdXJyZWRcbiAgICAgKi9cbiAgICB0aGlzLl9oYW5kbGVXaW5kb3dCbHVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgICAgICBjYXRlZ29yeTogJ3VpLmJsdXInLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIERvIG5vdCBjb3VudCBibHVyIGFzIGEgdXNlciBhY3Rpb24gLS0gaXQncyBwYXJ0IG9mIHRoZSBwcm9jZXNzIG9mIHRoZW1cbiAgICAgIC8vIGxlYXZpbmcgdGhlIHBhZ2VcbiAgICAgIHRoaXMuX2RvQ2hhbmdlVG9CYWNrZ3JvdW5kVGFza3MoYnJlYWRjcnVtYik7XG4gICAgfTtcblxuICAgIHRoaXMuX2hhbmRsZVdpbmRvd0ZvY3VzID0gKCkgPT4ge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IGNyZWF0ZUJyZWFkY3J1bWIoe1xuICAgICAgICBjYXRlZ29yeTogJ3VpLmZvY3VzJyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEbyBub3QgY291bnQgZm9jdXMgYXMgYSB1c2VyIGFjdGlvbiAtLSBpbnN0ZWFkIHdhaXQgdW50aWwgdGhleSBmb2N1cyBhbmRcbiAgICAgIC8vIGludGVyYWN0aXZlIHdpdGggcGFnZVxuICAgICAgdGhpcy5fZG9DaGFuZ2VUb0ZvcmVncm91bmRUYXNrcyhicmVhZGNydW1iKTtcbiAgICB9O1xuXG4gICAgLyoqIEVuc3VyZSBwYWdlIHJlbWFpbnMgYWN0aXZlIHdoZW4gYSBrZXkgaXMgcHJlc3NlZC4gKi9cbiAgICB0aGlzLl9oYW5kbGVLZXlib2FyZEV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICBoYW5kbGVLZXlib2FyZEV2ZW50KHRoaXMsIGV2ZW50KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEdldCB0aGUgZXZlbnQgY29udGV4dC4gKi9cbiAgIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gIH1cblxuICAvKiogSWYgcmVjb3JkaW5nIGlzIGN1cnJlbnRseSBlbmFibGVkLiAqL1xuICAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cblxuICAvKiogSWYgcmVjb3JkaW5nIGlzIGN1cnJlbnRseSBwYXVzZWQuICovXG4gICBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGNhbnZhcyByZWNvcmRpbmcgaXMgZW5hYmxlZFxuICAgKi9cbiAgIGlzUmVjb3JkaW5nQ2FudmFzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2NhbnZhcyk7XG4gIH1cblxuICAvKiogR2V0IHRoZSByZXBsYXkgaW50ZWdyYXRpb24gb3B0aW9ucy4gKi9cbiAgIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICAvKiogQSB3cmFwcGVyIHRvIGNvbmRpdGlvbmFsbHkgY2FwdHVyZSBleGNlcHRpb25zLiAqL1xuICAgaGFuZGxlRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXhjZXB0aW9uKGVycm9yKTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLm9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJhc2VkIG9uIHNhbXBsaW5nIGNvbmZpZ3VyYXRpb24uIFNob3VsZCBub3QgYmVcbiAgICogY2FsbGVkIG91dHNpZGUgb2YgY29uc3RydWN0b3IuXG4gICAqL1xuICAgaW5pdGlhbGl6ZVNhbXBsaW5nKHByZXZpb3VzU2Vzc2lvbklkKSB7XG4gICAgY29uc3QgeyBlcnJvclNhbXBsZVJhdGUsIHNlc3Npb25TYW1wbGVSYXRlIH0gPSB0aGlzLl9vcHRpb25zO1xuXG4gICAgLy8gSWYgbmVpdGhlciBzYW1wbGUgcmF0ZSBpcyA+IDAsIHRoZW4gZG8gbm90aGluZyAtIHVzZXIgd2lsbCBuZWVkIHRvIGNhbGwgb25lIG9mXG4gICAgLy8gYHN0YXJ0KClgIG9yIGBzdGFydEJ1ZmZlcmluZ2AgdGhlbXNlbHZlcy5cbiAgICBjb25zdCByZXF1aXJlc01hbnVhbFN0YXJ0ID0gZXJyb3JTYW1wbGVSYXRlIDw9IDAgJiYgc2Vzc2lvblNhbXBsZVJhdGUgPD0gMDtcblxuICAgIHRoaXMuX3JlcXVpcmVzTWFudWFsU3RhcnQgPSByZXF1aXJlc01hbnVhbFN0YXJ0O1xuXG4gICAgaWYgKHJlcXVpcmVzTWFudWFsU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlcmUgaXMgX2FueV8gc2FtcGxlIHJhdGUgc2V0LCB0cnkgdG8gbG9hZCBhbiBleGlzdGluZ1xuICAgIC8vIHNlc3Npb24sIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgdGhpcy5faW5pdGlhbGl6ZVNlc3Npb25Gb3JTYW1wbGluZyhwcmV2aW91c1Nlc3Npb25JZCk7XG5cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgc29tZXRoaW5nIHdyb25nIGhhcyBvY2N1cnJlZFxuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXhjZXB0aW9uKG5ldyBFcnJvcignVW5hYmxlIHRvIGluaXRpYWxpemUgYW5kIGNyZWF0ZSBzZXNzaW9uJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlc3Npb24uc2FtcGxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgb2NjdXIgaWYgYGVycm9yU2FtcGxlUmF0ZWAgaXMgMCBhbmQgd2FzIHVuc2FtcGxlZCBmb3JcbiAgICAgIC8vIHNlc3Npb24tYmFzZWQgcmVwbGF5LiBJbiB0aGlzIGNhc2UgdGhlcmUgaXMgbm90aGluZyB0byBkby5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWdtZW50SWQgPiAwLCBpdCBtZWFucyB3ZSd2ZSBwcmV2aW91c2x5IGFscmVhZHkgY2FwdHVyZWQgdGhpcyBzZXNzaW9uXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzdGlsbCB3YW50IHRvIGNvbnRpbnVlIGluIGBzZXNzaW9uYCByZWNvcmRpbmcgbW9kZVxuICAgIHRoaXMucmVjb3JkaW5nTW9kZSA9IHRoaXMuc2Vzc2lvbi5zYW1wbGVkID09PSAnYnVmZmVyJyAmJiB0aGlzLnNlc3Npb24uc2VnbWVudElkID09PSAwID8gJ2J1ZmZlcicgOiAnc2Vzc2lvbic7XG5cbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5pbmZvVGljayhgU3RhcnRpbmcgcmVwbGF5IGluICR7dGhpcy5yZWNvcmRpbmdNb2RlfSBtb2RlYCk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplUmVjb3JkaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSByZXBsYXkgcmVnYXJkbGVzcyBvZiBzYW1wbGluZyByYXRlLiBDYWxsaW5nIHRoaXMgd2lsbCBhbHdheXNcbiAgICogY3JlYXRlIGEgbmV3IHNlc3Npb24uIFdpbGwgbG9nIGEgbWVzc2FnZSBpZiByZXBsYXkgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAgICpcbiAgICogQ3JlYXRlcyBvciBsb2FkcyBhIHNlc3Npb24sIGF0dGFjaGVzIGxpc3RlbmVycyB0byB2YXJ5aW5nIGV2ZW50cyAoRE9NLFxuICAgKiBfcGVyZm9ybWFuY2VPYnNlcnZlciwgUmVjb3JkaW5nLCBTZW50cnkgU0RLLCBldGMpXG4gICAqL1xuICAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCAmJiB0aGlzLnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJykge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdSZWNvcmRpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQgJiYgdGhpcy5yZWNvcmRpbmdNb2RlID09PSAnYnVmZmVyJykge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdCdWZmZXJpbmcgaXMgaW4gcHJvZ3Jlc3MsIGNhbGwgYGZsdXNoKClgIHRvIHNhdmUgdGhlIHJlcGxheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmluZm9UaWNrKCdTdGFydGluZyByZXBsYXkgaW4gc2Vzc2lvbiBtb2RlJyk7XG5cbiAgICAvLyBSZXF1aXJlZCBhcyB1c2VyIGFjdGl2aXR5IGlzIGluaXRpYWxseSBzZXQgaW5cbiAgICAvLyBjb25zdHJ1Y3Rvciwgc28gaWYgYHN0YXJ0KClgIGlzIGNhbGxlZCBhZnRlclxuICAgIC8vIHNlc3Npb24gaWRsZSBleHBpcmF0aW9uLCBhIHJlcGxheSB3aWxsIG5vdCBiZVxuICAgIC8vIGNyZWF0ZWQgZHVlIHRvIGFuIGlkbGUgdGltZW91dC5cbiAgICB0aGlzLl91cGRhdGVVc2VyQWN0aXZpdHkoKTtcblxuICAgIGNvbnN0IHNlc3Npb24gPSBsb2FkT3JDcmVhdGVTZXNzaW9uKFxuICAgICAge1xuICAgICAgICBtYXhSZXBsYXlEdXJhdGlvbjogdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbixcbiAgICAgICAgc2Vzc2lvbklkbGVFeHBpcmU6IHRoaXMudGltZW91dHMuc2Vzc2lvbklkbGVFeHBpcmUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdGlja3lTZXNzaW9uOiB0aGlzLl9vcHRpb25zLnN0aWNreVNlc3Npb24sXG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWw6IGNyZWF0ZSBhIG5ldyBzZXNzaW9uLWJhc2VkIHJlcGxheSB3aGVuIGNhbGxpbmcgYHN0YXJ0KClgXG4gICAgICAgIHNlc3Npb25TYW1wbGVSYXRlOiAxLFxuICAgICAgICBhbGxvd0J1ZmZlcmluZzogZmFsc2UsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMucmVjb3JkaW5nTW9kZSA9ICdzZXNzaW9uJztcblxuICAgIHRoaXMuX2luaXRpYWxpemVSZWNvcmRpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCByZXBsYXkgYnVmZmVyaW5nLiBCdWZmZXJzIHVudGlsIGBmbHVzaCgpYCBpcyBjYWxsZWQgb3IsIGlmXG4gICAqIGByZXBsYXlzT25FcnJvclNhbXBsZVJhdGVgID4gMCwgYW4gZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgIHN0YXJ0QnVmZmVyaW5nKCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnQnVmZmVyaW5nIGlzIGluIHByb2dyZXNzLCBjYWxsIGBmbHVzaCgpYCB0byBzYXZlIHRoZSByZXBsYXknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5pbmZvVGljaygnU3RhcnRpbmcgcmVwbGF5IGluIGJ1ZmZlciBtb2RlJyk7XG5cbiAgICBjb25zdCBzZXNzaW9uID0gbG9hZE9yQ3JlYXRlU2Vzc2lvbihcbiAgICAgIHtcbiAgICAgICAgc2Vzc2lvbklkbGVFeHBpcmU6IHRoaXMudGltZW91dHMuc2Vzc2lvbklkbGVFeHBpcmUsXG4gICAgICAgIG1heFJlcGxheUR1cmF0aW9uOiB0aGlzLl9vcHRpb25zLm1heFJlcGxheUR1cmF0aW9uLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3RpY2t5U2Vzc2lvbjogdGhpcy5fb3B0aW9ucy5zdGlja3lTZXNzaW9uLFxuICAgICAgICBzZXNzaW9uU2FtcGxlUmF0ZTogMCxcbiAgICAgICAgYWxsb3dCdWZmZXJpbmc6IHRydWUsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuXG4gICAgdGhpcy5yZWNvcmRpbmdNb2RlID0gJ2J1ZmZlcic7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVJlY29yZGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJlY29yZGluZy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBjYXVzZSBhIG5ldyBET00gY2hlY2tvdXRcbiAgICovXG4gICBzdGFydFJlY29yZGluZygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhcztcblxuICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IHJlY29yZCh7XG4gICAgICAgIC4uLnRoaXMuX3JlY29yZGluZ09wdGlvbnMsXG4gICAgICAgIC8vIFdoZW4gcnVubmluZyBpbiBlcnJvciBzYW1wbGluZyBtb2RlLCB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBgY2hlY2tvdXRFdmVyeU5tc2BcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBpdCB3b3VsZCByZWNvcmQgZm9yZXZlciwgdW50aWwgYW4gZXJyb3IgaGFwcGVucywgd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyBpbnN0ZWFkLCB3ZSdsbCBhbHdheXMga2VlcCB0aGUgbGFzdCA2MCBzZWNvbmRzIG9mIHJlcGxheSBiZWZvcmUgYW4gZXJyb3IgaGFwcGVuZWRcbiAgICAgICAgLi4uKHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcidcbiAgICAgICAgICA/IHsgY2hlY2tvdXRFdmVyeU5tczogQlVGRkVSX0NIRUNLT1VUX1RJTUUgfVxuICAgICAgICAgIDogLy8gT3RoZXJ3aXNlLCB1c2UgZXhwZXJpbWVudGFsIG9wdGlvbiB3LyBtaW4gY2hlY2tvdXQgdGltZSBvZiA2IG1pbnV0ZXNcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gaW1wcm92ZSBwbGF5YmFjayBzZWVraW5nIGFzIHRoZXJlIGNvdWxkIHBvdGVudGlhbGx5IGJlXG4gICAgICAgICAgICAvLyBsZXNzIG11dGF0aW9ucyB0byBwcm9jZXNzIGluIHRoZSB3b3JzZSBjYXNlcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjaGVja291dCBieSBcIk5cIiBldmVudHMgaXMgcHJvYmFibHkgaWRlYWwsIGJ1dCBtZWFucyB3ZSBoYXZlIGxlc3NcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgYWJvdXQgdGhlIG51bWJlciBvZiBjaGVja291dHMgd2UgbWFrZSAod2hpY2ggZ2VuZXJhbGx5XG4gICAgICAgICAgICAvLyBpbmNyZWFzZXMgcmVwbGF5IHNpemUpXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLl9leHBlcmltZW50cy5jb250aW51b3VzQ2hlY2tvdXQgJiYge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNoZWNrb3V0IHRpbWUgaXMgNiBtaW51dGVzXG4gICAgICAgICAgICAgIGNoZWNrb3V0RXZlcnlObXM6IE1hdGgubWF4KDM2MDAwMCwgdGhpcy5fb3B0aW9ucy5fZXhwZXJpbWVudHMuY29udGludW91c0NoZWNrb3V0KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBlbWl0OiBnZXRIYW5kbGVSZWNvcmRpbmdFbWl0KHRoaXMpLFxuICAgICAgICAuLi5nZXRSZWNvcmRpbmdTYW1wbGluZ09wdGlvbnMoKSxcbiAgICAgICAgb25NdXRhdGlvbjogdGhpcy5fb25NdXRhdGlvbkhhbmRsZXIuYmluZCh0aGlzKSxcbiAgICAgICAgLi4uKGNhbnZhc09wdGlvbnNcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiBjYW52YXNPcHRpb25zLnJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgZ2V0Q2FudmFzTWFuYWdlcjogY2FudmFzT3B0aW9ucy5nZXRDYW52YXNNYW5hZ2VyLFxuICAgICAgICAgICAgICBzYW1wbGluZzogY2FudmFzT3B0aW9ucy5zYW1wbGluZyxcbiAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGNhbnZhc09wdGlvbnMuZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSByZWNvcmRpbmcsIGlmIGl0IHdhcyBydW5uaW5nLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXQgd2FzIHByZXZpb3VzbHkgc3RvcHBlZCwgb3IgaXMgbm93IHN0b3BwZWQsXG4gICAqIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gICBzdG9wUmVjb3JkaW5nKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fc3RvcFJlY29yZGluZykge1xuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudGx5LCB0aGlzIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGNhbGxlZCAoZS5nLiBmb3IgdGVzdHMpLiBTZW50cnkgU0RLXG4gICAqIGRvZXMgbm90IHN1cHBvcnQgYSB0ZWFyZG93blxuICAgKi9cbiAgIGFzeW5jIHN0b3AoeyBmb3JjZUZsdXNoID0gZmFsc2UsIHJlYXNvbiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IG1vdmUgYF9pc0VuYWJsZWRgIGFmdGVyIGF3YWl0aW5nIGEgZmx1c2gsIG90aGVyd2lzZSB3ZSBjYW5cbiAgICAvLyBlbnRlciBpbnRvIGFuIGluZmluaXRlIGxvb3Agd2hlbiBgc3RvcCgpYCBpcyBjYWxsZWQgd2hpbGUgZmx1c2hpbmcuXG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVzZXQgYHJlY29yZGluZ01vZGVgIHRvIGBidWZmZXJgIHRvIGF2b2lkIGFueSBhZGRpdGlvbmFsXG4gICAgLy8gYnJlYWRjcnVtYnMgdG8gdHJpZ2dlciBhIGZsdXNoIChlLmcuIGluIGBhZGRVcGRhdGUoKWApXG4gICAgdGhpcy5yZWNvcmRpbmdNb2RlID0gJ2J1ZmZlcic7XG5cbiAgICB0cnkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKGBTdG9wcGluZyBSZXBsYXkke3JlYXNvbiA/IGAgdHJpZ2dlcmVkIGJ5ICR7cmVhc29ufWAgOiAnJ31gKTtcblxuICAgICAgcmVzZXRSZXBsYXlJZE9uRHluYW1pY1NhbXBsaW5nQ29udGV4dCgpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuXG4gICAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcbiAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIHJlOiBgX2lzRW5hYmxlZGAsIHdlIFwiZm9yY2VcIiBhIGZsdXNoLCBpZ25vcmluZyB0aGVcbiAgICAgIC8vIGBfaXNFbmFibGVkYCBzdGF0ZSBvZiB0aGUgcGx1Z2luIHNpbmNlIGl0IHdhcyBkaXNhYmxlZCBhYm92ZS5cbiAgICAgIGlmIChmb3JjZUZsdXNoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2ZsdXNoKHsgZm9yY2U6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGZsdXNoLCBkZXN0cm95IGV2ZW50IGJ1ZmZlclxuICAgICAgdGhpcy5ldmVudEJ1ZmZlcj8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5ldmVudEJ1ZmZlciA9IG51bGw7XG5cbiAgICAgIC8vIENsZWFyIHNlc3Npb24gZnJvbSBzZXNzaW9uIHN0b3JhZ2UsIG5vdGUgdGhpcyBtZWFucyBpZiBhIG5ldyBzZXNzaW9uXG4gICAgICAvLyBpcyBzdGFydGVkIGFmdGVyLCBpdCB3aWxsIG5vdCBoYXZlIGBwcmV2aW91c1Nlc3Npb25JZGBcbiAgICAgIGNsZWFyU2Vzc2lvbih0aGlzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHNvbWUgcmVwbGF5IGZ1bmN0aW9uYWxpdHkuIFNlZSBjb21tZW50cyBmb3IgYF9pc1BhdXNlZGAuXG4gICAqIFRoaXMgZGlmZmVycyBmcm9tIHN0b3AgYXMgdGhpcyBvbmx5IHN0b3BzIERPTSByZWNvcmRpbmcsIGl0IGlzXG4gICAqIG5vdCBhcyB0aG9yb3VnaCBvZiBhIHNodXRkb3duIGFzIGBzdG9wKClgLlxuICAgKi9cbiAgIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcblxuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnUGF1c2luZyByZXBsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHJlY29yZGluZywgc2VlIG5vdGVzIGZvciBgcGF1c2UoKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGNhbGxpbmcgYHN0YXJ0UmVjb3JkaW5nKClgIGhlcmUgd2lsbCBjYXVzZSBhXG4gICAqIG5ldyBET00gY2hlY2tvdXQuYFxuICAgKi9cbiAgIHJlc3VtZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9jaGVja1Nlc3Npb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFJlY29yZGluZygpO1xuXG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdSZXN1bWluZyByZXBsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBub3QgaW4gXCJzZXNzaW9uXCIgcmVjb3JkaW5nIG1vZGUsIGZsdXNoIGV2ZW50IGJ1ZmZlciB3aGljaCB3aWxsIGNyZWF0ZSBhIG5ldyByZXBsYXkuXG4gICAqIFVubGVzcyBgY29udGludWVSZWNvcmRpbmdgIGlzIGZhbHNlLCB0aGUgcmVwbGF5IHdpbGwgY29udGludWUgdG8gcmVjb3JkIGFuZFxuICAgKiBiZWhhdmUgYXMgYSBcInNlc3Npb25cIi1iYXNlZCByZXBsYXkuXG4gICAqXG4gICAqIE90aGVyd2lzZSwgcXVldWUgdXAgYSBmbHVzaC5cbiAgICovXG4gICBhc3luYyBzZW5kQnVmZmVyZWRSZXBsYXlPckZsdXNoKHsgY29udGludWVSZWNvcmRpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZmx1c2hJbW1lZGlhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpdml0eVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdDb252ZXJ0aW5nIGJ1ZmZlciB0byBzZXNzaW9uJyk7XG5cbiAgICAvLyBBbGxvdyBmbHVzaCB0byBjb21wbGV0ZSBiZWZvcmUgcmVzdW1pbmcgYXMgYSBzZXNzaW9uIHJlY29yZGluZywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIGNoZWNrb3V0IGZyb20gYHN0YXJ0UmVjb3JkaW5nYCBtYXkgYmUgaW5jbHVkZWQgaW4gdGhlIHBheWxvYWQuXG4gICAgLy8gUHJlZmVyIHRvIGtlZXAgdGhlIGVycm9yIHJlcGxheSBhcyBhIHNlcGFyYXRlIChhbmQgc21hbGxlcikgc2VnbWVudFxuICAgIC8vIHRoYW4gdGhlIHNlc3Npb24gcmVwbGF5LlxuICAgIGF3YWl0IHRoaXMuZmx1c2hJbW1lZGlhdGUoKTtcblxuICAgIGNvbnN0IGhhc1N0b3BwZWRSZWNvcmRpbmcgPSB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcblxuICAgIGlmICghY29udGludWVSZWNvcmRpbmcgfHwgIWhhc1N0b3BwZWRSZWNvcmRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2hlcmUgdGhpcyBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHdlIGNoZWNrIGhlcmUgYWdhaW4gdGhhdCB3ZSBhcmUgc3RpbGwgYnVmZmVyaW5nXG4gICAgaWYgKCh0aGlzLnJlY29yZGluZ01vZGUgKSA9PT0gJ3Nlc3Npb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmUtc3RhcnQgcmVjb3JkaW5nIGluIHNlc3Npb24tbW9kZVxuICAgIHRoaXMucmVjb3JkaW5nTW9kZSA9ICdzZXNzaW9uJztcblxuICAgIC8vIE9uY2UgdGhpcyBzZXNzaW9uIGVuZHMsIHdlIGRvIG5vdCB3YW50IHRvIHJlZnJlc2ggaXRcbiAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICB0aGlzLnNlc3Npb24uZGlydHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VwZGF0ZVVzZXJBY3Rpdml0eShhY3Rpdml0eVRpbWUpO1xuICAgICAgdGhpcy5fdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KGFjdGl2aXR5VGltZSk7XG4gICAgICB0aGlzLl9tYXliZVNhdmVTZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydFJlY29yZGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gYmF0Y2ggdXBsb2FkcyBvZiByZXBsYXkgZXZlbnRzLiBTYXZlIGV2ZW50cyBvbmx5IGlmXG4gICAqIGA8Zmx1c2hNaW5EZWxheT5gIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZXZlbnRcbiAgICogKk9SKiBpZiBgPGZsdXNoTWF4RGVsYXk+YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLlxuICAgKlxuICAgKiBBY2NlcHRzIGEgY2FsbGJhY2sgdG8gcGVyZm9ybSBzaWRlLWVmZmVjdHMgYW5kIHJldHVybnMgdHJ1ZSB0byBzdG9wIGJhdGNoXG4gICAqIHByb2Nlc3NpbmcgYW5kIGhhbmQgYmFjayBjb250cm9sIHRvIGNhbGxlci5cbiAgICovXG4gICBhZGRVcGRhdGUoY2IpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGFsd2F5cyBydW4gYGNiYCAoZS5nLiBpbiB0aGUgY2FzZSBvZiBgdGhpcy5yZWNvcmRpbmdNb2RlID09ICdidWZmZXInYClcbiAgICBjb25zdCBjYlJlc3VsdCA9IGNiKCk7XG5cbiAgICAvLyBJZiB0aGlzIG9wdGlvbiBpcyB0dXJuZWQgb24gdGhlbiB3ZSB3aWxsIG9ubHkgd2FudCB0byBjYWxsIGBmbHVzaGBcbiAgICAvLyBleHBsaWNpdGx5XG4gICAgaWYgKHRoaXMucmVjb3JkaW5nTW9kZSA9PT0gJ2J1ZmZlcicgfHwgIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGNhbGxiYWNrIGlzIHRydWUsIHdlIGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlIHdpdGggZmx1c2hpbmcgLS0gdGhlXG4gICAgLy8gY2FsbGVyIHdpbGwgbmVlZCB0byBoYW5kbGUgaXQuXG4gICAgaWYgKGNiUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkVXBkYXRlIGlzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5IC0gdXNlIF9kZWJvdW5jZWRGbHVzaCBzbyB0aGF0IGl0XG4gICAgLy8gcmVzcGVjdHMgdGhlIGZsdXNoIGRlbGF5cyBhbmQgZG9lcyBub3QgZmx1c2ggaW1tZWRpYXRlbHlcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgYWN0aXZpdHkgdGltZXN0YW1wIGFuZCByZXN1bWVzIHJlY29yZGluZy4gVGhpcyBzaG91bGQgYmVcbiAgICogY2FsbGVkIGluIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgdXNlciBhY3Rpb24gdGhhdCB3ZSBjb25zaWRlciBhcyB0aGUgdXNlclxuICAgKiBiZWluZyBcImFjdGl2ZVwiIChlLmcuIGEgbW91c2UgY2xpY2spLlxuICAgKi9cbiAgIHRyaWdnZXJVc2VyQWN0aXZpdHkoKSB7XG4gICAgdGhpcy5fdXBkYXRlVXNlckFjdGl2aXR5KCk7XG5cbiAgICAvLyBUaGlzIGNhc2UgbWVhbnMgdGhhdCByZWNvcmRpbmcgd2FzIG9uY2Ugc3RvcHBlZCBkdWUgdG8gaW5hY3Rpdml0eS5cbiAgICAvLyBFbnN1cmUgdGhhdCByZWNvcmRpbmcgaXMgcmVzdW1lZC5cbiAgICBpZiAoIXRoaXMuX3N0b3BSZWNvcmRpbmcpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZXNzaW9uLCBvdGhlcndpc2Ugd2hlbiB0aGUgdXNlciBhY3Rpb24gaXMgZmx1c2hlZCwgaXRcbiAgICAgIC8vIHdpbGwgZ2V0IHJlamVjdGVkIGR1ZSB0byBhbiBleHBpcmVkIHNlc3Npb24uXG4gICAgICBpZiAoIXRoaXMuX2NoZWNrU2Vzc2lvbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGNhdXNlIGEgbmV3IERPTSBjaGVja291dFxuICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UuLi4gcmVjb3JkaW5nIHdhcyBuZXZlciBzdXNwZW5kZWQsIGNvbnRpbnVlIGFzIG5vcm1hbGlzaFxuICAgIHRoaXMuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpO1xuXG4gICAgdGhpcy5fdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlciBhY3Rpdml0eSB0aW1lc3RhbXAgKndpdGhvdXQqIHJlc3VtaW5nXG4gICAqIHJlY29yZGluZy4gU29tZSB1c2VyIGV2ZW50cyAoZS5nLiBrZXlkb3duKSBjYW4gYmUgY3JlYXRlXG4gICAqIGxvdy12YWx1ZSByZXBsYXlzIHRoYXQgb25seSBjb250YWluIHRoZSBrZXlwcmVzcyBhcyBhXG4gICAqIGJyZWFkY3J1bWIuIEluc3RlYWQgdGhpcyB3b3VsZCByZXF1aXJlIG90aGVyIGV2ZW50cyB0b1xuICAgKiBjcmVhdGUgYSBuZXcgcmVwbGF5IGFmdGVyIGEgc2Vzc2lvbiBoYXMgZXhwaXJlZC5cbiAgICovXG4gICB1cGRhdGVVc2VyQWN0aXZpdHkoKSB7XG4gICAgdGhpcy5fdXBkYXRlVXNlckFjdGl2aXR5KCk7XG4gICAgdGhpcy5fdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KCk7XG4gIH1cblxuICAvKipcbiAgICogT25seSBmbHVzaCBpZiBgdGhpcy5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbidgXG4gICAqL1xuICAgY29uZGl0aW9uYWxGbHVzaCgpIHtcbiAgICBpZiAodGhpcy5yZWNvcmRpbmdNb2RlID09PSAnYnVmZmVyJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZsdXNoSW1tZWRpYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggdXNpbmcgZGVib3VuY2UgZmx1c2hcbiAgICovXG4gICBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVib3VuY2VkRmx1c2goKSA7XG4gIH1cblxuICAvKipcbiAgICogQWx3YXlzIGZsdXNoIHZpYSBgX2RlYm91bmNlZEZsdXNoYCBzbyB0aGF0IHdlIGRvIG5vdCBoYXZlIGZsdXNoZXMgdHJpZ2dlcmVkXG4gICAqIGZyb20gY2FsbGluZyBib3RoIGBmbHVzaGAgYW5kIGBfZGVib3VuY2VkRmx1c2hgLiBPdGhlcndpc2UsIHRoZXJlIGNvdWxkIGJlXG4gICAqIGNhc2VzIG9mIG11bHRpcGxlIGZsdXNoZXMgaGFwcGVuaW5nIGNsb3NlbHkgdG9nZXRoZXIuXG4gICAqL1xuICAgZmx1c2hJbW1lZGlhdGUoKSB7XG4gICAgdGhpcy5fZGVib3VuY2VkRmx1c2goKTtcbiAgICAvLyBgLmZsdXNoYCBpcyBwcm92aWRlZCBieSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLCBhbmFsb2dvdXNseSB0byBsb2Rhc2guZGVib3VuY2VcbiAgICByZXR1cm4gdGhpcy5fZGVib3VuY2VkRmx1c2guZmx1c2goKSA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBxdWV1ZWQgdXAgZmx1c2hlcy5cbiAgICovXG4gICBjYW5jZWxGbHVzaCgpIHtcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiAoPXJlcGxheSkgSURcbiAgICpcbiAgICogQHBhcmFtIG9ubHlJZlNhbXBsZWQgLSBJZiB0cnVlLCB3aWxsIG9ubHkgcmV0dXJuIHRoZSBzZXNzaW9uIElEIGlmIHRoZSBzZXNzaW9uIGlzIHNhbXBsZWQuXG4gICAqL1xuICAgZ2V0U2Vzc2lvbklkKG9ubHlJZlNhbXBsZWQpIHtcbiAgICBpZiAob25seUlmU2FtcGxlZCAmJiB0aGlzLnNlc3Npb24/LnNhbXBsZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlc3Npb24/LmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiByZWNvcmRpbmcgc2hvdWxkIGJlIHN0b3BwZWQgZHVlIHRvIHVzZXIgaW5hY3Rpdml0eS4gT3RoZXJ3aXNlXG4gICAqIGNoZWNrIGlmIHNlc3Npb24gaXMgZXhwaXJlZCBhbmQgY3JlYXRlIGEgbmV3IHNlc3Npb24gaWYgc28uIFRyaWdnZXJzIGEgbmV3XG4gICAqIGZ1bGwgc25hcHNob3Qgb24gbmV3IHNlc3Npb24uXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBzZXNzaW9uIGlzIG5vdCBleHBpcmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBoaWRkZW5cbiAgICovXG4gICBjaGVja0FuZEhhbmRsZUV4cGlyZWRTZXNzaW9uKCkge1xuICAgIC8vIFByZXZlbnQgc3RhcnRpbmcgYSBuZXcgc2Vzc2lvbiBpZiB0aGUgbGFzdCB1c2VyIGFjdGl2aXR5IGlzIG9sZGVyIHRoYW5cbiAgICAvLyBTRVNTSU9OX0lETEVfUEFVU0VfRFVSQVRJT04uIE90aGVyd2lzZSBub24tdXNlciBhY3Rpdml0eSBjYW4gdHJpZ2dlciBhIG5ld1xuICAgIC8vIHNlc3Npb24rcmVjb3JkaW5nLiBUaGlzIGNyZWF0ZXMgbm9pc3kgcmVwbGF5cyB0aGF0IGRvIG5vdCBoYXZlIG11Y2hcbiAgICAvLyBjb250ZW50IGluIHRoZW0uXG4gICAgaWYgKFxuICAgICAgdGhpcy5fbGFzdEFjdGl2aXR5ICYmXG4gICAgICBpc0V4cGlyZWQodGhpcy5fbGFzdEFjdGl2aXR5LCB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlUGF1c2UpICYmXG4gICAgICB0aGlzLnNlc3Npb24gJiZcbiAgICAgIHRoaXMuc2Vzc2lvbi5zYW1wbGVkID09PSAnc2Vzc2lvbidcbiAgICApIHtcbiAgICAgIC8vIFBhdXNlIHJlY29yZGluZyBvbmx5IGZvciBzZXNzaW9uLWJhc2VkIHJlcGxheXMuIE90aGVyd2lzZSwgcmVzdW1pbmdcbiAgICAgIC8vIHdpbGwgY3JlYXRlIGEgbmV3IHJlcGxheSBhbmQgd2lsbCBjb25mbGljdCB3aXRoIHVzZXJzIHdobyBvbmx5IGNob29zZVxuICAgICAgLy8gdG8gcmVjb3JkIGVycm9yLWJhc2VkIHJlcGxheXMgb25seS4gKGUuZy4gdGhlIHJlc3VtZWQgcmVwbGF5IHdpbGwgbm90XG4gICAgICAvLyBjb250YWluIGEgcmVmZXJlbmNlIHRvIGFuIGVycm9yKVxuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIC0tLSBUaGVyZSBpcyByZWNlbnQgdXNlciBhY3Rpdml0eSAtLS0gLy9cbiAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IHNlc3Npb24gaWYgZXhwaXJlZCwgYmFzZWQgb24gZXhwaXJ5IGxlbmd0aFxuICAgIGlmICghdGhpcy5fY2hlY2tTZXNzaW9uKCkpIHtcbiAgICAgIC8vIENoZWNrIHNlc3Npb24gaGFuZGxlcyB0aGUgcmVmcmVzaGluZyBpdHNlbGZcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIHNvbWUgaW5pdGlhbCBzdGF0ZSB0aGF0IGNhbiBjaGFuZ2UgdGhyb3VnaG91dCB0aGUgbGlmZXNwYW4gb2YgdGhlXG4gICAqIHJlcGxheS4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIG90aGVyd2lzZSB0aGV5IHdvdWxkIGJlIGNhcHR1cmVkIGF0IHRoZVxuICAgKiBmaXJzdCBmbHVzaC5cbiAgICovXG4gICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgdXJsUGF0aCA9IGAke1dJTkRPVy5sb2NhdGlvbi5wYXRobmFtZX0ke1dJTkRPVy5sb2NhdGlvbi5oYXNofSR7V0lORE9XLmxvY2F0aW9uLnNlYXJjaH1gO1xuICAgIGNvbnN0IHVybCA9IGAke1dJTkRPVy5sb2NhdGlvbi5vcmlnaW59JHt1cmxQYXRofWA7XG5cbiAgICB0aGlzLnBlcmZvcm1hbmNlRW50cmllcyA9IFtdO1xuICAgIHRoaXMucmVwbGF5UGVyZm9ybWFuY2VFbnRyaWVzID0gW107XG5cbiAgICAvLyBSZXNldCBfY29udGV4dCBhcyB3ZWxsXG4gICAgdGhpcy5fY2xlYXJDb250ZXh0KCk7XG5cbiAgICB0aGlzLl9jb250ZXh0LmluaXRpYWxVcmwgPSB1cmw7XG4gICAgdGhpcy5fY29udGV4dC5pbml0aWFsVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLl9jb250ZXh0LnVybHMucHVzaCh1cmwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGJyZWFkY3J1bWIgZXZlbnQsIHRoYXQgbWF5IGJlIHRocm90dGxlZC5cbiAgICogSWYgaXQgd2FzIHRocm90dGxlZCwgd2UgYWRkIGEgY3VzdG9tIGJyZWFkY3J1bWIgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICovXG4gICB0aHJvdHRsZWRBZGRFdmVudChcbiAgICBldmVudCxcbiAgICBpc0NoZWNrb3V0LFxuICApIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLl90aHJvdHRsZWRBZGRFdmVudChldmVudCwgaXNDaGVja291dCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIFRIUk9UVExFRCwgaXQgbWVhbnMgd2UgaGF2ZSB0aHJvdHRsZWQgdGhlIGV2ZW50IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byBhZGQgYSBicmVhZGNydW1iIGluZGljYXRpbmcgdGhhdCBzb21ldGhpbmcgd2FzIHNraXBwZWRcbiAgICBpZiAocmVzID09PSBUSFJPVFRMRUQpIHtcbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSBjcmVhdGVCcmVhZGNydW1iKHtcbiAgICAgICAgY2F0ZWdvcnk6ICdyZXBsYXkudGhyb3R0bGVkJyxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZFVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIC8vIFJldHVybiBgZmFsc2VgIGlmIHRoZSBldmVudCBfd2FzXyBhZGRlZCwgYXMgdGhhdCBtZWFucyB3ZSBzY2hlZHVsZSBhIGZsdXNoXG4gICAgICAgIHJldHVybiAhYWRkRXZlbnRTeW5jKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBSZXBsYXlFdmVudFR5cGVDdXN0b20sXG4gICAgICAgICAgdGltZXN0YW1wOiBicmVhZGNydW1iLnRpbWVzdGFtcCB8fCAwLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhZzogJ2JyZWFkY3J1bWInLFxuICAgICAgICAgICAgcGF5bG9hZDogYnJlYWRjcnVtYixcbiAgICAgICAgICAgIG1ldHJpYzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyB3aWxsIGdldCB0aGUgcGFyYW1ldHJpemVkIHJvdXRlIG5hbWUgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiBwZXJmb3JtYW5jZSBpcyBlbmFibGVkLCBhbmQgaWYgYW4gaW5zdHJ1bWVudGVkIHJvdXRlciBpcyB1c2VkLlxuICAgKi9cbiAgIGdldEN1cnJlbnRSb3V0ZSgpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlU3BhbiA9IHRoaXMubGFzdEFjdGl2ZVNwYW4gfHwgZ2V0QWN0aXZlU3BhbigpO1xuICAgIGNvbnN0IGxhc3RSb290U3BhbiA9IGxhc3RBY3RpdmVTcGFuICYmIGdldFJvb3RTcGFuKGxhc3RBY3RpdmVTcGFuKTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAobGFzdFJvb3RTcGFuICYmIHNwYW5Ub0pTT04obGFzdFJvb3RTcGFuKS5kYXRhKSB8fCB7fTtcbiAgICBjb25zdCBzb3VyY2UgPSBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTtcbiAgICBpZiAoIWxhc3RSb290U3BhbiB8fCAhc291cmNlIHx8ICFbJ3JvdXRlJywgJ2N1c3RvbSddLmluY2x1ZGVzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW5Ub0pTT04obGFzdFJvb3RTcGFuKS5kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGFuZCBzdGFydCBhbGwgbGlzdGVuZXJzIHRvIHZhcnlpbmcgZXZlbnRzIChET00sXG4gICAqIFBlcmZvcm1hbmNlIE9ic2VydmVyLCBSZWNvcmRpbmcsIFNlbnRyeSBTREssIGV0YylcbiAgICovXG4gICBfaW5pdGlhbGl6ZVJlY29yZGluZygpIHtcbiAgICB0aGlzLnNldEluaXRpYWxTdGF0ZSgpO1xuXG4gICAgLy8gdGhpcyBtZXRob2QgaXMgZ2VuZXJhbGx5IGNhbGxlZCBvbiBwYWdlIGxvYWQgb3IgbWFudWFsbHkgLSBpbiBib3RoIGNhc2VzXG4gICAgLy8gd2Ugc2hvdWxkIHRyZWF0IGl0IGFzIGFuIGFjdGl2aXR5XG4gICAgdGhpcy5fdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KCk7XG5cbiAgICB0aGlzLmV2ZW50QnVmZmVyID0gY3JlYXRlRXZlbnRCdWZmZXIoe1xuICAgICAgdXNlQ29tcHJlc3Npb246IHRoaXMuX29wdGlvbnMudXNlQ29tcHJlc3Npb24sXG4gICAgICB3b3JrZXJVcmw6IHRoaXMuX29wdGlvbnMud29ya2VyVXJsLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYWRkTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBOZWVkIHRvIHNldCBhcyBlbmFibGVkIGJlZm9yZSB3ZSBzdGFydCByZWNvcmRpbmcsIGFzIGByZWNvcmQoKWAgY2FuIHRyaWdnZXIgYSBmbHVzaCB3aXRoIGEgbmV3IGNoZWNrb3V0XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGFydFJlY29yZGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIChvciByZWZyZXNoZXMpIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqL1xuICAgX2luaXRpYWxpemVTZXNzaW9uRm9yU2FtcGxpbmcocHJldmlvdXNTZXNzaW9uSWQpIHtcbiAgICAvLyBXaGVuZXZlciB0aGVyZSBpcyBfYW55XyBlcnJvciBzYW1wbGUgcmF0ZSwgd2UgYWx3YXlzIGFsbG93IGJ1ZmZlcmluZ1xuICAgIC8vIEJlY2F1c2Ugd2UgZGVjaWRlIG9uIHNhbXBsaW5nIHdoZW4gYW4gZXJyb3Igb2NjdXJzLCB3ZSBuZWVkIHRvIGJ1ZmZlciBhdCBhbGwgdGltZXMgaWYgc2FtcGxpbmcgZm9yIGVycm9yc1xuICAgIGNvbnN0IGFsbG93QnVmZmVyaW5nID0gdGhpcy5fb3B0aW9ucy5lcnJvclNhbXBsZVJhdGUgPiAwO1xuXG4gICAgY29uc3Qgc2Vzc2lvbiA9IGxvYWRPckNyZWF0ZVNlc3Npb24oXG4gICAgICB7XG4gICAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlRXhwaXJlLFxuICAgICAgICBtYXhSZXBsYXlEdXJhdGlvbjogdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbixcbiAgICAgICAgcHJldmlvdXNTZXNzaW9uSWQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdGlja3lTZXNzaW9uOiB0aGlzLl9vcHRpb25zLnN0aWNreVNlc3Npb24sXG4gICAgICAgIHNlc3Npb25TYW1wbGVSYXRlOiB0aGlzLl9vcHRpb25zLnNlc3Npb25TYW1wbGVSYXRlLFxuICAgICAgICBhbGxvd0J1ZmZlcmluZyxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGFuZCBwb3RlbnRpYWxseSByZWZyZXNoZXMgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICogUmV0dXJucyBmYWxzZSBpZiBzZXNzaW9uIGlzIG5vdCByZWNvcmRlZC5cbiAgICovXG4gICBfY2hlY2tTZXNzaW9uKCkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHNlc3Npb24geWV0LCB3ZSBkbyBub3Qgd2FudCB0byByZWZyZXNoIGFueXRoaW5nXG4gICAgLy8gVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBoYXBwZW4sIGJ1dCB0byBiZSBzYWZlLi4uLlxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoXG4gICAgICBzaG91bGRSZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbiwge1xuICAgICAgICBzZXNzaW9uSWRsZUV4cGlyZTogdGhpcy50aW1lb3V0cy5zZXNzaW9uSWRsZUV4cGlyZSxcbiAgICAgICAgbWF4UmVwbGF5RHVyYXRpb246IHRoaXMuX29wdGlvbnMubWF4UmVwbGF5RHVyYXRpb24sXG4gICAgICB9KVxuICAgICkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLl9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBhIHNlc3Npb24gd2l0aCBhIG5ldyBvbmUuXG4gICAqIFRoaXMgc3RvcHMgdGhlIGN1cnJlbnQgc2Vzc2lvbiAod2l0aG91dCBmb3JjaW5nIGEgZmx1c2gsIGFzIHRoYXQgd291bGQgbmV2ZXIgd29yayBzaW5jZSB3ZSBhcmUgZXhwaXJlZCksXG4gICAqIGFuZCB0aGVuIGRvZXMgYSBuZXcgc2FtcGxpbmcgYmFzZWQgb24gdGhlIHJlZnJlc2hlZCBzZXNzaW9uLlxuICAgKi9cbiAgIGFzeW5jIF9yZWZyZXNoU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdG9wKHsgcmVhc29uOiAncmVmcmVzaCBzZXNzaW9uJyB9KTtcbiAgICB0aGlzLmluaXRpYWxpemVTYW1wbGluZyhzZXNzaW9uLmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVycyB0byByZWNvcmQgZXZlbnRzIGZvciB0aGUgcmVwbGF5XG4gICAqL1xuICAgX2FkZExpc3RlbmVycygpIHtcbiAgICB0cnkge1xuICAgICAgV0lORE9XLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIFdJTkRPVy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlV2luZG93Qmx1cik7XG4gICAgICBXSU5ET1cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVXaW5kb3dGb2N1cyk7XG4gICAgICBXSU5ET1cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleWJvYXJkRXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5jbGlja0RldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xpY2tEZXRlY3Rvci5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIHJlbW92ZSB0aGVzZSBsaXN0ZW5lcnMsIHNvIGVuc3VyZSB0aGV5IGFyZSBvbmx5IGFkZGVkIG9uY2VcbiAgICAgIGlmICghdGhpcy5faGFzSW5pdGlhbGl6ZWRDb3JlTGlzdGVuZXJzKSB7XG4gICAgICAgIGFkZEdsb2JhbExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICB0aGlzLl9oYXNJbml0aWFsaXplZENvcmVMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZXJmb3JtYW5jZUNsZWFudXBDYWxsYmFjayA9IHNldHVwUGVyZm9ybWFuY2VPYnNlcnZlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgbGlzdGVuZXJzIHRoYXQgd2VyZSBjcmVhdGVkIGluIGBfYWRkTGlzdGVuZXJzYFxuICAgKi9cbiAgIF9yZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIFdJTkRPVy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5faGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG5cbiAgICAgIFdJTkRPVy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlV2luZG93Qmx1cik7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVXaW5kb3dGb2N1cyk7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleWJvYXJkRXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5jbGlja0RldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2xpY2tEZXRlY3Rvci5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BlcmZvcm1hbmNlQ2xlYW51cENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BlcmZvcm1hbmNlQ2xlYW51cENhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmhhbmRsZUV4Y2VwdGlvbihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYXNrcyB0byBydW4gd2hlbiB3ZSBjb25zaWRlciBhIHBhZ2UgdG8gYmUgaGlkZGVuICh2aWEgYmx1cnJpbmcgYW5kL29yIHZpc2liaWxpdHkpXG4gICAqL1xuICAgX2RvQ2hhbmdlVG9CYWNrZ3JvdW5kVGFza3MoYnJlYWRjcnVtYikge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhwaXJlZCA9IGlzU2Vzc2lvbkV4cGlyZWQodGhpcy5zZXNzaW9uLCB7XG4gICAgICBtYXhSZXBsYXlEdXJhdGlvbjogdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbixcbiAgICAgIHNlc3Npb25JZGxlRXhwaXJlOiB0aGlzLnRpbWVvdXRzLnNlc3Npb25JZGxlRXhwaXJlLFxuICAgIH0pO1xuXG4gICAgaWYgKGV4cGlyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYnJlYWRjcnVtYikge1xuICAgICAgdGhpcy5fY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHJlcGxheSB3aGVuIHRoZSBwYWdlL3RhYiBiZWNvbWVzIGhpZGRlbi4gVGhlcmUgaXMgbm8gcmVhc29uIHRvIHNlbmRcbiAgICAvLyByZXBsYXkgaWYgaXQgYmVjb21lcyB2aXNpYmxlLCBzaW5jZSBubyBhY3Rpb25zIHdlIGNhcmUgYWJvdXQgd2VyZSBkb25lXG4gICAgLy8gd2hpbGUgaXQgd2FzIGhpZGRlblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB2b2lkIHRoaXMuY29uZGl0aW9uYWxGbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRhc2tzIHRvIHJ1biB3aGVuIHdlIGNvbnNpZGVyIGEgcGFnZSB0byBiZSB2aXNpYmxlICh2aWEgZm9jdXMgYW5kL29yIHZpc2liaWxpdHkpXG4gICAqL1xuICAgX2RvQ2hhbmdlVG9Gb3JlZ3JvdW5kVGFza3MoYnJlYWRjcnVtYikge1xuICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNTZXNzaW9uQWN0aXZlID0gdGhpcy5jaGVja0FuZEhhbmRsZUV4cGlyZWRTZXNzaW9uKCk7XG5cbiAgICBpZiAoIWlzU2Vzc2lvbkFjdGl2ZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIGNvbWUgYmFjayB0byB0aGUgcGFnZSB3aXRoaW4gU0VTU0lPTl9JRExFX1BBVVNFX0RVUkFUSU9OXG4gICAgICAvLyBtcywgd2Ugd2lsbCByZS11c2UgdGhlIGV4aXN0aW5nIHNlc3Npb24sIG90aGVyd2lzZSBjcmVhdGUgYSBuZXdcbiAgICAgIC8vIHNlc3Npb25cbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnRG9jdW1lbnQgaGFzIGJlY29tZSBhY3RpdmUsIGJ1dCBzZXNzaW9uIGhhcyBleHBpcmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGJyZWFkY3J1bWIpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZUN1c3RvbUJyZWFkY3J1bWIoYnJlYWRjcnVtYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB1c2VyIGFjdGl2aXR5IChhY3Jvc3Mgc2Vzc2lvbiBsaWZlc3BhbnMpXG4gICAqL1xuICAgX3VwZGF0ZVVzZXJBY3Rpdml0eShfbGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKSkge1xuICAgIHRoaXMuX2xhc3RBY3Rpdml0eSA9IF9sYXN0QWN0aXZpdHk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGxhc3QgYWN0aXZpdHkgdGltZXN0YW1wXG4gICAqL1xuICAgX3VwZGF0ZVNlc3Npb25BY3Rpdml0eShfbGFzdEFjdGl2aXR5ID0gRGF0ZS5ub3coKSkge1xuICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5sYXN0QWN0aXZpdHkgPSBfbGFzdEFjdGl2aXR5O1xuICAgICAgdGhpcy5fbWF5YmVTYXZlU2Vzc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gY3JlYXRlIChhbmQgYnVmZmVyKSBhIHJlcGxheSBicmVhZGNydW1iIGZyb20gYSBjb3JlIFNESyBicmVhZGNydW1iXG4gICAqL1xuICAgX2NyZWF0ZUN1c3RvbUJyZWFkY3J1bWIoYnJlYWRjcnVtYikge1xuICAgIHRoaXMuYWRkVXBkYXRlKCgpID0+IHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIHJlamVjdFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgdGhpcy50aHJvdHRsZWRBZGRFdmVudCh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgICAgIHRpbWVzdGFtcDogYnJlYWRjcnVtYi50aW1lc3RhbXAgfHwgMCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRhZzogJ2JyZWFkY3J1bWInLFxuICAgICAgICAgIHBheWxvYWQ6IGJyZWFkY3J1bWIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlZCBwZXJmb3JtYW5jZSBldmVudHMgYXJlIGFkZGVkIHRvIGB0aGlzLnBlcmZvcm1hbmNlRW50cmllc2AuIFRoZXNlXG4gICAqIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVwbGF5IGV2ZW50IGJlZm9yZSBpdCBpcyBmaW5pc2hlZCBhbmQgc2VudCB0byBTZW50cnkuXG4gICAqL1xuICAgX2FkZFBlcmZvcm1hbmNlRW50cmllcygpIHtcbiAgICBsZXQgcGVyZm9ybWFuY2VFbnRyaWVzID0gY3JlYXRlUGVyZm9ybWFuY2VFbnRyaWVzKHRoaXMucGVyZm9ybWFuY2VFbnRyaWVzKS5jb25jYXQodGhpcy5yZXBsYXlQZXJmb3JtYW5jZUVudHJpZXMpO1xuXG4gICAgdGhpcy5wZXJmb3JtYW5jZUVudHJpZXMgPSBbXTtcbiAgICB0aGlzLnJlcGxheVBlcmZvcm1hbmNlRW50cmllcyA9IFtdO1xuXG4gICAgLy8gSWYgd2UgYXJlIG1hbnVhbGx5IHN0YXJ0aW5nLCB3ZSB3YW50IHRvIGVuc3VyZSB3ZSBvbmx5IGluY2x1ZGUgcGVyZm9ybWFuY2UgZW50cmllc1xuICAgIC8vIHRoYXQgYXJlIGFmdGVyIHRoZSBpbml0aWFsIHRpbWVzdGFtcFxuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB3ZSBtYXkgaGF2ZSBwZXJmb3JtYW5jZSBlbnRyaWVzIGZyb20gdGhlIHBhZ2UgbG9hZCwgYnV0IG1heSBkZWNpZGUgdG8gc3RhcnRcbiAgICAvLyB0aGUgcmVwbGF5IGxhdGVyIG9uLCBpbiB3aGljaCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgdGhlc2UgZW50cmllcy5cbiAgICAvLyB3aXRob3V0IHRoaXMsIG1hbnVhbGx5IHN0YXJ0ZWQgcmVwbGF5cyBjYW4gaGF2ZSBldmVudHMgbG9uZyBiZWZvcmUgdGhlIGFjdHVhbCByZXBsYXkgcmVjb3JkaW5nIHN0YXJ0cyxcbiAgICAvLyB3aGljaCBtZXNzZXMgd2l0aCB0aGUgdGltZWxpbmUgZXRjLlxuICAgIGlmICh0aGlzLl9yZXF1aXJlc01hbnVhbFN0YXJ0KSB7XG4gICAgICBjb25zdCBpbml0aWFsVGltZXN0YW1wSW5TZWNvbmRzID0gdGhpcy5fY29udGV4dC5pbml0aWFsVGltZXN0YW1wIC8gMTAwMDtcbiAgICAgIHBlcmZvcm1hbmNlRW50cmllcyA9IHBlcmZvcm1hbmNlRW50cmllcy5maWx0ZXIoZW50cnkgPT4gZW50cnkuc3RhcnQgPj0gaW5pdGlhbFRpbWVzdGFtcEluU2Vjb25kcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGNyZWF0ZVBlcmZvcm1hbmNlU3BhbnModGhpcywgcGVyZm9ybWFuY2VFbnRyaWVzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgX2NvbnRleHRcbiAgICovXG4gICBfY2xlYXJDb250ZXh0KCkge1xuICAgIC8vIFhYWDogYGluaXRpYWxUaW1lc3RhbXBgIGFuZCBgaW5pdGlhbFVybGAgZG8gbm90IGdldCBjbGVhcmVkXG4gICAgdGhpcy5fY29udGV4dC5lcnJvcklkcy5jbGVhcigpO1xuICAgIHRoaXMuX2NvbnRleHQudHJhY2VJZHMuY2xlYXIoKTtcbiAgICB0aGlzLl9jb250ZXh0LnVybHMgPSBbXTtcbiAgfVxuXG4gIC8qKiBVcGRhdGUgdGhlIGluaXRpYWwgdGltZXN0YW1wIGJhc2VkIG9uIHRoZSBidWZmZXIgY29udGVudC4gKi9cbiAgIF91cGRhdGVJbml0aWFsVGltZXN0YW1wRnJvbUV2ZW50QnVmZmVyKCkge1xuICAgIGNvbnN0IHsgc2Vzc2lvbiwgZXZlbnRCdWZmZXIgfSA9IHRoaXM7XG4gICAgLy8gSWYgcmVwbGF5IHdhcyBzdGFydGVkIG1hbnVhbGx5ICg9bm8gc2FtcGxlIHJhdGUgd2FzIGdpdmVuKSxcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBiYWNrLXBvcnQgdGhlIGluaXRpYWwgdGltZXN0YW1wXG4gICAgaWYgKCFzZXNzaW9uIHx8ICFldmVudEJ1ZmZlciB8fCB0aGlzLl9yZXF1aXJlc01hbnVhbFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2Ugb25seSBldmVyIHVwZGF0ZSB0aGlzIG9uIHRoZSBpbml0aWFsIHNlZ21lbnRcbiAgICBpZiAoc2Vzc2lvbi5zZWdtZW50SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlYXJsaWVzdEV2ZW50ID0gZXZlbnRCdWZmZXIuZ2V0RWFybGllc3RUaW1lc3RhbXAoKTtcbiAgICBpZiAoZWFybGllc3RFdmVudCAmJiBlYXJsaWVzdEV2ZW50IDwgdGhpcy5fY29udGV4dC5pbml0aWFsVGltZXN0YW1wKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXAgPSBlYXJsaWVzdEV2ZW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW5kIGNsZWFyIF9jb250ZXh0XG4gICAqL1xuICAgX3BvcEV2ZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBfY29udGV4dCA9IHtcbiAgICAgIGluaXRpYWxUaW1lc3RhbXA6IHRoaXMuX2NvbnRleHQuaW5pdGlhbFRpbWVzdGFtcCxcbiAgICAgIGluaXRpYWxVcmw6IHRoaXMuX2NvbnRleHQuaW5pdGlhbFVybCxcbiAgICAgIGVycm9ySWRzOiBBcnJheS5mcm9tKHRoaXMuX2NvbnRleHQuZXJyb3JJZHMpLFxuICAgICAgdHJhY2VJZHM6IEFycmF5LmZyb20odGhpcy5fY29udGV4dC50cmFjZUlkcyksXG4gICAgICB1cmxzOiB0aGlzLl9jb250ZXh0LnVybHMsXG4gICAgfTtcblxuICAgIHRoaXMuX2NsZWFyQ29udGV4dCgpO1xuXG4gICAgcmV0dXJuIF9jb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgcmVwbGF5IGV2ZW50IGJ1ZmZlciB0byBTZW50cnkuXG4gICAqXG4gICAqIFBlcmZvcm1hbmNlIGV2ZW50cyBhcmUgb25seSBhZGRlZCByaWdodCBiZWZvcmUgZmx1c2hpbmcgLSB0aGlzIGlzXG4gICAqIGR1ZSB0byB0aGUgYnVmZmVyZWQgcGVyZm9ybWFuY2Ugb2JzZXJ2ZXIgZXZlbnRzLlxuICAgKlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGRpcmVjdGx5LCBvbmx5IGJ5IGBmbHVzaGBcbiAgICovXG4gICBhc3luYyBfcnVuRmx1c2goKSB7XG4gICAgY29uc3QgcmVwbGF5SWQgPSB0aGlzLmdldFNlc3Npb25JZCgpO1xuXG4gICAgaWYgKCF0aGlzLnNlc3Npb24gfHwgIXRoaXMuZXZlbnRCdWZmZXIgfHwgIXJlcGxheUlkKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5lcnJvcignTm8gc2Vzc2lvbiBvciBldmVudEJ1ZmZlciBmb3VuZCB0byBmbHVzaC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLl9hZGRQZXJmb3JtYW5jZUVudHJpZXMoKTtcblxuICAgIC8vIENoZWNrIGV2ZW50QnVmZmVyIGFnYWluLCBhcyBpdCBjb3VsZCBoYXZlIGJlZW4gc3RvcHBlZCBpbiB0aGUgbWVhbndoaWxlXG4gICAgaWYgKCF0aGlzLmV2ZW50QnVmZmVyPy5oYXNFdmVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGF0dGFjaCBtZW1vcnkgZXZlbnQgaWYgZXZlbnRCdWZmZXIgaXMgbm90IGVtcHR5XG4gICAgYXdhaXQgYWRkTWVtb3J5RW50cnkodGhpcyk7XG5cbiAgICAvLyBDaGVjayBldmVudEJ1ZmZlciBhZ2FpbiwgYXMgaXQgY291bGQgaGF2ZSBiZWVuIHN0b3BwZWQgaW4gdGhlIG1lYW53aGlsZVxuICAgIGlmICghdGhpcy5ldmVudEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgY2hhbmdlZCBpbiB0aGUgbWVhbndoaWxlLCBlLmcuIGJlY2F1c2UgdGhlIHNlc3Npb24gd2FzIHJlZnJlc2hlZCBvciBzaW1pbGFyLCB3ZSBhYm9ydCBoZXJlXG4gICAgaWYgKHJlcGxheUlkICE9PSB0aGlzLmdldFNlc3Npb25JZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgdXNlcyB0aGUgZGF0YSBmcm9tIHRoZSBldmVudEJ1ZmZlciwgc28gd2UgbmVlZCB0byBjYWxsIHRoaXMgYmVmb3JlIGBmaW5pc2goKVxuICAgICAgdGhpcy5fdXBkYXRlSW5pdGlhbFRpbWVzdGFtcEZyb21FdmVudEJ1ZmZlcigpO1xuXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBDaGVjayB0b3RhbCBkdXJhdGlvbiBhZ2FpbiwgdG8gYXZvaWQgc2VuZGluZyBvdXRkYXRlZCBzdHVmZlxuICAgICAgLy8gV2UgbGVhdmUgMzBzIHdpZ2dsZSByb29tIHRvIGFjY29tbW9kYXRlIGxhdGUgZmx1c2hpbmcgZXRjLlxuICAgICAgLy8gVGhpcyBfY291bGRfIGhhcHBlbiB3aGVuIHRoZSBicm93c2VyIGlzIHN1c3BlbmRlZCBkdXJpbmcgZmx1c2hpbmcsIGluIHdoaWNoIGNhc2Ugd2UganVzdCB3YW50IHRvIHN0b3BcbiAgICAgIGlmICh0aW1lc3RhbXAgLSB0aGlzLl9jb250ZXh0LmluaXRpYWxUaW1lc3RhbXAgPiB0aGlzLl9vcHRpb25zLm1heFJlcGxheUR1cmF0aW9uICsgMzAwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGlzIHRvbyBsb25nLCBub3Qgc2VuZGluZyByZXBsYXknKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXZlbnRDb250ZXh0ID0gdGhpcy5fcG9wRXZlbnRDb250ZXh0KCk7XG4gICAgICAvLyBBbHdheXMgaW5jcmVtZW50IHNlZ21lbnRJZCByZWdhcmRsZXNzIG9mIG91dGNvbWUgb2Ygc2VuZGluZyByZXBsYXlcbiAgICAgIGNvbnN0IHNlZ21lbnRJZCA9IHRoaXMuc2Vzc2lvbi5zZWdtZW50SWQrKztcbiAgICAgIHRoaXMuX21heWJlU2F2ZVNlc3Npb24oKTtcblxuICAgICAgLy8gTm90ZSB0aGlzIGVtcHRpZXMgdGhlIGV2ZW50IGJ1ZmZlciByZWdhcmRsZXNzIG9mIG91dGNvbWUgb2Ygc2VuZGluZyByZXBsYXlcbiAgICAgIGNvbnN0IHJlY29yZGluZ0RhdGEgPSBhd2FpdCB0aGlzLmV2ZW50QnVmZmVyLmZpbmlzaCgpO1xuXG4gICAgICBhd2FpdCBzZW5kUmVwbGF5KHtcbiAgICAgICAgcmVwbGF5SWQsXG4gICAgICAgIHJlY29yZGluZ0RhdGEsXG4gICAgICAgIHNlZ21lbnRJZCxcbiAgICAgICAgZXZlbnRDb250ZXh0LFxuICAgICAgICBzZXNzaW9uOiB0aGlzLnNlc3Npb24sXG4gICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgb25FcnJvcjogZXJyID0+IHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVyciksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9uKGVycik7XG5cbiAgICAgIC8vIFRoaXMgbWVhbnMgd2UgcmV0cmllZCAzIHRpbWVzIGFuZCBhbGwgb2YgdGhlbSBmYWlsZWQsXG4gICAgICAvLyBvciB3ZSByYW4gaW50byBhIHByb2JsZW0gd2UgZG9uJ3Qgd2FudCB0byByZXRyeSwgbGlrZSByYXRlIGxpbWl0aW5nLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgcmVwbGF5IC0gb3RoZXJ3aXNlLCB3ZSBtYXkgZ2V0IGluY29uc2lzdGVudCBzZWdtZW50c1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnN0b3AoeyByZWFzb246ICdzZW5kUmVwbGF5JyB9KTtcblxuICAgICAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG5cbiAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY29uc3QgZHJvcFJlYXNvbiA9IGVyciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yID8gJ3JhdGVsaW1pdF9iYWNrb2ZmJyA6ICdzZW5kX2Vycm9yJztcbiAgICAgICAgY2xpZW50LnJlY29yZERyb3BwZWRFdmVudChkcm9wUmVhc29uLCAncmVwbGF5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHJlY29yZGluZyBkYXRhIHRvIFNlbnRyeS4gQ3JlYXRlcyBhIGxvY2sgc28gdGhhdCBvbmx5IGEgc2luZ2xlIGZsdXNoXG4gICAqIGNhbiBiZSBhY3RpdmUgYXQgYSB0aW1lLiBEbyBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LlxuICAgKi9cbiAgIGFzeW5jIF9mbHVzaCh7XG4gICAgZm9yY2UgPSBmYWxzZSxcbiAgfVxuXG4gPSB7fSkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkICYmICFmb3JjZSkge1xuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGUuZy4gdGhlIHJlcGxheSB3YXMgc3RvcHBlZCBiZWNhdXNlIG9mIGV4Y2VlZGluZyB0aGUgcmV0cnkgbGltaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2hlY2tBbmRIYW5kbGVFeHBpcmVkU2Vzc2lvbigpKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5lcnJvcignQXR0ZW1wdGluZyB0byBmaW5pc2ggcmVwbGF5IGV2ZW50IGFmdGVyIHNlc3Npb24gZXhwaXJlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbiwgYXMgd2Ugd291bGQgaGF2ZSBiYWlsZWQgb3V0IGJlZm9yZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zZXNzaW9uLnN0YXJ0ZWQ7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0O1xuXG4gICAgLy8gQSBmbHVzaCBpcyBhYm91dCB0byBoYXBwZW4sIGNhbmNlbCBhbnkgcXVldWVkIGZsdXNoZXNcbiAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaC5jYW5jZWwoKTtcblxuICAgIC8vIElmIHNlc3Npb24gaXMgdG9vIHNob3J0LCBvciB0b28gbG9uZyAoYWxsb3cgc29tZSB3aWdnbGUgcm9vbSBvdmVyIG1heFJlcGxheUR1cmF0aW9uKSwgZG8gbm90IHNlbmQgaXRcbiAgICAvLyBUaGlzIF9zaG91bGRfIG5vdCBoYXBwZW4sIGJ1dCBpdCBtYXkgaGFwcGVuIGlmIGZsdXNoIGlzIHRyaWdnZXJlZCBkdWUgdG8gYSBwYWdlIGFjdGl2aXR5IGNoYW5nZSBvciBzaW1pbGFyXG4gICAgY29uc3QgdG9vU2hvcnQgPSBkdXJhdGlvbiA8IHRoaXMuX29wdGlvbnMubWluUmVwbGF5RHVyYXRpb247XG4gICAgY29uc3QgdG9vTG9uZyA9IGR1cmF0aW9uID4gdGhpcy5fb3B0aW9ucy5tYXhSZXBsYXlEdXJhdGlvbiArIDUwMDA7XG4gICAgaWYgKHRvb1Nob3J0IHx8IHRvb0xvbmcpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGRlYnVnLmxvZyhcbiAgICAgICAgICBgU2Vzc2lvbiBkdXJhdGlvbiAoJHtNYXRoLmZsb29yKGR1cmF0aW9uIC8gMTAwMCl9cykgaXMgdG9vICR7XG4gICAgICAgICAgICB0b29TaG9ydCA/ICdzaG9ydCcgOiAnbG9uZydcbiAgICAgICAgICB9LCBub3Qgc2VuZGluZyByZXBsYXkuYCxcbiAgICAgICAgKTtcblxuICAgICAgaWYgKHRvb1Nob3J0KSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlZEZsdXNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRCdWZmZXIgPSB0aGlzLmV2ZW50QnVmZmVyO1xuICAgIGlmIChldmVudEJ1ZmZlciAmJiB0aGlzLnNlc3Npb24uc2VnbWVudElkID09PSAwICYmICFldmVudEJ1ZmZlci5oYXNDaGVja291dCkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdGbHVzaGluZyBpbml0aWFsIHNlZ21lbnQgd2l0aG91dCBjaGVja291dC4nKTtcbiAgICAgIC8vIFRPRE8gRk46IEV2YWx1YXRlIGlmIHdlIHdhbnQgdG8gc3RvcCBoZXJlLCBvciByZW1vdmUgdGhpcyBhZ2Fpbj9cbiAgICB9XG5cbiAgICBjb25zdCBfZmx1c2hJblByb2dyZXNzID0gISF0aGlzLl9mbHVzaExvY2s7XG5cbiAgICAvLyB0aGlzLl9mbHVzaExvY2sgYWN0cyBhcyBhIGxvY2sgc28gdGhhdCBmdXR1cmUgY2FsbHMgdG8gYF9mbHVzaCgpYCB3aWxsXG4gICAgLy8gYmUgYmxvY2tlZCB1bnRpbCBjdXJyZW50IGZsdXNoIGlzIGZpbmlzaGVkIChpLmUuIHRoaXMgcHJvbWlzZSByZXNvbHZlcylcbiAgICBpZiAoIXRoaXMuX2ZsdXNoTG9jaykge1xuICAgICAgdGhpcy5fZmx1c2hMb2NrID0gdGhpcy5fcnVuRmx1c2goKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fZmx1c2hMb2NrO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFeGNlcHRpb24oZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZmx1c2hMb2NrID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoX2ZsdXNoSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXYWl0IGZvciBwcmV2aW91cyBmbHVzaCB0byBmaW5pc2gsIHRoZW4gY2FsbCB0aGUgZGVib3VuY2VkXG4gICAgICAgIC8vIGBfZmx1c2goKWAuIEl0J3MgcG9zc2libGUgdGhlcmUgYXJlIG90aGVyIGZsdXNoIHJlcXVlc3RzIHF1ZXVlZCBhbmRcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgaXQgdG8gcmVzb2x2ZS4gV2Ugd2FudCB0byByZWR1Y2UgYWxsIG91dHN0YW5kaW5nXG4gICAgICAgIC8vIHJlcXVlc3RzIChhcyB3ZWxsIGFzIGFueSBuZXcgZmx1c2ggcmVxdWVzdHMgdGhhdCBvY2N1ciB3aXRoaW4gYVxuICAgICAgICAvLyBzZWNvbmQgb2YgdGhlIGxvY2tlZCBmbHVzaCBjb21wbGV0aW5nKSBpbnRvIGEgc2luZ2xlIGZsdXNoLlxuICAgICAgICB0aGlzLl9kZWJvdW5jZWRGbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBTYXZlIHRoZSBzZXNzaW9uLCBpZiBpdCBpcyBzdGlja3kgKi9cbiAgIF9tYXliZVNhdmVTZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5fb3B0aW9ucy5zdGlja3lTZXNzaW9uKSB7XG4gICAgICBzYXZlU2Vzc2lvbih0aGlzLnNlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBIYW5kbGVyIGZvciBycndlYi5yZWNvcmQub25NdXRhdGlvbiAqL1xuICAgX29uTXV0YXRpb25IYW5kbGVyKG11dGF0aW9ucykge1xuICAgIGNvbnN0IHsgaWdub3JlTXV0YXRpb25zIH0gPSB0aGlzLl9vcHRpb25zLl9leHBlcmltZW50cztcbiAgICBpZiAoaWdub3JlTXV0YXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbXV0YXRpb25zLnNvbWUobXV0YXRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGVsID0gY2xvc2VzdEVsZW1lbnRPZk5vZGUobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGlnbm9yZU11dGF0aW9ucy5qb2luKCcsJyk7XG4gICAgICAgICAgcmV0dXJuIGVsPy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgfSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY291bnQgPSBtdXRhdGlvbnMubGVuZ3RoO1xuXG4gICAgY29uc3QgbXV0YXRpb25MaW1pdCA9IHRoaXMuX29wdGlvbnMubXV0YXRpb25MaW1pdDtcbiAgICBjb25zdCBtdXRhdGlvbkJyZWFkY3J1bWJMaW1pdCA9IHRoaXMuX29wdGlvbnMubXV0YXRpb25CcmVhZGNydW1iTGltaXQ7XG4gICAgY29uc3Qgb3Zlck11dGF0aW9uTGltaXQgPSBtdXRhdGlvbkxpbWl0ICYmIGNvdW50ID4gbXV0YXRpb25MaW1pdDtcblxuICAgIC8vIENyZWF0ZSBhIGJyZWFkY3J1bWIgaWYgYSBsb3Qgb2YgbXV0YXRpb25zIGhhcHBlbiBhdCB0aGUgc2FtZSB0aW1lXG4gICAgLy8gV2UgY2FuIHNob3cgdGhpcyBpbiB0aGUgVUkgYXMgYW4gaW5mb3JtYXRpb24gd2l0aCBwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzXG4gICAgaWYgKGNvdW50ID4gbXV0YXRpb25CcmVhZGNydW1iTGltaXQgfHwgb3Zlck11dGF0aW9uTGltaXQpIHtcbiAgICAgIGNvbnN0IGJyZWFkY3J1bWIgPSBjcmVhdGVCcmVhZGNydW1iKHtcbiAgICAgICAgY2F0ZWdvcnk6ICdyZXBsYXkubXV0YXRpb25zJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIGxpbWl0OiBvdmVyTXV0YXRpb25MaW1pdCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY3JlYXRlQ3VzdG9tQnJlYWRjcnVtYihicmVhZGNydW1iKTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHJlcGxheSBpZiBvdmVyIHRoZSBtdXRhdGlvbiBsaW1pdFxuICAgIGlmIChvdmVyTXV0YXRpb25MaW1pdCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgcmVqZWN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnN0b3AoeyByZWFzb246ICdtdXRhdGlvbkxpbWl0JywgZm9yY2VGbHVzaDogdGhpcy5yZWNvcmRpbmdNb2RlID09PSAnc2Vzc2lvbicgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYHRydWVgIG1lYW5zIHdlIHVzZSB0aGUgcmVndWxhciBtdXRhdGlvbiBoYW5kbGluZyBieSBycndlYlxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbihzZWxlY3RvcnMsIGRlZmF1bHRTZWxlY3RvcnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5zZWxlY3RvcnMsXG4gICAgLy8gc2VudHJ5IGRlZmF1bHRzXG4gICAgLi4uZGVmYXVsdFNlbGVjdG9ycyxcbiAgXS5qb2luKCcsJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBwcml2YWN5IHJlbGF0ZWQgY29uZmlndXJhdGlvbiBmb3IgdXNlIGluIHJyd2ViXG4gKi9cbmZ1bmN0aW9uIGdldFByaXZhY3lPcHRpb25zKHsgbWFzaywgdW5tYXNrLCBibG9jaywgdW5ibG9jaywgaWdub3JlIH0pIHtcbiAgY29uc3QgZGVmYXVsdEJsb2NrZWRFbGVtZW50cyA9IFsnYmFzZScsICdpZnJhbWVbc3JjZG9jXTpub3QoW3NyY10pJ107XG5cbiAgY29uc3QgbWFza1NlbGVjdG9yID0gZ2V0T3B0aW9uKG1hc2ssIFsnLnNlbnRyeS1tYXNrJywgJ1tkYXRhLXNlbnRyeS1tYXNrXSddKTtcbiAgY29uc3QgdW5tYXNrU2VsZWN0b3IgPSBnZXRPcHRpb24odW5tYXNrLCBbXSk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAvLyBXZSBhcmUgbWFraW5nIHRoZSBkZWNpc2lvbiB0byBtYWtlIHRleHQgYW5kIGlucHV0IHNlbGVjdG9ycyB0aGUgc2FtZVxuICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tTZWxlY3RvcixcbiAgICB1bm1hc2tUZXh0U2VsZWN0b3I6IHVubWFza1NlbGVjdG9yLFxuXG4gICAgYmxvY2tTZWxlY3RvcjogZ2V0T3B0aW9uKGJsb2NrLCBbJy5zZW50cnktYmxvY2snLCAnW2RhdGEtc2VudHJ5LWJsb2NrXScsIC4uLmRlZmF1bHRCbG9ja2VkRWxlbWVudHNdKSxcbiAgICB1bmJsb2NrU2VsZWN0b3I6IGdldE9wdGlvbih1bmJsb2NrLCBbXSksXG4gICAgaWdub3JlU2VsZWN0b3I6IGdldE9wdGlvbihpZ25vcmUsIFsnLnNlbnRyeS1pZ25vcmUnLCAnW2RhdGEtc2VudHJ5LWlnbm9yZV0nLCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nXSksXG4gIH07XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogTWFza3MgYW4gYXR0cmlidXRlIGlmIG5lY2Vzc2FyeSwgb3RoZXJ3aXNlIHJldHVybiBhdHRyaWJ1dGUgdmFsdWUgYXMtaXMuXG4gKi9cbmZ1bmN0aW9uIG1hc2tBdHRyaWJ1dGUoe1xuICBlbCxcbiAga2V5LFxuICBtYXNrQXR0cmlidXRlcyxcbiAgbWFza0FsbFRleHQsXG4gIHByaXZhY3lPcHRpb25zLFxuICB2YWx1ZSxcbn0pIHtcbiAgLy8gV2Ugb25seSBtYXNrIGF0dHJpYnV0ZXMgaWYgYG1hc2tBbGxUZXh0YCBpcyB0cnVlXG4gIGlmICghbWFza0FsbFRleHQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyB1bm1hc2tUZXh0U2VsZWN0b3IgdGFrZXMgcHJlY2VkZW5jZVxuICBpZiAocHJpdmFjeU9wdGlvbnMudW5tYXNrVGV4dFNlbGVjdG9yICYmIGVsLm1hdGNoZXMocHJpdmFjeU9wdGlvbnMudW5tYXNrVGV4dFNlbGVjdG9yKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICBtYXNrQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgLy8gTmVlZCB0byBtYXNrIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBgPGlucHV0PmAgaWYgaXQncyBhIGJ1dHRvbi1saWtlXG4gICAgLy8gdHlwZVxuICAgIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBbJ3N1Ym1pdCcsICdidXR0b24nXS5pbmNsdWRlcyhlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSB8fCAnJykpXG4gICkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCBNRURJQV9TRUxFQ1RPUlMgPVxuICAnaW1nLGltYWdlLHN2Zyx2aWRlbyxvYmplY3QscGljdHVyZSxlbWJlZCxtYXAsYXVkaW8sbGlua1tyZWw9XCJpY29uXCJdLGxpbmtbcmVsPVwiYXBwbGUtdG91Y2gtaWNvblwiXSc7XG5cbmNvbnN0IERFRkFVTFRfTkVUV09SS19IRUFERVJTID0gWydjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnYWNjZXB0J107XG5cbmxldCBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBTZW50cnkgaW50ZWdyYXRpb24gZm9yIFtTZXNzaW9uIFJlcGxheV0oaHR0cHM6Ly9zZW50cnkuaW8vZm9yL3Nlc3Npb24tcmVwbGF5LykuXG4gKlxuICogU2VlIHRoZSBbUmVwbGF5IGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5zZW50cnkuaW8vcGxhdGZvcm1zL2phdmFzY3JpcHQvZ3VpZGVzL3Nlc3Npb24tcmVwbGF5LykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIFNlbnRyeS5pbml0KHtcbiAqICAgZHNuOiAnX19EU05fXycsXG4gKiAgIGludGVncmF0aW9uczogW1NlbnRyeS5yZXBsYXlJbnRlZ3JhdGlvbigpXSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNvbnN0IHJlcGxheUludGVncmF0aW9uID0gKChvcHRpb25zKSA9PiB7XG4gIHJldHVybiBuZXcgUmVwbGF5KG9wdGlvbnMpO1xufSkgO1xuXG4vKipcbiAqIFJlcGxheSBpbnRlZ3JhdGlvblxuICovXG5jbGFzcyBSZXBsYXkgIHtcbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIHBhc3MgdG8gYHJyd2ViLnJlY29yZCgpYFxuICAgKi9cblxuICAvKipcbiAgICogSW5pdGlhbCBvcHRpb25zIHBhc3NlZCB0byB0aGUgcmVwbGF5IGludGVncmF0aW9uLCBtZXJnZWQgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICogTm90ZTogYHNlc3Npb25TYW1wbGVSYXRlYCBhbmQgYGVycm9yU2FtcGxlUmF0ZWAgYXJlIG5vdCByZXF1aXJlZCBoZXJlLCBhcyB0aGV5XG4gICAqIGNhbiBvbmx5IGJlIGZpbmFsbHkgc2V0IHdoZW4gc2V0dXBPbmNlKCkgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICAgY29uc3RydWN0b3Ioe1xuICAgIGZsdXNoTWluRGVsYXkgPSBERUZBVUxUX0ZMVVNIX01JTl9ERUxBWSxcbiAgICBmbHVzaE1heERlbGF5ID0gREVGQVVMVF9GTFVTSF9NQVhfREVMQVksXG4gICAgbWluUmVwbGF5RHVyYXRpb24gPSBNSU5fUkVQTEFZX0RVUkFUSU9OLFxuICAgIG1heFJlcGxheUR1cmF0aW9uID0gTUFYX1JFUExBWV9EVVJBVElPTixcbiAgICBzdGlja3lTZXNzaW9uID0gdHJ1ZSxcbiAgICB1c2VDb21wcmVzc2lvbiA9IHRydWUsXG4gICAgd29ya2VyVXJsLFxuICAgIF9leHBlcmltZW50cyA9IHt9LFxuICAgIG1hc2tBbGxUZXh0ID0gdHJ1ZSxcbiAgICBtYXNrQWxsSW5wdXRzID0gdHJ1ZSxcbiAgICBibG9ja0FsbE1lZGlhID0gdHJ1ZSxcblxuICAgIG11dGF0aW9uQnJlYWRjcnVtYkxpbWl0ID0gNzUwLFxuICAgIG11dGF0aW9uTGltaXQgPSAxMDAwMCxcblxuICAgIHNsb3dDbGlja1RpbWVvdXQgPSA3MDAwLFxuICAgIHNsb3dDbGlja0lnbm9yZVNlbGVjdG9ycyA9IFtdLFxuXG4gICAgbmV0d29ya0RldGFpbEFsbG93VXJscyA9IFtdLFxuICAgIG5ldHdvcmtEZXRhaWxEZW55VXJscyA9IFtdLFxuICAgIG5ldHdvcmtDYXB0dXJlQm9kaWVzID0gdHJ1ZSxcbiAgICBuZXR3b3JrUmVxdWVzdEhlYWRlcnMgPSBbXSxcbiAgICBuZXR3b3JrUmVzcG9uc2VIZWFkZXJzID0gW10sXG5cbiAgICBtYXNrID0gW10sXG4gICAgbWFza0F0dHJpYnV0ZXMgPSBbJ3RpdGxlJywgJ3BsYWNlaG9sZGVyJywgJ2FyaWEtbGFiZWwnXSxcbiAgICB1bm1hc2sgPSBbXSxcbiAgICBibG9jayA9IFtdLFxuICAgIHVuYmxvY2sgPSBbXSxcbiAgICBpZ25vcmUgPSBbXSxcbiAgICBtYXNrRm4sXG5cbiAgICBiZWZvcmVBZGRSZWNvcmRpbmdFdmVudCxcbiAgICBiZWZvcmVFcnJvclNhbXBsaW5nLFxuICAgIG9uRXJyb3IsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9ICdSZXBsYXknO1xuXG4gICAgY29uc3QgcHJpdmFjeU9wdGlvbnMgPSBnZXRQcml2YWN5T3B0aW9ucyh7XG4gICAgICBtYXNrLFxuICAgICAgdW5tYXNrLFxuICAgICAgYmxvY2ssXG4gICAgICB1bmJsb2NrLFxuICAgICAgaWdub3JlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVjb3JkaW5nT3B0aW9ucyA9IHtcbiAgICAgIG1hc2tBbGxJbnB1dHMsXG4gICAgICBtYXNrQWxsVGV4dCxcbiAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHsgcGFzc3dvcmQ6IHRydWUgfSxcbiAgICAgIG1hc2tUZXh0Rm46IG1hc2tGbixcbiAgICAgIG1hc2tJbnB1dEZuOiBtYXNrRm4sXG4gICAgICBtYXNrQXR0cmlidXRlRm46IChrZXksIHZhbHVlLCBlbCkgPT5cbiAgICAgICAgbWFza0F0dHJpYnV0ZSh7XG4gICAgICAgICAgbWFza0F0dHJpYnV0ZXMsXG4gICAgICAgICAgbWFza0FsbFRleHQsXG4gICAgICAgICAgcHJpdmFjeU9wdGlvbnMsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGVsLFxuICAgICAgICB9KSxcblxuICAgICAgLi4ucHJpdmFjeU9wdGlvbnMsXG5cbiAgICAgIC8vIE91ciBkZWZhdWx0c1xuICAgICAgc2xpbURPTU9wdGlvbnM6ICdhbGwnLFxuICAgICAgaW5saW5lU3R5bGVzaGVldDogdHJ1ZSxcbiAgICAgIC8vIERpc2FibGUgaW5saW5lIGltYWdlcyBhcyBpdCB3aWxsIGluY3JlYXNlIHNlZ21lbnQvcmVwbGF5IHNpemVcbiAgICAgIGlubGluZUltYWdlczogZmFsc2UsXG4gICAgICAvLyBjb2xsZWN0IGZvbnRzLCBidXQgYmUgYXdhcmUgdGhhdCBgc2VudHJ5LmlvYCBuZWVkcyB0byBiZSBhbiBhbGxvd2VkXG4gICAgICAvLyBvcmlnaW4gZm9yIHBsYXliYWNrXG4gICAgICBjb2xsZWN0Rm9udHM6IHRydWUsXG4gICAgICBlcnJvckhhbmRsZXI6IChlcnIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlcnIuX19ycndlYl9fID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBoZXJlXG4gICAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBlcnJvciBpcyBmcm96ZW4gb3IgZG9lcyBub3QgYWxsb3cgbXV0YXRpb24gZm9yIG90aGVyIHJlYXNvbnNcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGV4cGVyaW1lbnRhbCBzdXBwb3J0IGZvciByZWNvcmRpbmcgaWZyYW1lcyBmcm9tIGRpZmZlcmVudCBvcmlnaW5zXG4gICAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXM6IEJvb2xlYW4oX2V4cGVyaW1lbnRzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyksXG4gICAgfTtcblxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0ge1xuICAgICAgZmx1c2hNaW5EZWxheSxcbiAgICAgIGZsdXNoTWF4RGVsYXksXG4gICAgICBtaW5SZXBsYXlEdXJhdGlvbjogTWF0aC5taW4obWluUmVwbGF5RHVyYXRpb24sIE1JTl9SRVBMQVlfRFVSQVRJT05fTElNSVQpLFxuICAgICAgbWF4UmVwbGF5RHVyYXRpb246IE1hdGgubWluKG1heFJlcGxheUR1cmF0aW9uLCBNQVhfUkVQTEFZX0RVUkFUSU9OKSxcbiAgICAgIHN0aWNreVNlc3Npb24sXG4gICAgICB1c2VDb21wcmVzc2lvbixcbiAgICAgIHdvcmtlclVybCxcbiAgICAgIGJsb2NrQWxsTWVkaWEsXG4gICAgICBtYXNrQWxsSW5wdXRzLFxuICAgICAgbWFza0FsbFRleHQsXG4gICAgICBtdXRhdGlvbkJyZWFkY3J1bWJMaW1pdCxcbiAgICAgIG11dGF0aW9uTGltaXQsXG4gICAgICBzbG93Q2xpY2tUaW1lb3V0LFxuICAgICAgc2xvd0NsaWNrSWdub3JlU2VsZWN0b3JzLFxuICAgICAgbmV0d29ya0RldGFpbEFsbG93VXJscyxcbiAgICAgIG5ldHdvcmtEZXRhaWxEZW55VXJscyxcbiAgICAgIG5ldHdvcmtDYXB0dXJlQm9kaWVzLFxuICAgICAgbmV0d29ya1JlcXVlc3RIZWFkZXJzOiBfZ2V0TWVyZ2VkTmV0d29ya0hlYWRlcnMobmV0d29ya1JlcXVlc3RIZWFkZXJzKSxcbiAgICAgIG5ldHdvcmtSZXNwb25zZUhlYWRlcnM6IF9nZXRNZXJnZWROZXR3b3JrSGVhZGVycyhuZXR3b3JrUmVzcG9uc2VIZWFkZXJzKSxcbiAgICAgIGJlZm9yZUFkZFJlY29yZGluZ0V2ZW50LFxuICAgICAgYmVmb3JlRXJyb3JTYW1wbGluZyxcbiAgICAgIG9uRXJyb3IsXG5cbiAgICAgIF9leHBlcmltZW50cyxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zLmJsb2NrQWxsTWVkaWEpIHtcbiAgICAgIC8vIGBibG9ja0FsbE1lZGlhYCBpcyBhIG1vcmUgdXNlciBmcmllbmRseSBvcHRpb24gdG8gY29uZmlndXJlIGJsb2NraW5nXG4gICAgICAvLyBlbWJlZGRlZCBtZWRpYSBlbGVtZW50c1xuICAgICAgdGhpcy5fcmVjb3JkaW5nT3B0aW9ucy5ibG9ja1NlbGVjdG9yID0gIXRoaXMuX3JlY29yZGluZ09wdGlvbnMuYmxvY2tTZWxlY3RvclxuICAgICAgICA/IE1FRElBX1NFTEVDVE9SU1xuICAgICAgICA6IGAke3RoaXMuX3JlY29yZGluZ09wdGlvbnMuYmxvY2tTZWxlY3Rvcn0sJHtNRURJQV9TRUxFQ1RPUlN9YDtcbiAgICAgIHRoaXMuX3JlY29yZGluZ09wdGlvbnMuaWdub3JlQ1NTQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kLWltYWdlJ10pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIFNlbnRyeSBTZXNzaW9uIFJlcGxheSBpbnN0YW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBJZiByZXBsYXkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZCAqL1xuICAgZ2V0IF9pc0luaXRpYWxpemVkKCkge1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZWQ7XG4gIH1cblxuICAvKiogVXBkYXRlIF9pc0luaXRpYWxpemVkICovXG4gICBzZXQgX2lzSW5pdGlhbGl6ZWQodmFsdWUpIHtcbiAgICBfaW5pdGlhbGl6ZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbmQgaW5pdGlhbGl6ZSByZXBsYXkgY29udGFpbmVyXG4gICAqL1xuICAgYWZ0ZXJBbGxTZXR1cChjbGllbnQpIHtcbiAgICBpZiAoIWlzQnJvd3NlcigpIHx8IHRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHVwKGNsaWVudCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZShjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgcmVwbGF5IHJlZ2FyZGxlc3Mgb2Ygc2FtcGxpbmcgcmF0ZS4gQ2FsbGluZyB0aGlzIHdpbGwgYWx3YXlzXG4gICAqIGNyZWF0ZSBhIG5ldyBzZXNzaW9uLiBXaWxsIGxvZyBhIG1lc3NhZ2UgaWYgcmVwbGF5IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXG4gICAqXG4gICAqIENyZWF0ZXMgb3IgbG9hZHMgYSBzZXNzaW9uLCBhdHRhY2hlcyBsaXN0ZW5lcnMgdG8gdmFyeWluZyBldmVudHMgKERPTSxcbiAgICogUGVyZm9ybWFuY2VPYnNlcnZlciwgUmVjb3JkaW5nLCBTZW50cnkgU0RLLCBldGMpXG4gICAqL1xuICAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXBsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVwbGF5LnN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcmVwbGF5IGJ1ZmZlcmluZy4gQnVmZmVycyB1bnRpbCBgZmx1c2goKWAgaXMgY2FsbGVkIG9yLCBpZlxuICAgKiBgcmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlYCA+IDAsIHVudGlsIGFuIGVycm9yIG9jY3Vycy5cbiAgICovXG4gICBzdGFydEJ1ZmZlcmluZygpIHtcbiAgICBpZiAoIXRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcGxheS5zdGFydEJ1ZmZlcmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSwgdGhpcyBuZWVkcyB0byBiZSBtYW51YWxseSBjYWxsZWQgKGUuZy4gZm9yIHRlc3RzKS4gU2VudHJ5IFNES1xuICAgKiBkb2VzIG5vdCBzdXBwb3J0IGEgdGVhcmRvd25cbiAgICovXG4gICBzdG9wKCkge1xuICAgIGlmICghdGhpcy5fcmVwbGF5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGxheS5zdG9wKHsgZm9yY2VGbHVzaDogdGhpcy5fcmVwbGF5LnJlY29yZGluZ01vZGUgPT09ICdzZXNzaW9uJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBub3QgaW4gXCJzZXNzaW9uXCIgcmVjb3JkaW5nIG1vZGUsIGZsdXNoIGV2ZW50IGJ1ZmZlciB3aGljaCB3aWxsIGNyZWF0ZSBhIG5ldyByZXBsYXkuXG4gICAqIElmIHJlcGxheSBpcyBub3QgZW5hYmxlZCwgYSBuZXcgc2Vzc2lvbiByZXBsYXkgaXMgc3RhcnRlZC5cbiAgICogVW5sZXNzIGBjb250aW51ZVJlY29yZGluZ2AgaXMgZmFsc2UsIHRoZSByZXBsYXkgd2lsbCBjb250aW51ZSB0byByZWNvcmQgYW5kXG4gICAqIGJlaGF2ZSBhcyBhIFwic2Vzc2lvblwiLWJhc2VkIHJlcGxheS5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBxdWV1ZSB1cCBhIGZsdXNoLlxuICAgKi9cbiAgIGZsdXNoKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX3JlcGxheSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtaW5nIGEgc2Vzc2lvbiBzaG91bGQgYmUgcmVjb3JkZWQgaW4gdGhpcyBjYXNlXG4gICAgaWYgKCF0aGlzLl9yZXBsYXkuaXNFbmFibGVkKCkpIHtcbiAgICAgIHRoaXMuX3JlcGxheS5zdGFydCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBsYXkuc2VuZEJ1ZmZlcmVkUmVwbGF5T3JGbHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiBJRC5cbiAgICpcbiAgICogQHBhcmFtIG9ubHlJZlNhbXBsZWQgLSBJZiB0cnVlLCB3aWxsIG9ubHkgcmV0dXJuIHRoZSBzZXNzaW9uIElEIGlmIHRoZSBzZXNzaW9uIGlzIHNhbXBsZWQuXG4gICAqXG4gICAqL1xuICAgZ2V0UmVwbGF5SWQob25seUlmU2FtcGxlZCkge1xuICAgIGlmICghdGhpcy5fcmVwbGF5Py5pc0VuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBsYXkuZ2V0U2Vzc2lvbklkKG9ubHlJZlNhbXBsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByZWNvcmRpbmcgbW9kZS4gVGhpcyBjYW4gYmUgZWl0aGVyIGBzZXNzaW9uYCBvciBgYnVmZmVyYC5cbiAgICpcbiAgICogYHNlc3Npb25gOiBSZWNvcmRpbmcgdGhlIHdob2xlIHNlc3Npb24sIHNlbmRpbmcgaXQgY29udGludW91c2x5XG4gICAqIGBidWZmZXJgOiBBbHdheXMga2VlcGluZyB0aGUgbGFzdCA2MHMgb2YgcmVjb3JkaW5nLCByZXF1aXJlczpcbiAgICogICAtIGhhdmluZyByZXBsYXlzT25FcnJvclNhbXBsZVJhdGUgPiAwIHRvIGNhcHR1cmUgcmVwbGF5IHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAqICAgLSBvciBjYWxsaW5nIGBmbHVzaCgpYCB0byBzZW5kIHRoZSByZXBsYXlcbiAgICovXG4gICBnZXRSZWNvcmRpbmdNb2RlKCkge1xuICAgIGlmICghdGhpcy5fcmVwbGF5Py5pc0VuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBsYXkucmVjb3JkaW5nTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyByZXBsYXkuXG4gICAqL1xuICAgX2luaXRpYWxpemUoY2xpZW50KSB7XG4gICAgaWYgKCF0aGlzLl9yZXBsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXliZUxvYWRGcm9tUmVwbGF5Q2FudmFzSW50ZWdyYXRpb24oY2xpZW50KTtcbiAgICB0aGlzLl9yZXBsYXkuaW5pdGlhbGl6ZVNhbXBsaW5nKCk7XG4gIH1cblxuICAvKiogU2V0dXAgdGhlIGludGVncmF0aW9uLiAqL1xuICAgX3NldHVwKGNsaWVudCkge1xuICAgIC8vIENsaWVudCBpcyBub3QgYXZhaWxhYmxlIGluIGNvbnN0cnVjdG9yLCBzbyB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgc2V0dXBPbmNlXG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gbG9hZFJlcGxheU9wdGlvbnNGcm9tQ2xpZW50KHRoaXMuX2luaXRpYWxPcHRpb25zLCBjbGllbnQpO1xuXG4gICAgdGhpcy5fcmVwbGF5ID0gbmV3IFJlcGxheUNvbnRhaW5lcih7XG4gICAgICBvcHRpb25zOiBmaW5hbE9wdGlvbnMsXG4gICAgICByZWNvcmRpbmdPcHRpb25zOiB0aGlzLl9yZWNvcmRpbmdPcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEdldCBjYW52YXMgb3B0aW9ucyBmcm9tIFJlcGxheUNhbnZhcyBpbnRlZ3JhdGlvbiwgaWYgaXQgaXMgYWxzbyBhZGRlZC4gKi9cbiAgIF9tYXliZUxvYWRGcm9tUmVwbGF5Q2FudmFzSW50ZWdyYXRpb24oY2xpZW50KSB7XG4gICAgLy8gVG8gc2F2ZSBidW5kbGUgc2l6ZSwgd2Ugc2tpcCBjaGVja2luZyBmb3Igc3R1ZmYgaGVyZVxuICAgIC8vIGFuZCBpbnN0ZWFkIGp1c3QgdHJ5LWNhdGNoIGV2ZXJ5dGhpbmcgLSBhcyBnZW5lcmFsbHkgdGhpcyBzaG91bGQgYWxsIGJlIGRlZmluZWRcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhc0ludGVncmF0aW9uID0gY2xpZW50LmdldEludGVncmF0aW9uQnlOYW1lKCdSZXBsYXlDYW52YXMnKVxuXG47XG4gICAgICBpZiAoIWNhbnZhc0ludGVncmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGF5WydfY2FudmFzJ10gPSBjYW52YXNJbnRlZ3JhdGlvbi5nZXRPcHRpb25zKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzIGhlcmVcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gIH1cbn1cblxuLyoqIFBhcnNlIFJlcGxheS1yZWxhdGVkIG9wdGlvbnMgZnJvbSBTREsgb3B0aW9ucyAqL1xuZnVuY3Rpb24gbG9hZFJlcGxheU9wdGlvbnNGcm9tQ2xpZW50KGluaXRpYWxPcHRpb25zLCBjbGllbnQpIHtcbiAgY29uc3Qgb3B0ID0gY2xpZW50LmdldE9wdGlvbnMoKSA7XG5cbiAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgIHNlc3Npb25TYW1wbGVSYXRlOiAwLFxuICAgIGVycm9yU2FtcGxlUmF0ZTogMCxcbiAgICAuLi5pbml0aWFsT3B0aW9ucyxcbiAgfTtcblxuICBjb25zdCByZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUgPSBwYXJzZVNhbXBsZVJhdGUob3B0LnJlcGxheXNTZXNzaW9uU2FtcGxlUmF0ZSk7XG4gIGNvbnN0IHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZSA9IHBhcnNlU2FtcGxlUmF0ZShvcHQucmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlKTtcblxuICBpZiAocmVwbGF5c1Nlc3Npb25TYW1wbGVSYXRlID09IG51bGwgJiYgcmVwbGF5c09uRXJyb3JTYW1wbGVSYXRlID09IG51bGwpIHtcbiAgICBjb25zb2xlU2FuZGJveCgoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnUmVwbGF5IGlzIGRpc2FibGVkIGJlY2F1c2UgbmVpdGhlciBgcmVwbGF5c1Nlc3Npb25TYW1wbGVSYXRlYCBub3IgYHJlcGxheXNPbkVycm9yU2FtcGxlUmF0ZWAgYXJlIHNldC4nLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUgIT0gbnVsbCkge1xuICAgIGZpbmFsT3B0aW9ucy5zZXNzaW9uU2FtcGxlUmF0ZSA9IHJlcGxheXNTZXNzaW9uU2FtcGxlUmF0ZTtcbiAgfVxuXG4gIGlmIChyZXBsYXlzT25FcnJvclNhbXBsZVJhdGUgIT0gbnVsbCkge1xuICAgIGZpbmFsT3B0aW9ucy5lcnJvclNhbXBsZVJhdGUgPSByZXBsYXlzT25FcnJvclNhbXBsZVJhdGU7XG4gIH1cblxuICByZXR1cm4gZmluYWxPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBfZ2V0TWVyZ2VkTmV0d29ya0hlYWRlcnMoaGVhZGVycykge1xuICByZXR1cm4gWy4uLkRFRkFVTFRfTkVUV09SS19IRUFERVJTLCAuLi5oZWFkZXJzLm1hcChoZWFkZXIgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpXTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgc21hbGwgdXRpbGl0eSB0byBnZXQgYSB0eXBlLXNhZmUgaW5zdGFuY2Ugb2YgdGhlIFJlcGxheSBpbnRlZ3JhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVwbGF5KCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgcmV0dXJuIGNsaWVudD8uZ2V0SW50ZWdyYXRpb25CeU5hbWUoJ1JlcGxheScpO1xufVxuXG5leHBvcnQgeyBnZXRSZXBsYXksIHJlcGxheUludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@sentry-internal+replay@10.25.0/node_modules/@sentry-internal/replay/build/npm/esm/index.js\n");

/***/ })

};
;