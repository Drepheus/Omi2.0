"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry-internal+replay-canvas@10.25.0";
exports.ids = ["vendor-chunks/@sentry-internal+replay-canvas@10.25.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@sentry-internal+replay-canvas@10.25.0/node_modules/@sentry-internal/replay-canvas/build/npm/esm/index.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry-internal+replay-canvas@10.25.0/node_modules/@sentry-internal/replay-canvas/build/npm/esm/index.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   replayCanvasIntegration: () => (/* binding */ replayCanvasIntegration)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@10.25.0/node_modules/@sentry/core/build/esm/integration.js\");\n\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) ;\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n  for (i2 = 0; i2 < len; i2 += 3) {\n    base64 += chars[bytes[i2] >> 2];\n    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n    base64 += chars[bytes[i2 + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nconst canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n  let contextMap = canvasVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    canvasVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx) => {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\"))\n    return;\n  const name = value.constructor.name;\n  const list = variableListFor$1(ctx, name);\n  let index = list.indexOf(value);\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\nfunction serializeArg(value, win, ctx) {\n  if (value instanceof Array) {\n    return value.map((arg) => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)]\n    };\n  } else if (\n    // SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    value instanceof ArrayBuffer\n  ) {\n    const name = value.constructor.name;\n    const base64 = encode(value);\n    return {\n      rr_type: name,\n      base64\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [\n        serializeArg(value.buffer, win, ctx),\n        value.byteOffset,\n        value.byteLength\n      ]\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const { src } = value;\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof HTMLCanvasElement) {\n    const name = \"HTMLImageElement\";\n    const src = value.toDataURL();\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height]\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx);\n    return {\n      rr_type: name,\n      index\n    };\n  }\n  return value;\n}\nconst serializeArgs = (args, win, ctx) => {\n  return args.map((arg) => serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win) => {\n  const webGLConstructorNames = [\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLFramebuffer\",\n    \"WebGLProgram\",\n    \"WebGLRenderbuffer\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLTexture\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArrayObject\",\n    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n    \"WebGLVertexArrayObjectOES\"\n  ];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(\n    (name) => typeof win[name] === \"function\"\n  );\n  return Boolean(\n    supportedWebGLConstructorNames.find(\n      (name) => value instanceof win[name]\n    )\n  );\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector) {\n  const handlers = [];\n  const props2D = Object.getOwnPropertyNames(\n    win.CanvasRenderingContext2D.prototype\n  );\n  for (const prop of props2D) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            if (!isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              setTimeout$1(() => {\n                const recordArgs = serializeArgs(args, win, this);\n                cb(this.canvas, {\n                  type: CanvasContext[\"2D\"],\n                  property: prop,\n                  args: recordArgs\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v2) {\n            cb(this.canvas, {\n              type: CanvasContext[\"2D\"],\n              property: prop,\n              args: [v2],\n              setter: true\n            });\n          }\n        }\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction getNormalizedContextName(contextType) {\n  return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\n  const handlers = [];\n  try {\n    const restoreHandler = patch(\n      win.HTMLCanvasElement.prototype,\n      \"getContext\",\n      function(original) {\n        return function(contextType, ...args) {\n          if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\n            const ctxName = getNormalizedContextName(contextType);\n            if (!(\"__context\" in this)) this.__context = ctxName;\n            if (setPreserveDrawingBufferToTrue && [\"webgl\", \"webgl2\"].includes(ctxName)) {\n              if (args[0] && typeof args[0] === \"object\") {\n                const contextAttributes = args[0];\n                if (!contextAttributes.preserveDrawingBuffer) {\n                  contextAttributes.preserveDrawingBuffer = true;\n                }\n              } else {\n                args.splice(0, 1, {\n                  preserveDrawingBuffer: true\n                });\n              }\n            }\n          }\n          return original.apply(this, [contextType, ...args]);\n        };\n      }\n    );\n    handlers.push(restoreHandler);\n  } catch {\n    console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass2, blockSelector, unblockSelector, _mirror2, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (\n      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n      [\n        \"isContextLost\",\n        \"canvas\",\n        \"drawingBufferWidth\",\n        \"drawingBufferHeight\"\n      ].includes(prop)\n    ) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            const result = original.apply(this, args);\n            saveWebGLVar(result, win, this);\n            if (\"tagName\" in this.canvas && !isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              const recordArgs = serializeArgs(args, win, this);\n              const mutation = {\n                type,\n                property: prop,\n                args: recordArgs\n              };\n              cb(this.canvas, mutation);\n            }\n            return result;\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v2) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v2],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector, mirror2) {\n  const handlers = [];\n  handlers.push(\n    ...patchGLPrototype(\n      win.WebGLRenderingContext.prototype,\n      CanvasContext.WebGL,\n      cb,\n      blockClass2,\n      blockSelector,\n      unblockSelector,\n      mirror2,\n      win\n    )\n  );\n  if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n    handlers.push(\n      ...patchGLPrototype(\n        win.WebGL2RenderingContext.prototype,\n        CanvasContext.WebGL2,\n        cb,\n        blockClass2,\n        blockSelector,\n        unblockSelector,\n        mirror2,\n        win\n      )\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nconst r$1 = `for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",t=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s=\"\";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+\"=\":r%3==1&&(s=s.substring(0,s.length-2)+\"==\"),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+\"-\"+t;if(\"OffscreenCanvas\"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext(\"2d\");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return\"\"}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext(\"bitmaprenderer\"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:\"low\"});w?.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};`;\nfunction t$1() {\n  const t2 = new Blob([r$1]);\n  return URL.createObjectURL(t2);\n}\nclass CanvasManager {\n  constructor(options) {\n    this.pendingCanvasMutations = /* @__PURE__ */ new Map();\n    this.rafStamps = { latestId: 0, invokeId: null };\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.restoreHandlers = [];\n    this.frozen = false;\n    this.locked = false;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n    this.worker = null;\n    this.lastSnapshotTime = 0;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId)\n        this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      enableManualSnapshot,\n      sampling = \"all\",\n      win,\n      recordCanvas,\n      errorHandler: errorHandler2\n    } = options;\n    options.sampling = sampling;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    this.options = options;\n    if (errorHandler2) {\n      registerErrorHandler(errorHandler2);\n    }\n    if (recordCanvas && typeof sampling === \"number\" || enableManualSnapshot) {\n      this.worker = this.initFPSWorker();\n    }\n    this.addWindow(win);\n    if (enableManualSnapshot) {\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        this.initCanvasFPSObserver();\n      }\n    })();\n  }\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.worker?.terminate();\n    this.worker = null;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  addWindow(win) {\n    const {\n      sampling = \"all\",\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      recordCanvas,\n      enableManualSnapshot\n    } = this.options;\n    if (this.windowsSet.has(win)) return;\n    if (enableManualSnapshot) {\n      this.windowsSet.add(win);\n      this.windows.push(new WeakRef(win));\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.initCanvasMutationObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector\n        );\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        const canvasContextReset = initCanvasContextObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        );\n        this.restoreHandlers.push(() => {\n          canvasContextReset();\n        });\n      }\n    })();\n    this.windowsSet.add(win);\n    this.windows.push(new WeakRef(win));\n  }\n  addShadowRoot(shadowRoot) {\n    this.shadowDoms.add(new WeakRef(shadowRoot));\n  }\n  resetShadowRoots() {\n    this.shadowDoms = /* @__PURE__ */ new Set();\n  }\n  snapshot(canvasElement, options) {\n    if (options?.skipRequestAnimationFrame) {\n      this.takeSnapshot(performance.now(), true, canvasElement);\n      return;\n    }\n    onRequestAnimationFrame(\n      (timestamp) => this.takeSnapshot(timestamp, true, canvasElement)\n    );\n  }\n  initFPSWorker() {\n    const worker = new Worker(t$1());\n    worker.onmessage = (e2) => {\n      const data = e2.data;\n      const { id } = data;\n      this.snapshotInProgressMap.set(id, false);\n      if (!(\"base64\" in data)) return;\n      const { base64, type, width, height } = data;\n      this.mutationCb({\n        id,\n        type: CanvasContext[\"2D\"],\n        commands: [\n          {\n            property: \"clearRect\",\n            // wipe canvas\n            args: [0, 0, width, height]\n          },\n          {\n            property: \"drawImage\",\n            // draws (semi-transparent) image\n            args: [\n              {\n                rr_type: \"ImageBitmap\",\n                args: [\n                  {\n                    rr_type: \"Blob\",\n                    data: [{ rr_type: \"ArrayBuffer\", base64 }],\n                    type\n                  }\n                ]\n              },\n              0,\n              0,\n              // The below args are needed if we enforce a max size, we want to\n              // retain the original size when drawing the image (which should be smaller)\n              width,\n              height\n            ]\n          }\n        ]\n      });\n    };\n    return worker;\n  }\n  initCanvasFPSObserver() {\n    let rafId;\n    if (!this.windows.length && !this.shadowDoms.size) {\n      return;\n    }\n    const rafCallback = (timestamp) => {\n      this.takeSnapshot(timestamp, false);\n      rafId = onRequestAnimationFrame(rafCallback);\n    };\n    rafId = onRequestAnimationFrame(rafCallback);\n    this.restoreHandlers.push(() => {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n      }\n    });\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\n    const canvasContextReset = initCanvasContextObserver(\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      false\n    );\n    const canvas2DReset = initCanvas2DMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector\n    );\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      this.mirror\n    );\n    this.restoreHandlers.push(() => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    });\n  }\n  /**\n   * Returns all `canvas` elements that are not blocked by the given selectors. Searches all windows and shadow roots.\n   */\n  getCanvasElements(blockClass, blockSelector, unblockSelector) {\n    const matchedCanvas = [];\n    const searchCanvas = (root) => {\n      root.querySelectorAll(\"canvas\").forEach((canvas) => {\n        if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\n          matchedCanvas.push(canvas);\n        }\n      });\n    };\n    for (const item of this.windows) {\n      const window2 = item.deref();\n      let _document;\n      try {\n        _document = window2 && window2.document;\n      } catch {\n      }\n      if (_document) {\n        searchCanvas(_document);\n      }\n    }\n    for (const item of this.shadowDoms) {\n      const shadowRoot = item.deref();\n      if (shadowRoot) {\n        searchCanvas(shadowRoot);\n      }\n    }\n    return matchedCanvas;\n  }\n  /**\n   * Takes a snapshot of the provided canvas element, or will search all windows/shadow roots for canvases. Will self-throttle based on `options.sampling`.\n   *\n   * @returns `true` if the snapshot was taken, `false` if it was throttled.\n   */\n  takeSnapshot(timestamp, isManualSnapshot, canvasElement) {\n    const {\n      sampling,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      dataURLOptions,\n      maxCanvasSize\n    } = this.options;\n    const fps = sampling === \"all\" ? 2 : sampling || 2;\n    const timeBetweenSnapshots = 1e3 / fps;\n    const shouldThrottle = this.lastSnapshotTime && timestamp - this.lastSnapshotTime < timeBetweenSnapshots;\n    if (shouldThrottle) {\n      return false;\n    }\n    this.lastSnapshotTime = timestamp;\n    const canvases = canvasElement ? [canvasElement] : this.getCanvasElements(blockClass, blockSelector, unblockSelector);\n    canvases.forEach((canvas) => {\n      const id = this.mirror.getId(canvas);\n      if (!this.mirror.hasNode(canvas) || !canvas.width || !canvas.height || this.snapshotInProgressMap.get(id)) {\n        return;\n      }\n      this.snapshotInProgressMap.set(id, true);\n      if (!isManualSnapshot && [\"webgl\", \"webgl2\"].includes(canvas.__context)) {\n        const context = canvas.getContext(canvas.__context);\n        if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\n          context.clear(context.COLOR_BUFFER_BIT);\n        }\n      }\n      createImageBitmap(canvas).then((bitmap) => {\n        this.worker?.postMessage(\n          {\n            id,\n            bitmap,\n            width: canvas.width,\n            height: canvas.height,\n            dataURLOptions,\n            maxCanvasSize\n          },\n          [bitmap]\n        );\n      }).catch((error) => {\n        callbackWrapper(() => {\n          this.snapshotInProgressMap.delete(id);\n          throw error;\n        })();\n      });\n    });\n    return true;\n  }\n  startPendingCanvasMutationFlusher() {\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = (timestamp) => {\n      this.rafStamps.latestId = timestamp;\n      onRequestAnimationFrame(setLatestRAFTimestamp);\n    };\n    onRequestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach(\n      (_values, canvas) => {\n        const id = this.mirror.getId(canvas);\n        this.flushPendingCanvasMutationFor(canvas, id);\n      }\n    );\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map((value) => {\n      const { type: type2, ...rest } = value;\n      return rest;\n    });\n    const { type } = valuesWithType[0];\n    this.mutationCb({ id, type, commands: values });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\ncreateMirror$2();\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\n\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25,\n    },\n  },\n  medium: {\n    sampling: {\n      canvas: 2,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4,\n    },\n  },\n  high: {\n    sampling: {\n      canvas: 4,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5,\n    },\n  },\n};\n\nconst INTEGRATION_NAME = 'ReplayCanvas';\nconst DEFAULT_MAX_CANVAS_SIZE = 1280;\n\n/** Exported only for type safe tests. */\nconst _replayCanvasIntegration = ((options = {}) => {\n  const [maxCanvasWidth, maxCanvasHeight] = options.maxCanvasSize || [];\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot,\n    maxCanvasSize: [\n      maxCanvasWidth ? Math.min(maxCanvasWidth, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n      maxCanvasHeight ? Math.min(maxCanvasHeight, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n    ] ,\n  };\n\n  let canvasManagerResolve;\n  const _canvasManager = new Promise(resolve => (canvasManagerResolve = resolve));\n\n  return {\n    name: INTEGRATION_NAME,\n    getOptions() {\n      const { quality, enableManualSnapshot, maxCanvasSize } = _canvasOptions;\n\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: (getCanvasManagerOptions) => {\n          const manager = new CanvasManager({\n            ...getCanvasManagerOptions,\n            enableManualSnapshot,\n            maxCanvasSize,\n            errorHandler: (err) => {\n              try {\n                if (typeof err === 'object') {\n                  (err ).__rrweb__ = true;\n                }\n              } catch {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            },\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality] || CANVAS_QUALITY.medium),\n      };\n    },\n    async snapshot(canvasElement, options) {\n      const canvasManager = await _canvasManager;\n\n      canvasManager.snapshot(canvasElement, options);\n    },\n  };\n}) ;\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nconst replayCanvasIntegration = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.defineIntegration)(\n  _replayCanvasIntegration,\n) ;\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeS1pbnRlcm5hbCtyZXBsYXktY2FudmFzQDEwLjI1LjAvbm9kZV9tb2R1bGVzL0BzZW50cnktaW50ZXJuYWwvcmVwbGF5LWNhbnZhcy9idWlsZC9ucG0vZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEOztBQUVqRDtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNKQUFzSixLQUFLLHlCQUF5QixrQkFBa0IsMENBQTBDLFFBQVEsSUFBSSw4RkFBOEYsNEZBQTRGLDBCQUEwQixhQUFhLDhCQUE4QiwyREFBMkQsYUFBYSxHQUFHLE1BQU0sZ0VBQWdFLGdDQUFnQyxnQkFBZ0IsbUNBQW1DLDRCQUE0QixpQ0FBaUMsbUJBQW1CLGdFQUFnRSxvQkFBb0IsU0FBUyw4QkFBOEIsa0JBQWtCLGFBQWEsMEJBQTBCLFlBQVksMkVBQTJFLGdIQUFnSCxpREFBaUQsRUFBRSx3Q0FBd0MseUVBQXlFLHFFQUFxRSxLQUFLLEVBQUUsc0NBQXNDLEtBQUssRUFBRSxlQUFlLHNDQUFzQyxlQUFlO0FBQzNnRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsWUFBWSxPQUFPO0FBQ25CLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUErQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFpQjtBQUNqRDtBQUNBOztBQUVtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dvcmtzcGFjZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5LWludGVybmFsK3JlcGxheS1jYW52YXNAMTAuMjUuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9yZXBsYXktY2FudmFzL2J1aWxkL25wbS9lc20vaW5kZXguanM/MTBlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY2xhc3MgTWlycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWROb2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm5vZGVNZXRhTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgfVxuICBnZXRJZChuMikge1xuICAgIGlmICghbjIpIHJldHVybiAtMTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TWV0YShuMik/LmlkO1xuICAgIHJldHVybiBpZCA/PyAtMTtcbiAgfVxuICBnZXROb2RlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRJZHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcbiAgfVxuICBnZXRNZXRhKG4yKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuZ2V0KG4yKSB8fCBudWxsO1xuICB9XG4gIC8vIHJlbW92ZXMgdGhlIG5vZGUgZnJvbSBpZE5vZGVNYXBcbiAgLy8gZG9lc24ndCByZW1vdmUgdGhlIG5vZGUgZnJvbSBub2RlTWV0YU1hcFxuICByZW1vdmVOb2RlRnJvbU1hcChuMikge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZChuMik7XG4gICAgdGhpcy5pZE5vZGVNYXAuZGVsZXRlKGlkKTtcbiAgICBpZiAobjIuY2hpbGROb2Rlcykge1xuICAgICAgbjIuY2hpbGROb2Rlcy5mb3JFYWNoKFxuICAgICAgICAoY2hpbGROb2RlKSA9PiB0aGlzLnJlbW92ZU5vZGVGcm9tTWFwKGNoaWxkTm9kZSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGhhcyhpZCkge1xuICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5oYXMoaWQpO1xuICB9XG4gIGhhc05vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlKTtcbiAgfVxuICBhZGQobjIsIG1ldGEpIHtcbiAgICBjb25zdCBpZCA9IG1ldGEuaWQ7XG4gICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobjIsIG1ldGEpO1xuICB9XG4gIHJlcGxhY2UoaWQsIG4yKSB7XG4gICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgaWYgKG9sZE5vZGUpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLm5vZGVNZXRhTWFwLmdldChvbGROb2RlKTtcbiAgICAgIGlmIChtZXRhKSB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbjIpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaWROb2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm5vZGVNZXRhTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pcnJvciQyKCkge1xuICByZXR1cm4gbmV3IE1pcnJvcigpO1xufVxuZnVuY3Rpb24gZWxlbWVudENsYXNzTWF0Y2hlc1JlZ2V4KGVsLCByZWdleCkge1xuICBmb3IgKGxldCBlSW5kZXggPSBlbC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTsgKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZWwuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgaWYgKHJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlVG9NYXRjaChub2RlLCBtYXRjaFByZWRpY2F0ZSwgbGltaXQgPSBJbmZpbml0eSwgZGlzdGFuY2UgPSAwKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIC0xO1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5FTEVNRU5UX05PREUpIHJldHVybiAtMTtcbiAgaWYgKGRpc3RhbmNlID4gbGltaXQpIHJldHVybiAtMTtcbiAgaWYgKG1hdGNoUHJlZGljYXRlKG5vZGUpKSByZXR1cm4gZGlzdGFuY2U7XG4gIHJldHVybiBkaXN0YW5jZVRvTWF0Y2gobm9kZS5wYXJlbnROb2RlLCBtYXRjaFByZWRpY2F0ZSwgbGltaXQsIGRpc3RhbmNlICsgMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXRjaFByZWRpY2F0ZShjbGFzc05hbWUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsID0gbm9kZTtcbiAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChlbC5tYXRjaGVzKGAuJHtjbGFzc05hbWV9YCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRDbGFzc01hdGNoZXNSZWdleChlbCwgY2xhc3NOYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0b3IgJiYgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9IFwiUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LFxcclxcbm5vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLFxcclxcbm9yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy5cIjtcbmxldCBfbWlycm9yID0ge1xuICBtYXA6IHt9LFxuICBnZXRJZCgpIHtcbiAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuICBnZXROb2RlKCkge1xuICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgcmVtb3ZlTm9kZUZyb21NYXAoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICB9LFxuICBoYXMoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVzZXQoKSB7XG4gICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICB9XG59O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XG4gIF9taXJyb3IgPSBuZXcgUHJveHkoX21pcnJvciwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJtYXBcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luID0gd2luZG93KSB7XG4gIGNvbnN0IG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB3aW4uT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgaXNSZXZva2VkID8gZCA6IHtcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0JDEoKCkgPT4ge1xuICAgICAgICAgIGQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNldCkge1xuICAgICAgICAgIG9yaWdpbmFsLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIG9yaWdpbmFsIHx8IHt9LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcbiAgICBjb25zdCB3cmFwcGVkID0gcmVwbGFjZW1lbnQob3JpZ2luYWwpO1xuICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xuICAgICAgICBfX3Jyd2ViX29yaWdpbmFsX186IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHNvdXJjZVtuYW1lXSA9IHdyYXBwZWQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsO1xuICAgIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfVxufVxuaWYgKCEvKiBAX19QVVJFX18gKi8gL1sxLTldWzAtOV17MTJ9Ly50ZXN0KERhdGUubm93KCkudG9TdHJpbmcoKSkpIDtcbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB1bmJsb2NrU2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbCA9IGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUpO1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrZWRQcmVkaWNhdGUgPSBjcmVhdGVNYXRjaFByZWRpY2F0ZShibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgaWYgKCFjaGVja0FuY2VzdG9ycykge1xuICAgIGNvbnN0IGlzVW5ibG9ja2VkID0gdW5ibG9ja1NlbGVjdG9yICYmIGVsLm1hdGNoZXModW5ibG9ja1NlbGVjdG9yKTtcbiAgICByZXR1cm4gYmxvY2tlZFByZWRpY2F0ZShlbCkgJiYgIWlzVW5ibG9ja2VkO1xuICB9XG4gIGNvbnN0IGJsb2NrRGlzdGFuY2UgPSBkaXN0YW5jZVRvTWF0Y2goZWwsIGJsb2NrZWRQcmVkaWNhdGUpO1xuICBsZXQgdW5ibG9ja0Rpc3RhbmNlID0gLTE7XG4gIGlmIChibG9ja0Rpc3RhbmNlIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodW5ibG9ja1NlbGVjdG9yKSB7XG4gICAgdW5ibG9ja0Rpc3RhbmNlID0gZGlzdGFuY2VUb01hdGNoKFxuICAgICAgZWwsXG4gICAgICBjcmVhdGVNYXRjaFByZWRpY2F0ZShudWxsLCB1bmJsb2NrU2VsZWN0b3IpXG4gICAgKTtcbiAgfVxuICBpZiAoYmxvY2tEaXN0YW5jZSA+IC0xICYmIHVuYmxvY2tEaXN0YW5jZSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYmxvY2tEaXN0YW5jZSA8IHVuYmxvY2tEaXN0YW5jZTtcbn1cbmNvbnN0IGNhY2hlZEltcGxlbWVudGF0aW9ucyA9IHt9O1xuZnVuY3Rpb24gZ2V0SW1wbGVtZW50YXRpb24obmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZWRJbXBsZW1lbnRhdGlvbnNbbmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IGRvY3VtZW50MiA9IHdpbmRvdy5kb2N1bWVudDtcbiAgbGV0IGltcGwgPSB3aW5kb3dbbmFtZV07XG4gIGlmIChkb2N1bWVudDIgJiYgdHlwZW9mIGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2FuZGJveCA9IGRvY3VtZW50Mi5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgc2FuZGJveC5oaWRkZW4gPSB0cnVlO1xuICAgICAgZG9jdW1lbnQyLmhlYWQuYXBwZW5kQ2hpbGQoc2FuZGJveCk7XG4gICAgICBjb25zdCBjb250ZW50V2luZG93ID0gc2FuZGJveC5jb250ZW50V2luZG93O1xuICAgICAgaWYgKGNvbnRlbnRXaW5kb3cgJiYgY29udGVudFdpbmRvd1tuYW1lXSkge1xuICAgICAgICBpbXBsID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICBjb250ZW50V2luZG93W25hbWVdO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQyLmhlYWQucmVtb3ZlQ2hpbGQoc2FuZGJveCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhY2hlZEltcGxlbWVudGF0aW9uc1tuYW1lXSA9IGltcGwuYmluZChcbiAgICB3aW5kb3dcbiAgKTtcbn1cbmZ1bmN0aW9uIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpKC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gc2V0VGltZW91dCQxKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldEltcGxlbWVudGF0aW9uKFwic2V0VGltZW91dFwiKSguLi5yZXN0KTtcbn1cbnZhciBDYW52YXNDb250ZXh0ID0gLyogQF9fUFVSRV9fICovICgoQ2FudmFzQ29udGV4dDIpID0+IHtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCIyRFwiXSA9IDBdID0gXCIyRFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICByZXR1cm4gQ2FudmFzQ29udGV4dDI7XG59KShDYW52YXNDb250ZXh0IHx8IHt9KTtcbmxldCBlcnJvckhhbmRsZXI7XG5mdW5jdGlvbiByZWdpc3RlckVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG4gIGVycm9ySGFuZGxlciA9IGhhbmRsZXI7XG59XG5jb25zdCBjYWxsYmFja1dyYXBwZXIgPSAoY2IpID0+IHtcbiAgaWYgKCFlcnJvckhhbmRsZXIpIHtcbiAgICByZXR1cm4gY2I7XG4gIH1cbiAgY29uc3QgcnJ3ZWJXcmFwcGVkID0gKC4uLnJlc3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKC4uLnJlc3QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcbn07XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoYXJzLmxlbmd0aDsgaSQxKyspIHtcbiAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpMiwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHtcbiAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTJdID4+IDJdO1xuICAgIGJhc2U2NCArPSBjaGFyc1soYnl0ZXNbaTJdICYgMykgPDwgNCB8IGJ5dGVzW2kyICsgMV0gPj4gNF07XG4gICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdO1xuICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpMiArIDJdICYgNjNdO1xuICB9XG4gIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NDtcbn07XG5jb25zdCBjYW52YXNWYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yJDEoY3R4LCBjdG9yKSB7XG4gIGxldCBjb250ZXh0TWFwID0gY2FudmFzVmFyTWFwLmdldChjdHgpO1xuICBpZiAoIWNvbnRleHRNYXApIHtcbiAgICBjb250ZXh0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjYW52YXNWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XG4gIH1cbiAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xuICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcbiAgfVxuICByZXR1cm4gY29udGV4dE1hcC5nZXQoY3Rvcik7XG59XG5jb25zdCBzYXZlV2ViR0xWYXIgPSAodmFsdWUsIHdpbiwgY3R4KSA9PiB7XG4gIGlmICghdmFsdWUgfHwgIShpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpKVxuICAgIHJldHVybjtcbiAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGNvbnN0IGxpc3QgPSB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIG5hbWUpO1xuICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YodmFsdWUpO1xuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgaW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgICBsaXN0LnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVBcmcodmFsdWUsIHdpbiwgY3R4KSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoYXJnKSA9PiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCkpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IHZhbHVlIGluc3RhbmNlb2YgSW50MTZBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbT2JqZWN0LnZhbHVlcyh2YWx1ZSldXG4gICAgfTtcbiAgfSBlbHNlIGlmIChcbiAgICAvLyBTaGFyZWRBcnJheUJ1ZmZlciBkaXNhYmxlZCBvbiBtb3N0IGJyb3dzZXJzIGR1ZSB0byBzcGVjdHJlLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2hhcmVkQXJyYXlCdWZmZXIvU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAvLyB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyIHx8XG4gICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICApIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgYmFzZTY0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcbiAgICAgICAgdmFsdWUuYnl0ZU9mZnNldCxcbiAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgXVxuICAgIH07XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgY29uc3QgeyBzcmMgfSA9IHZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgY29uc3QgbmFtZSA9IFwiSFRNTEltYWdlRWxlbWVudFwiO1xuICAgIGNvbnN0IHNyYyA9IHZhbHVlLnRvRGF0YVVSTCgpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgYXJnczogW3NlcmlhbGl6ZUFyZyh2YWx1ZS5kYXRhLCB3aW4sIGN0eCksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICBjb25zdCBpbmRleCA9IHNhdmVXZWJHTFZhcih2YWx1ZSwgd2luLCBjdHgpO1xuICAgIHJldHVybiB7XG4gICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgaW5kZXhcbiAgICB9O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHNlcmlhbGl6ZUFyZ3MgPSAoYXJncywgd2luLCBjdHgpID0+IHtcbiAgcmV0dXJuIGFyZ3MubWFwKChhcmcpID0+IHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KSk7XG59O1xuY29uc3QgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSAodmFsdWUsIHdpbikgPT4ge1xuICBjb25zdCB3ZWJHTENvbnN0cnVjdG9yTmFtZXMgPSBbXG4gICAgXCJXZWJHTEFjdGl2ZUluZm9cIixcbiAgICBcIldlYkdMQnVmZmVyXCIsXG4gICAgXCJXZWJHTEZyYW1lYnVmZmVyXCIsXG4gICAgXCJXZWJHTFByb2dyYW1cIixcbiAgICBcIldlYkdMUmVuZGVyYnVmZmVyXCIsXG4gICAgXCJXZWJHTFNoYWRlclwiLFxuICAgIFwiV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXRcIixcbiAgICBcIldlYkdMVGV4dHVyZVwiLFxuICAgIFwiV2ViR0xVbmlmb3JtTG9jYXRpb25cIixcbiAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RcIixcbiAgICAvLyBJbiBvbGQgQ2hyb21lIHZlcnNpb25zLCB2YWx1ZSB3b24ndCBiZSBhbiBpbnN0YW5jZW9mIFdlYkdMVmVydGV4QXJyYXlPYmplY3QuXG4gICAgXCJXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTXCJcbiAgXTtcbiAgY29uc3Qgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gd2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbHRlcihcbiAgICAobmFtZSkgPT4gdHlwZW9mIHdpbltuYW1lXSA9PT0gXCJmdW5jdGlvblwiXG4gICk7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKFxuICAgICAgKG5hbWUpID0+IHZhbHVlIGluc3RhbmNlb2Ygd2luW25hbWVdXG4gICAgKVxuICApO1xufTtcbmZ1bmN0aW9uIGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzczIsIGJsb2NrU2VsZWN0b3IsIHVuYmxvY2tTZWxlY3Rvcikge1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBjb25zdCBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXG4gICAgd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVcbiAgKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzMkQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtwcm9wXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChcbiAgICAgICAgd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKFxuICAgICAgICAgICAgICB0aGlzLmNhbnZhcyxcbiAgICAgICAgICAgICAgYmxvY2tDbGFzczIsXG4gICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0JDEoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIoXG4gICAgICAgIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLFxuICAgICAgICBwcm9wLFxuICAgICAgICB7XG4gICAgICAgICAgc2V0KHYyKSB7XG4gICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICBhcmdzOiBbdjJdLFxuICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcbiAgcmV0dXJuIGNvbnRleHRUeXBlID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiID8gXCJ3ZWJnbFwiIDogY29udGV4dFR5cGU7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCBzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUpIHtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKFxuICAgICAgd2luLkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgIFwiZ2V0Q29udGV4dFwiLFxuICAgICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHRUeXBlLCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XG4gICAgICAgICAgICBpZiAoIShcIl9fY29udGV4dFwiIGluIHRoaXMpKSB0aGlzLl9fY29udGV4dCA9IGN0eE5hbWU7XG4gICAgICAgICAgICBpZiAoc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlICYmIFtcIndlYmdsXCIsIFwid2ViZ2wyXCJdLmluY2x1ZGVzKGN0eE5hbWUpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgwLCAxLCB7XG4gICAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2NvbnRleHRUeXBlLCAuLi5hcmdzXSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgfSBjYXRjaCB7XG4gICAgY29uc29sZS5lcnJvcihcImZhaWxlZCB0byBwYXRjaCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dFwiKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGgpID0+IGgoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBwYXRjaEdMUHJvdG90eXBlKHByb3RvdHlwZSwgdHlwZSwgY2IsIGJsb2NrQ2xhc3MyLCBibG9ja1NlbGVjdG9yLCB1bmJsb2NrU2VsZWN0b3IsIF9taXJyb3IyLCB3aW4pIHtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICBpZiAoXG4gICAgICAvL3Byb3Auc3RhcnRzV2l0aCgnZ2V0JykgfHwgIC8vIGUuZy4gZ2V0UHJvZ3JhbVBhcmFtZXRlciwgYnV0IHRvbyByaXNreVxuICAgICAgW1xuICAgICAgICBcImlzQ29udGV4dExvc3RcIixcbiAgICAgICAgXCJjYW52YXNcIixcbiAgICAgICAgXCJkcmF3aW5nQnVmZmVyV2lkdGhcIixcbiAgICAgICAgXCJkcmF3aW5nQnVmZmVySGVpZ2h0XCJcbiAgICAgIF0uaW5jbHVkZXMocHJvcClcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goXG4gICAgICAgIHByb3RvdHlwZSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0LCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIHRoaXMuY2FudmFzICYmICFpc0Jsb2NrZWQoXG4gICAgICAgICAgICAgIHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgICBibG9ja0NsYXNzMixcbiAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgdW5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XG4gICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIocHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgIHNldCh2Mikge1xuICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBhcmdzOiBbdjJdLFxuICAgICAgICAgICAgc2V0dGVyOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYW5kbGVycztcbn1cbmZ1bmN0aW9uIGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzczIsIGJsb2NrU2VsZWN0b3IsIHVuYmxvY2tTZWxlY3RvciwgbWlycm9yMikge1xuICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICBoYW5kbGVycy5wdXNoKFxuICAgIC4uLnBhdGNoR0xQcm90b3R5cGUoXG4gICAgICB3aW4uV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSxcbiAgICAgIENhbnZhc0NvbnRleHQuV2ViR0wsXG4gICAgICBjYixcbiAgICAgIGJsb2NrQ2xhc3MyLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIG1pcnJvcjIsXG4gICAgICB3aW5cbiAgICApXG4gICk7XG4gIGlmICh0eXBlb2Ygd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBoYW5kbGVycy5wdXNoKFxuICAgICAgLi4ucGF0Y2hHTFByb3RvdHlwZShcbiAgICAgICAgd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLFxuICAgICAgICBDYW52YXNDb250ZXh0LldlYkdMMixcbiAgICAgICAgY2IsXG4gICAgICAgIGJsb2NrQ2xhc3MyLFxuICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICAgIG1pcnJvcjIsXG4gICAgICAgIHdpblxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xuICB9O1xufVxuY29uc3QgciQxID0gYGZvcih2YXIgZT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIix0PVwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P1tdOm5ldyBVaW50OEFycmF5KDI1NiksYT0wO2E8NjQ7YSsrKXRbZS5jaGFyQ29kZUF0KGEpXT1hO3ZhciBuPWZ1bmN0aW9uKHQpe3ZhciBhLG49bmV3IFVpbnQ4QXJyYXkodCkscj1uLmxlbmd0aCxzPVwiXCI7Zm9yKGE9MDthPHI7YSs9MylzKz1lW25bYV0+PjJdLHMrPWVbKDMmblthXSk8PDR8blthKzFdPj40XSxzKz1lWygxNSZuW2ErMV0pPDwyfG5bYSsyXT4+Nl0scys9ZVs2MyZuW2ErMl1dO3JldHVybiByJTM9PTI/cz1zLnN1YnN0cmluZygwLHMubGVuZ3RoLTEpK1wiPVwiOnIlMz09MSYmKHM9cy5zdWJzdHJpbmcoMCxzLmxlbmd0aC0yKStcIj09XCIpLHN9O2NvbnN0IHI9bmV3IE1hcCxzPW5ldyBNYXA7Y29uc3QgaT1zZWxmO2kub25tZXNzYWdlPWFzeW5jIGZ1bmN0aW9uKGUpe2lmKCEoXCJPZmZzY3JlZW5DYW52YXNcImluIGdsb2JhbFRoaXMpKXJldHVybiBpLnBvc3RNZXNzYWdlKHtpZDplLmRhdGEuaWR9KTt7Y29uc3R7aWQ6dCxiaXRtYXA6YSx3aWR0aDpvLGhlaWdodDpmLG1heENhbnZhc1NpemU6YyxkYXRhVVJMT3B0aW9uczpnfT1lLmRhdGEsdT1hc3luYyBmdW5jdGlvbihlLHQsYSl7Y29uc3Qgcj1lK1wiLVwiK3Q7aWYoXCJPZmZzY3JlZW5DYW52YXNcImluIGdsb2JhbFRoaXMpe2lmKHMuaGFzKHIpKXJldHVybiBzLmdldChyKTtjb25zdCBpPW5ldyBPZmZzY3JlZW5DYW52YXMoZSx0KTtpLmdldENvbnRleHQoXCIyZFwiKTtjb25zdCBvPWF3YWl0IGkuY29udmVydFRvQmxvYihhKSxmPWF3YWl0IG8uYXJyYXlCdWZmZXIoKSxjPW4oZik7cmV0dXJuIHMuc2V0KHIsYyksY31yZXR1cm5cIlwifShvLGYsZyksW2gsZF09ZnVuY3Rpb24oZSx0LGEpe2lmKCFhKXJldHVybltlLHRdO2NvbnN0W24scl09YTtpZihlPD1uJiZ0PD1yKXJldHVybltlLHRdO2xldCBzPWUsaT10O3JldHVybiBzPm4mJihpPU1hdGguZmxvb3Iobip0L2UpLHM9biksaT5yJiYocz1NYXRoLmZsb29yKHIqZS90KSxpPXIpLFtzLGldfShvLGYsYyksbD1uZXcgT2Zmc2NyZWVuQ2FudmFzKGgsZCksdz1sLmdldENvbnRleHQoXCJiaXRtYXByZW5kZXJlclwiKSxwPWg9PT1vJiZkPT09Zj9hOmF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGEse3Jlc2l6ZVdpZHRoOmgscmVzaXplSGVpZ2h0OmQscmVzaXplUXVhbGl0eTpcImxvd1wifSk7dz8udHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAocCksYS5jbG9zZSgpO2NvbnN0IHk9YXdhaXQgbC5jb252ZXJ0VG9CbG9iKGcpLHY9eS50eXBlLGI9YXdhaXQgeS5hcnJheUJ1ZmZlcigpLG09bihiKTtpZihwLmNsb3NlKCksIXIuaGFzKHQpJiZhd2FpdCB1PT09bSlyZXR1cm4gci5zZXQodCxtKSxpLnBvc3RNZXNzYWdlKHtpZDp0fSk7aWYoci5nZXQodCk9PT1tKXJldHVybiBpLnBvc3RNZXNzYWdlKHtpZDp0fSk7aS5wb3N0TWVzc2FnZSh7aWQ6dCx0eXBlOnYsYmFzZTY0Om0sd2lkdGg6byxoZWlnaHQ6Zn0pLHIuc2V0KHQsbSl9fTtgO1xuZnVuY3Rpb24gdCQxKCkge1xuICBjb25zdCB0MiA9IG5ldyBCbG9iKFtyJDFdKTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodDIpO1xufVxuY2xhc3MgQ2FudmFzTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucmFmU3RhbXBzID0geyBsYXRlc3RJZDogMCwgaW52b2tlSWQ6IG51bGwgfTtcbiAgICB0aGlzLnNoYWRvd0RvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMud2luZG93c1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMud2luZG93cyA9IFtdO1xuICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuc25hcHNob3RJblByb2dyZXNzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgdGhpcy5sYXN0U25hcHNob3RUaW1lID0gMDtcbiAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9ICh0YXJnZXQsIG11dGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBuZXdGcmFtZSA9IHRoaXMucmFmU3RhbXBzLmludm9rZUlkICYmIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkICE9PSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcbiAgICAgIGlmIChuZXdGcmFtZSB8fCAhdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpXG4gICAgICAgIHRoaXMucmFmU3RhbXBzLmludm9rZUlkID0gdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldCh0YXJnZXQpLnB1c2gobXV0YXRpb24pO1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlTWFudWFsU25hcHNob3QsXG4gICAgICBzYW1wbGluZyA9IFwiYWxsXCIsXG4gICAgICB3aW4sXG4gICAgICByZWNvcmRDYW52YXMsXG4gICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcjJcbiAgICB9ID0gb3B0aW9ucztcbiAgICBvcHRpb25zLnNhbXBsaW5nID0gc2FtcGxpbmc7XG4gICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZXJyb3JIYW5kbGVyMikge1xuICAgICAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyMik7XG4gICAgfVxuICAgIGlmIChyZWNvcmRDYW52YXMgJiYgdHlwZW9mIHNhbXBsaW5nID09PSBcIm51bWJlclwiIHx8IGVuYWJsZU1hbnVhbFNuYXBzaG90KSB7XG4gICAgICB0aGlzLndvcmtlciA9IHRoaXMuaW5pdEZQU1dvcmtlcigpO1xuICAgIH1cbiAgICB0aGlzLmFkZFdpbmRvdyh3aW4pO1xuICAgIGlmIChlbmFibGVNYW51YWxTbmFwc2hvdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xuICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiBzYW1wbGluZyA9PT0gXCJhbGxcIikge1xuICAgICAgICB0aGlzLnN0YXJ0UkFGVGltZXN0YW1waW5nKCk7XG4gICAgICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHR5cGVvZiBzYW1wbGluZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLmluaXRDYW52YXNGUFNPYnNlcnZlcigpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xuICAgIHRoaXMud2luZG93c1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMud2luZG93cyA9IFtdO1xuICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy53b3JrZXI/LnRlcm1pbmF0ZSgpO1xuICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICB0aGlzLnNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgfVxuICB1bmZyZWV6ZSgpIHtcbiAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICB9XG4gIHVubG9jaygpIHtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB9XG4gIGFkZFdpbmRvdyh3aW4pIHtcbiAgICBjb25zdCB7XG4gICAgICBzYW1wbGluZyA9IFwiYWxsXCIsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIHJlY29yZENhbnZhcyxcbiAgICAgIGVuYWJsZU1hbnVhbFNuYXBzaG90XG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy53aW5kb3dzU2V0Lmhhcyh3aW4pKSByZXR1cm47XG4gICAgaWYgKGVuYWJsZU1hbnVhbFNuYXBzaG90KSB7XG4gICAgICB0aGlzLndpbmRvd3NTZXQuYWRkKHdpbik7XG4gICAgICB0aGlzLndpbmRvd3MucHVzaChuZXcgV2Vha1JlZih3aW4pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgc2FtcGxpbmcgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcihcbiAgICAgICAgICB3aW4sXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIHVuYmxvY2tTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiB0eXBlb2Ygc2FtcGxpbmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcihcbiAgICAgICAgICB3aW4sXG4gICAgICAgICAgYmxvY2tDbGFzcyxcbiAgICAgICAgICBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHRoaXMud2luZG93c1NldC5hZGQod2luKTtcbiAgICB0aGlzLndpbmRvd3MucHVzaChuZXcgV2Vha1JlZih3aW4pKTtcbiAgfVxuICBhZGRTaGFkb3dSb290KHNoYWRvd1Jvb3QpIHtcbiAgICB0aGlzLnNoYWRvd0RvbXMuYWRkKG5ldyBXZWFrUmVmKHNoYWRvd1Jvb3QpKTtcbiAgfVxuICByZXNldFNoYWRvd1Jvb3RzKCkge1xuICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgc25hcHNob3QoY2FudmFzRWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5za2lwUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLnRha2VTbmFwc2hvdChwZXJmb3JtYW5jZS5ub3coKSwgdHJ1ZSwgY2FudmFzRWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgKHRpbWVzdGFtcCkgPT4gdGhpcy50YWtlU25hcHNob3QodGltZXN0YW1wLCB0cnVlLCBjYW52YXNFbGVtZW50KVxuICAgICk7XG4gIH1cbiAgaW5pdEZQU1dvcmtlcigpIHtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHQkMSgpKTtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKGUyKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZTIuZGF0YTtcbiAgICAgIGNvbnN0IHsgaWQgfSA9IGRhdGE7XG4gICAgICB0aGlzLnNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcbiAgICAgIGlmICghKFwiYmFzZTY0XCIgaW4gZGF0YSkpIHJldHVybjtcbiAgICAgIGNvbnN0IHsgYmFzZTY0LCB0eXBlLCB3aWR0aCwgaGVpZ2h0IH0gPSBkYXRhO1xuICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJjbGVhclJlY3RcIixcbiAgICAgICAgICAgIC8vIHdpcGUgY2FudmFzXG4gICAgICAgICAgICBhcmdzOiBbMCwgMCwgd2lkdGgsIGhlaWdodF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImRyYXdJbWFnZVwiLFxuICAgICAgICAgICAgLy8gZHJhd3MgKHNlbWktdHJhbnNwYXJlbnQpIGltYWdlXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBycl90eXBlOiBcIkltYWdlQml0bWFwXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBycl90eXBlOiBcIkJsb2JcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3sgcnJfdHlwZTogXCJBcnJheUJ1ZmZlclwiLCBiYXNlNjQgfV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIC8vIFRoZSBiZWxvdyBhcmdzIGFyZSBuZWVkZWQgaWYgd2UgZW5mb3JjZSBhIG1heCBzaXplLCB3ZSB3YW50IHRvXG4gICAgICAgICAgICAgIC8vIHJldGFpbiB0aGUgb3JpZ2luYWwgc2l6ZSB3aGVuIGRyYXdpbmcgdGhlIGltYWdlICh3aGljaCBzaG91bGQgYmUgc21hbGxlcilcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG4gIGluaXRDYW52YXNGUFNPYnNlcnZlcigpIHtcbiAgICBsZXQgcmFmSWQ7XG4gICAgaWYgKCF0aGlzLndpbmRvd3MubGVuZ3RoICYmICF0aGlzLnNoYWRvd0RvbXMuc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYWZDYWxsYmFjayA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgIHRoaXMudGFrZVNuYXBzaG90KHRpbWVzdGFtcCwgZmFsc2UpO1xuICAgICAgcmFmSWQgPSBvblJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgfTtcbiAgICByYWZJZCA9IG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKCgpID0+IHtcbiAgICAgIGlmIChyYWZJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB1bmJsb2NrU2VsZWN0b3IpIHtcbiAgICBjb25zdCBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKFxuICAgICAgd2luLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgY2FudmFzMkRSZXNldCA9IGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgd2luLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3JcbiAgICApO1xuICAgIGNvbnN0IGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgd2luLFxuICAgICAgYmxvY2tDbGFzcyxcbiAgICAgIGJsb2NrU2VsZWN0b3IsXG4gICAgICB1bmJsb2NrU2VsZWN0b3IsXG4gICAgICB0aGlzLm1pcnJvclxuICAgICk7XG4gICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaCgoKSA9PiB7XG4gICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcbiAgICAgIGNhbnZhczJEUmVzZXQoKTtcbiAgICAgIGNhbnZhc1dlYkdMMWFuZDJSZXNldCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBgY2FudmFzYCBlbGVtZW50cyB0aGF0IGFyZSBub3QgYmxvY2tlZCBieSB0aGUgZ2l2ZW4gc2VsZWN0b3JzLiBTZWFyY2hlcyBhbGwgd2luZG93cyBhbmQgc2hhZG93IHJvb3RzLlxuICAgKi9cbiAgZ2V0Q2FudmFzRWxlbWVudHMoYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yKSB7XG4gICAgY29uc3QgbWF0Y2hlZENhbnZhcyA9IFtdO1xuICAgIGNvbnN0IHNlYXJjaENhbnZhcyA9IChyb290KSA9PiB7XG4gICAgICByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYW52YXNcIikuZm9yRWFjaCgoY2FudmFzKSA9PiB7XG4gICAgICAgIGlmICghaXNCbG9ja2VkKGNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLndpbmRvd3MpIHtcbiAgICAgIGNvbnN0IHdpbmRvdzIgPSBpdGVtLmRlcmVmKCk7XG4gICAgICBsZXQgX2RvY3VtZW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgX2RvY3VtZW50ID0gd2luZG93MiAmJiB3aW5kb3cyLmRvY3VtZW50O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpZiAoX2RvY3VtZW50KSB7XG4gICAgICAgIHNlYXJjaENhbnZhcyhfZG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5zaGFkb3dEb21zKSB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gaXRlbS5kZXJlZigpO1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2VhcmNoQ2FudmFzKHNoYWRvd1Jvb3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlZENhbnZhcztcbiAgfVxuICAvKipcbiAgICogVGFrZXMgYSBzbmFwc2hvdCBvZiB0aGUgcHJvdmlkZWQgY2FudmFzIGVsZW1lbnQsIG9yIHdpbGwgc2VhcmNoIGFsbCB3aW5kb3dzL3NoYWRvdyByb290cyBmb3IgY2FudmFzZXMuIFdpbGwgc2VsZi10aHJvdHRsZSBiYXNlZCBvbiBgb3B0aW9ucy5zYW1wbGluZ2AuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc25hcHNob3Qgd2FzIHRha2VuLCBgZmFsc2VgIGlmIGl0IHdhcyB0aHJvdHRsZWQuXG4gICAqL1xuICB0YWtlU25hcHNob3QodGltZXN0YW1wLCBpc01hbnVhbFNuYXBzaG90LCBjYW52YXNFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2FtcGxpbmcsXG4gICAgICBibG9ja0NsYXNzLFxuICAgICAgYmxvY2tTZWxlY3RvcixcbiAgICAgIHVuYmxvY2tTZWxlY3RvcixcbiAgICAgIGRhdGFVUkxPcHRpb25zLFxuICAgICAgbWF4Q2FudmFzU2l6ZVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZnBzID0gc2FtcGxpbmcgPT09IFwiYWxsXCIgPyAyIDogc2FtcGxpbmcgfHwgMjtcbiAgICBjb25zdCB0aW1lQmV0d2VlblNuYXBzaG90cyA9IDFlMyAvIGZwcztcbiAgICBjb25zdCBzaG91bGRUaHJvdHRsZSA9IHRoaXMubGFzdFNuYXBzaG90VGltZSAmJiB0aW1lc3RhbXAgLSB0aGlzLmxhc3RTbmFwc2hvdFRpbWUgPCB0aW1lQmV0d2VlblNuYXBzaG90cztcbiAgICBpZiAoc2hvdWxkVGhyb3R0bGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xuICAgIGNvbnN0IGNhbnZhc2VzID0gY2FudmFzRWxlbWVudCA/IFtjYW52YXNFbGVtZW50XSA6IHRoaXMuZ2V0Q2FudmFzRWxlbWVudHMoYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdW5ibG9ja1NlbGVjdG9yKTtcbiAgICBjYW52YXNlcy5mb3JFYWNoKChjYW52YXMpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgIGlmICghdGhpcy5taXJyb3IuaGFzTm9kZShjYW52YXMpIHx8ICFjYW52YXMud2lkdGggfHwgIWNhbnZhcy5oZWlnaHQgfHwgdGhpcy5zbmFwc2hvdEluUHJvZ3Jlc3NNYXAuZ2V0KGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIHRydWUpO1xuICAgICAgaWYgKCFpc01hbnVhbFNuYXBzaG90ICYmIFtcIndlYmdsXCIsIFwid2ViZ2wyXCJdLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChjYW52YXMuX19jb250ZXh0KTtcbiAgICAgICAgaWYgKGNvbnRleHQ/LmdldENvbnRleHRBdHRyaWJ1dGVzKCk/LnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyKGNvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhcykudGhlbigoYml0bWFwKSA9PiB7XG4gICAgICAgIHRoaXMud29ya2VyPy5wb3N0TWVzc2FnZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGJpdG1hcCxcbiAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIG1heENhbnZhc1NpemVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtiaXRtYXBdXG4gICAgICAgICk7XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNuYXBzaG90SW5Qcm9ncmVzc01hcC5kZWxldGUoaWQpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCkge1xuICAgIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkpO1xuICB9XG4gIHN0YXJ0UkFGVGltZXN0YW1waW5nKCkge1xuICAgIGNvbnN0IHNldExhdGVzdFJBRlRpbWVzdGFtcCA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgIHRoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xuICAgICAgb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICB9O1xuICAgIG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XG4gIH1cbiAgZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xuICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5mb3JFYWNoKFxuICAgICAgKF92YWx1ZXMsIGNhbnZhcykgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XG4gICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XG4gICAgICB9XG4gICAgKTtcbiAgICBvblJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpKTtcbiAgfVxuICBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKSB7XG4gICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xuICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKSByZXR1cm47XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlOiB0eXBlMiwgLi4ucmVzdCB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9KTtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHZhbHVlc1dpdGhUeXBlWzBdO1xuICAgIHRoaXMubXV0YXRpb25DYih7IGlkLCB0eXBlLCBjb21tYW5kczogdmFsdWVzIH0pO1xuICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5kZWxldGUoY2FudmFzKTtcbiAgfVxufVxudHJ5IHtcbiAgaWYgKEFycmF5LmZyb20oWzFdLCAoeCkgPT4geCAqIDIpWzBdICE9PSAyKSB7XG4gICAgY29uc3QgY2xlYW5GcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbGVhbkZyYW1lKTtcbiAgICBBcnJheS5mcm9tID0gY2xlYW5GcmFtZS5jb250ZW50V2luZG93Py5BcnJheS5mcm9tIHx8IEFycmF5LmZyb207XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjbGVhbkZyYW1lKTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIGNvbnNvbGUuZGVidWcoXCJVbmFibGUgdG8gb3ZlcnJpZGUgQXJyYXkuZnJvbVwiLCBlcnIpO1xufVxuY3JlYXRlTWlycm9yJDIoKTtcbnZhciBuO1xuIWZ1bmN0aW9uKHQyKSB7XG4gIHQyW3QyLk5vdFN0YXJ0ZWQgPSAwXSA9IFwiTm90U3RhcnRlZFwiLCB0Mlt0Mi5SdW5uaW5nID0gMV0gPSBcIlJ1bm5pbmdcIiwgdDJbdDIuU3RvcHBlZCA9IDJdID0gXCJTdG9wcGVkXCI7XG59KG4gfHwgKG4gPSB7fSkpO1xuXG5jb25zdCBDQU5WQVNfUVVBTElUWSA9IHtcbiAgbG93OiB7XG4gICAgc2FtcGxpbmc6IHtcbiAgICAgIGNhbnZhczogMSxcbiAgICB9LFxuICAgIGRhdGFVUkxPcHRpb25zOiB7XG4gICAgICB0eXBlOiAnaW1hZ2Uvd2VicCcsXG4gICAgICBxdWFsaXR5OiAwLjI1LFxuICAgIH0sXG4gIH0sXG4gIG1lZGl1bToge1xuICAgIHNhbXBsaW5nOiB7XG4gICAgICBjYW52YXM6IDIsXG4gICAgfSxcbiAgICBkYXRhVVJMT3B0aW9uczoge1xuICAgICAgdHlwZTogJ2ltYWdlL3dlYnAnLFxuICAgICAgcXVhbGl0eTogMC40LFxuICAgIH0sXG4gIH0sXG4gIGhpZ2g6IHtcbiAgICBzYW1wbGluZzoge1xuICAgICAgY2FudmFzOiA0LFxuICAgIH0sXG4gICAgZGF0YVVSTE9wdGlvbnM6IHtcbiAgICAgIHR5cGU6ICdpbWFnZS93ZWJwJyxcbiAgICAgIHF1YWxpdHk6IDAuNSxcbiAgICB9LFxuICB9LFxufTtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdSZXBsYXlDYW52YXMnO1xuY29uc3QgREVGQVVMVF9NQVhfQ0FOVkFTX1NJWkUgPSAxMjgwO1xuXG4vKiogRXhwb3J0ZWQgb25seSBmb3IgdHlwZSBzYWZlIHRlc3RzLiAqL1xuY29uc3QgX3JlcGxheUNhbnZhc0ludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgW21heENhbnZhc1dpZHRoLCBtYXhDYW52YXNIZWlnaHRdID0gb3B0aW9ucy5tYXhDYW52YXNTaXplIHx8IFtdO1xuICBjb25zdCBfY2FudmFzT3B0aW9ucyA9IHtcbiAgICBxdWFsaXR5OiBvcHRpb25zLnF1YWxpdHkgfHwgJ21lZGl1bScsXG4gICAgZW5hYmxlTWFudWFsU25hcHNob3Q6IG9wdGlvbnMuZW5hYmxlTWFudWFsU25hcHNob3QsXG4gICAgbWF4Q2FudmFzU2l6ZTogW1xuICAgICAgbWF4Q2FudmFzV2lkdGggPyBNYXRoLm1pbihtYXhDYW52YXNXaWR0aCwgREVGQVVMVF9NQVhfQ0FOVkFTX1NJWkUpIDogREVGQVVMVF9NQVhfQ0FOVkFTX1NJWkUsXG4gICAgICBtYXhDYW52YXNIZWlnaHQgPyBNYXRoLm1pbihtYXhDYW52YXNIZWlnaHQsIERFRkFVTFRfTUFYX0NBTlZBU19TSVpFKSA6IERFRkFVTFRfTUFYX0NBTlZBU19TSVpFLFxuICAgIF0gLFxuICB9O1xuXG4gIGxldCBjYW52YXNNYW5hZ2VyUmVzb2x2ZTtcbiAgY29uc3QgX2NhbnZhc01hbmFnZXIgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IChjYW52YXNNYW5hZ2VyUmVzb2x2ZSA9IHJlc29sdmUpKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IElOVEVHUkFUSU9OX05BTUUsXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgIGNvbnN0IHsgcXVhbGl0eSwgZW5hYmxlTWFudWFsU25hcHNob3QsIG1heENhbnZhc1NpemUgfSA9IF9jYW52YXNPcHRpb25zO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbmFibGVNYW51YWxTbmFwc2hvdCxcbiAgICAgICAgcmVjb3JkQ2FudmFzOiB0cnVlLFxuICAgICAgICBnZXRDYW52YXNNYW5hZ2VyOiAoZ2V0Q2FudmFzTWFuYWdlck9wdGlvbnMpID0+IHtcbiAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xuICAgICAgICAgICAgLi4uZ2V0Q2FudmFzTWFuYWdlck9wdGlvbnMsXG4gICAgICAgICAgICBlbmFibGVNYW51YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIG1heENhbnZhc1NpemUsXG4gICAgICAgICAgICBlcnJvckhhbmRsZXI6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIChlcnIgKS5fX3Jyd2ViX18gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBlcnJvciBpcyBmcm96ZW4gb3IgZG9lcyBub3QgYWxsb3cgbXV0YXRpb24gZm9yIG90aGVyIHJlYXNvbnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYW52YXNNYW5hZ2VyUmVzb2x2ZShtYW5hZ2VyKTtcbiAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uKENBTlZBU19RVUFMSVRZW3F1YWxpdHldIHx8IENBTlZBU19RVUFMSVRZLm1lZGl1bSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgc25hcHNob3QoY2FudmFzRWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgY29uc3QgY2FudmFzTWFuYWdlciA9IGF3YWl0IF9jYW52YXNNYW5hZ2VyO1xuXG4gICAgICBjYW52YXNNYW5hZ2VyLnNuYXBzaG90KGNhbnZhc0VsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogQWRkIHRoaXMgaW4gYWRkaXRpb24gdG8gYHJlcGxheUludGVncmF0aW9uKClgIHRvIGVuYWJsZSBjYW52YXMgcmVjb3JkaW5nLlxuICovXG5jb25zdCByZXBsYXlDYW52YXNJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uKFxuICBfcmVwbGF5Q2FudmFzSW50ZWdyYXRpb24sXG4pIDtcblxuZXhwb3J0IHsgcmVwbGF5Q2FudmFzSW50ZWdyYXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@sentry-internal+replay-canvas@10.25.0/node_modules/@sentry-internal/replay-canvas/build/npm/esm/index.js\n");

/***/ })

};
;